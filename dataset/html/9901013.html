<!DOCTYPE html><html lang="en">
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>[cs/9901013] Analysis of Approximate Nearest Neighbor Searching with Clustered Point SetsThe support of the National Science Foundation under grant CCR–9712379 is gratefully acknowledged.</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Analysis of Approximate Nearest Neighbor Searching with Clustered Point SetsThe support of the National Science Foundation under grant CCR–9712379 is gratefully acknowledged.">
<meta name="twitter:image:src" content="https://ar5iv.labs.arxiv.org/assets/ar5iv_card.png">
<meta name="twitter:image:alt" content="ar5iv logo">
<meta property="og:title" content="Analysis of Approximate Nearest Neighbor Searching with Clustered Point SetsThe support of the National Science Foundation under grant CCR–9712379 is gratefully acknowledged.">
<meta property="og:site_name" content="ar5iv">
<meta property="og:image" content="https://ar5iv.labs.arxiv.org/assets/ar5iv_card.png">
<meta property="og:type" content="article">
<meta property="og:url" content="https://ar5iv.labs.arxiv.org/html/cs/9901013">

<!--Generated on Sun Dec 18 07:58:15 2022 by LaTeXML (version 0.8.6) http://dlmf.nist.gov/LaTeXML/.-->
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<script>
  function detectColorScheme(){
    var theme="light";
    var current_theme = localStorage.getItem("ar5iv_theme");
    if(current_theme){
      if(current_theme == "dark"){
        theme = "dark";
      } }
    else if(!window.matchMedia) { return false; }
    else if(window.matchMedia("(prefers-color-scheme: dark)").matches) {
      theme = "dark"; }
    if (theme=="dark") {
      document.documentElement.setAttribute("data-theme", "dark");
    } else {
      document.documentElement.setAttribute("data-theme", "light"); } }

  detectColorScheme();

  function toggleColorScheme(){
    var current_theme = localStorage.getItem("ar5iv_theme");
    if (current_theme) {
      if (current_theme == "light") {
        localStorage.setItem("ar5iv_theme", "dark"); }
      else {
        localStorage.setItem("ar5iv_theme", "light"); } }
    else {
        localStorage.setItem("ar5iv_theme", "dark"); }
    detectColorScheme(); }
</script>
<link media="all" rel="stylesheet" href="/assets/ar5iv.0.7.6.min.css"><link media="all" rel="stylesheet" href="/assets/ar5iv-site.0.2.1.css">
</head>
<body>
<div class="ltx_page_main">
<div class="ltx_page_content">
<article class="ltx_document ltx_authors_1line"><span id="id1" class="ltx_note ltx_role_institutetext"><sup class="ltx_note_mark">1</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">1</sup><span class="ltx_note_type">institutetext: </span>
Department of Computer Science, University of Maryland, College Park,
Maryland. <span id="id1.1" class="ltx_note ltx_role_email"><sup class="ltx_note_mark">1</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">1</sup><span class="ltx_note_type">email: </span><span id="id1.1.1" class="ltx_text ltx_font_typewriter">songrit@cs.umd.edu</span></span></span></span><span id="id1.2" class="ltx_text ltx_font_typewriter">.
</span></span></span></span><span id="id2" class="ltx_note ltx_role_institutetext"><sup class="ltx_note_mark">2</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">2</sup><span class="ltx_note_type">institutetext: </span>Department of Computer Science and Institute for Advanced Computer
Studies, University of Maryland, College Park, Maryland.
<span id="id2.1" class="ltx_note ltx_role_email"><sup class="ltx_note_mark">2</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">2</sup><span class="ltx_note_type">email: </span>mount@cs.umd.edu</span></span></span>.</span></span></span>
<h1 class="ltx_title ltx_title_document">Analysis of Approximate Nearest Neighbor Searching
with Clustered Point Sets<span id="id1.id1" class="ltx_note ltx_role_thanks"><sup class="ltx_note_mark">†</sup><span class="ltx_note_outer"><span class="ltx_note_content"><sup class="ltx_note_mark">†</sup><span class="ltx_note_type">thanks: </span>The support of the National
Science Foundation under grant CCR–9712379 is gratefully
acknowledged.</span></span></span>
</h1>
<div class="ltx_authors">
<span class="ltx_creator ltx_role_author">
<span class="ltx_personname">Songrit Maneewongvatana
</span><span class="ltx_author_notes">11</span></span>
<span class="ltx_author_before">  </span><span class="ltx_creator ltx_role_author">
<span class="ltx_personname">David M. Mount
</span><span class="ltx_author_notes">22</span></span>
</div>

<section id="S1" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">1 </span>Introduction</h2>

<div id="S1.p1" class="ltx_para">
<p id="S1.p1.5" class="ltx_p">Nearest neighbor searching is the following problem: we are given a set
<math id="S1.p1.1.m1.1" class="ltx_Math" alttext="S" display="inline"><semantics id="S1.p1.1.m1.1a"><mi id="S1.p1.1.m1.1.1" xref="S1.p1.1.m1.1.1.cmml">S</mi><annotation-xml encoding="MathML-Content" id="S1.p1.1.m1.1b"><ci id="S1.p1.1.m1.1.1.cmml" xref="S1.p1.1.m1.1.1">𝑆</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.p1.1.m1.1c">S</annotation><annotation encoding="application/x-llamapun" id="S1.p1.1.m1.1d">italic_S</annotation></semantics></math> of <math id="S1.p1.2.m2.1" class="ltx_Math" alttext="n" display="inline"><semantics id="S1.p1.2.m2.1a"><mi id="S1.p1.2.m2.1.1" xref="S1.p1.2.m2.1.1.cmml">n</mi><annotation-xml encoding="MathML-Content" id="S1.p1.2.m2.1b"><ci id="S1.p1.2.m2.1.1.cmml" xref="S1.p1.2.m2.1.1">𝑛</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.p1.2.m2.1c">n</annotation><annotation encoding="application/x-llamapun" id="S1.p1.2.m2.1d">italic_n</annotation></semantics></math> <span id="S1.p1.5.1" class="ltx_text ltx_font_italic">data points</span> in a metric space, <math id="S1.p1.3.m3.1" class="ltx_Math" alttext="X" display="inline"><semantics id="S1.p1.3.m3.1a"><mi id="S1.p1.3.m3.1.1" xref="S1.p1.3.m3.1.1.cmml">X</mi><annotation-xml encoding="MathML-Content" id="S1.p1.3.m3.1b"><ci id="S1.p1.3.m3.1.1.cmml" xref="S1.p1.3.m3.1.1">𝑋</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.p1.3.m3.1c">X</annotation><annotation encoding="application/x-llamapun" id="S1.p1.3.m3.1d">italic_X</annotation></semantics></math>, and are asked to
preprocess these points so that, given any <span id="S1.p1.5.2" class="ltx_text ltx_font_italic">query point</span> <math id="S1.p1.4.m4.1" class="ltx_Math" alttext="q\in X" display="inline"><semantics id="S1.p1.4.m4.1a"><mrow id="S1.p1.4.m4.1.1" xref="S1.p1.4.m4.1.1.cmml"><mi id="S1.p1.4.m4.1.1.2" xref="S1.p1.4.m4.1.1.2.cmml">q</mi><mo id="S1.p1.4.m4.1.1.1" xref="S1.p1.4.m4.1.1.1.cmml">∈</mo><mi id="S1.p1.4.m4.1.1.3" xref="S1.p1.4.m4.1.1.3.cmml">X</mi></mrow><annotation-xml encoding="MathML-Content" id="S1.p1.4.m4.1b"><apply id="S1.p1.4.m4.1.1.cmml" xref="S1.p1.4.m4.1.1"><in id="S1.p1.4.m4.1.1.1.cmml" xref="S1.p1.4.m4.1.1.1"></in><ci id="S1.p1.4.m4.1.1.2.cmml" xref="S1.p1.4.m4.1.1.2">𝑞</ci><ci id="S1.p1.4.m4.1.1.3.cmml" xref="S1.p1.4.m4.1.1.3">𝑋</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.p1.4.m4.1c">q\in X</annotation><annotation encoding="application/x-llamapun" id="S1.p1.4.m4.1d">italic_q ∈ italic_X</annotation></semantics></math>,
the data point nearest to <math id="S1.p1.5.m5.1" class="ltx_Math" alttext="q" display="inline"><semantics id="S1.p1.5.m5.1a"><mi id="S1.p1.5.m5.1.1" xref="S1.p1.5.m5.1.1.cmml">q</mi><annotation-xml encoding="MathML-Content" id="S1.p1.5.m5.1b"><ci id="S1.p1.5.m5.1.1.cmml" xref="S1.p1.5.m5.1.1">𝑞</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.p1.5.m5.1c">q</annotation><annotation encoding="application/x-llamapun" id="S1.p1.5.m5.1d">italic_q</annotation></semantics></math> can be reported quickly. Nearest neighbor
searching has applications in many areas, including knowledge discovery
and data mining <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib18" title="" class="ltx_ref">18</a>]</cite>, pattern recognition and
classification <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib14" title="" class="ltx_ref">14</a>, <a href="#bib.bib17" title="" class="ltx_ref">17</a>]</cite>, machine learning
<cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib13" title="" class="ltx_ref">13</a>]</cite>, data compression <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib22" title="" class="ltx_ref">22</a>]</cite>, multimedia
databases <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib19" title="" class="ltx_ref">19</a>]</cite>, document retrieval
<cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib15" title="" class="ltx_ref">15</a>]</cite>, and statistics <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib16" title="" class="ltx_ref">16</a>]</cite>.</p>
</div>
<div id="S1.p2" class="ltx_para">
<p id="S1.p2.13" class="ltx_p">There are many possible choices of the metric space. Throughout we will
assume that the space is <math id="S1.p2.1.m1.1" class="ltx_Math" alttext="R^{d}" display="inline"><semantics id="S1.p2.1.m1.1a"><msup id="S1.p2.1.m1.1.1" xref="S1.p2.1.m1.1.1.cmml"><mi id="S1.p2.1.m1.1.1.2" xref="S1.p2.1.m1.1.1.2.cmml">R</mi><mi id="S1.p2.1.m1.1.1.3" xref="S1.p2.1.m1.1.1.3.cmml">d</mi></msup><annotation-xml encoding="MathML-Content" id="S1.p2.1.m1.1b"><apply id="S1.p2.1.m1.1.1.cmml" xref="S1.p2.1.m1.1.1"><csymbol cd="ambiguous" id="S1.p2.1.m1.1.1.1.cmml" xref="S1.p2.1.m1.1.1">superscript</csymbol><ci id="S1.p2.1.m1.1.1.2.cmml" xref="S1.p2.1.m1.1.1.2">𝑅</ci><ci id="S1.p2.1.m1.1.1.3.cmml" xref="S1.p2.1.m1.1.1.3">𝑑</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.p2.1.m1.1c">R^{d}</annotation><annotation encoding="application/x-llamapun" id="S1.p2.1.m1.1d">italic_R start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT</annotation></semantics></math>, real <math id="S1.p2.2.m2.1" class="ltx_Math" alttext="d" display="inline"><semantics id="S1.p2.2.m2.1a"><mi id="S1.p2.2.m2.1.1" xref="S1.p2.2.m2.1.1.cmml">d</mi><annotation-xml encoding="MathML-Content" id="S1.p2.2.m2.1b"><ci id="S1.p2.2.m2.1.1.cmml" xref="S1.p2.2.m2.1.1">𝑑</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.p2.2.m2.1c">d</annotation><annotation encoding="application/x-llamapun" id="S1.p2.2.m2.1d">italic_d</annotation></semantics></math>-dimensional space, where
distances are measured using any Minkowski <math id="S1.p2.3.m3.1" class="ltx_Math" alttext="L_{m}" display="inline"><semantics id="S1.p2.3.m3.1a"><msub id="S1.p2.3.m3.1.1" xref="S1.p2.3.m3.1.1.cmml"><mi id="S1.p2.3.m3.1.1.2" xref="S1.p2.3.m3.1.1.2.cmml">L</mi><mi id="S1.p2.3.m3.1.1.3" xref="S1.p2.3.m3.1.1.3.cmml">m</mi></msub><annotation-xml encoding="MathML-Content" id="S1.p2.3.m3.1b"><apply id="S1.p2.3.m3.1.1.cmml" xref="S1.p2.3.m3.1.1"><csymbol cd="ambiguous" id="S1.p2.3.m3.1.1.1.cmml" xref="S1.p2.3.m3.1.1">subscript</csymbol><ci id="S1.p2.3.m3.1.1.2.cmml" xref="S1.p2.3.m3.1.1.2">𝐿</ci><ci id="S1.p2.3.m3.1.1.3.cmml" xref="S1.p2.3.m3.1.1.3">𝑚</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.p2.3.m3.1c">L_{m}</annotation><annotation encoding="application/x-llamapun" id="S1.p2.3.m3.1d">italic_L start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT</annotation></semantics></math> distance metric. For
any integer <math id="S1.p2.4.m4.1" class="ltx_Math" alttext="m\geq 1" display="inline"><semantics id="S1.p2.4.m4.1a"><mrow id="S1.p2.4.m4.1.1" xref="S1.p2.4.m4.1.1.cmml"><mi id="S1.p2.4.m4.1.1.2" xref="S1.p2.4.m4.1.1.2.cmml">m</mi><mo id="S1.p2.4.m4.1.1.1" xref="S1.p2.4.m4.1.1.1.cmml">≥</mo><mn id="S1.p2.4.m4.1.1.3" xref="S1.p2.4.m4.1.1.3.cmml">1</mn></mrow><annotation-xml encoding="MathML-Content" id="S1.p2.4.m4.1b"><apply id="S1.p2.4.m4.1.1.cmml" xref="S1.p2.4.m4.1.1"><geq id="S1.p2.4.m4.1.1.1.cmml" xref="S1.p2.4.m4.1.1.1"></geq><ci id="S1.p2.4.m4.1.1.2.cmml" xref="S1.p2.4.m4.1.1.2">𝑚</ci><cn type="integer" id="S1.p2.4.m4.1.1.3.cmml" xref="S1.p2.4.m4.1.1.3">1</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.p2.4.m4.1c">m\geq 1</annotation><annotation encoding="application/x-llamapun" id="S1.p2.4.m4.1d">italic_m ≥ 1</annotation></semantics></math>, the <math id="S1.p2.5.m5.1" class="ltx_Math" alttext="L_{m}" display="inline"><semantics id="S1.p2.5.m5.1a"><msub id="S1.p2.5.m5.1.1" xref="S1.p2.5.m5.1.1.cmml"><mi id="S1.p2.5.m5.1.1.2" xref="S1.p2.5.m5.1.1.2.cmml">L</mi><mi id="S1.p2.5.m5.1.1.3" xref="S1.p2.5.m5.1.1.3.cmml">m</mi></msub><annotation-xml encoding="MathML-Content" id="S1.p2.5.m5.1b"><apply id="S1.p2.5.m5.1.1.cmml" xref="S1.p2.5.m5.1.1"><csymbol cd="ambiguous" id="S1.p2.5.m5.1.1.1.cmml" xref="S1.p2.5.m5.1.1">subscript</csymbol><ci id="S1.p2.5.m5.1.1.2.cmml" xref="S1.p2.5.m5.1.1.2">𝐿</ci><ci id="S1.p2.5.m5.1.1.3.cmml" xref="S1.p2.5.m5.1.1.3">𝑚</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.p2.5.m5.1c">L_{m}</annotation><annotation encoding="application/x-llamapun" id="S1.p2.5.m5.1d">italic_L start_POSTSUBSCRIPT italic_m end_POSTSUBSCRIPT</annotation></semantics></math><span id="S1.p2.13.1" class="ltx_text ltx_font_italic">-distance</span> between points <math id="S1.p2.6.m6.4" class="ltx_Math" alttext="p=(p_{1},p_{2},\ldots,p_{d})" display="inline"><semantics id="S1.p2.6.m6.4a"><mrow id="S1.p2.6.m6.4.4" xref="S1.p2.6.m6.4.4.cmml"><mi id="S1.p2.6.m6.4.4.5" xref="S1.p2.6.m6.4.4.5.cmml">p</mi><mo id="S1.p2.6.m6.4.4.4" xref="S1.p2.6.m6.4.4.4.cmml">=</mo><mrow id="S1.p2.6.m6.4.4.3.3" xref="S1.p2.6.m6.4.4.3.4.cmml"><mo stretchy="false" id="S1.p2.6.m6.4.4.3.3.4" xref="S1.p2.6.m6.4.4.3.4.cmml">(</mo><msub id="S1.p2.6.m6.2.2.1.1.1" xref="S1.p2.6.m6.2.2.1.1.1.cmml"><mi id="S1.p2.6.m6.2.2.1.1.1.2" xref="S1.p2.6.m6.2.2.1.1.1.2.cmml">p</mi><mn id="S1.p2.6.m6.2.2.1.1.1.3" xref="S1.p2.6.m6.2.2.1.1.1.3.cmml">1</mn></msub><mo id="S1.p2.6.m6.4.4.3.3.5" xref="S1.p2.6.m6.4.4.3.4.cmml">,</mo><msub id="S1.p2.6.m6.3.3.2.2.2" xref="S1.p2.6.m6.3.3.2.2.2.cmml"><mi id="S1.p2.6.m6.3.3.2.2.2.2" xref="S1.p2.6.m6.3.3.2.2.2.2.cmml">p</mi><mn id="S1.p2.6.m6.3.3.2.2.2.3" xref="S1.p2.6.m6.3.3.2.2.2.3.cmml">2</mn></msub><mo id="S1.p2.6.m6.4.4.3.3.6" xref="S1.p2.6.m6.4.4.3.4.cmml">,</mo><mi mathvariant="normal" id="S1.p2.6.m6.1.1" xref="S1.p2.6.m6.1.1.cmml">…</mi><mo id="S1.p2.6.m6.4.4.3.3.7" xref="S1.p2.6.m6.4.4.3.4.cmml">,</mo><msub id="S1.p2.6.m6.4.4.3.3.3" xref="S1.p2.6.m6.4.4.3.3.3.cmml"><mi id="S1.p2.6.m6.4.4.3.3.3.2" xref="S1.p2.6.m6.4.4.3.3.3.2.cmml">p</mi><mi id="S1.p2.6.m6.4.4.3.3.3.3" xref="S1.p2.6.m6.4.4.3.3.3.3.cmml">d</mi></msub><mo stretchy="false" id="S1.p2.6.m6.4.4.3.3.8" xref="S1.p2.6.m6.4.4.3.4.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S1.p2.6.m6.4b"><apply id="S1.p2.6.m6.4.4.cmml" xref="S1.p2.6.m6.4.4"><eq id="S1.p2.6.m6.4.4.4.cmml" xref="S1.p2.6.m6.4.4.4"></eq><ci id="S1.p2.6.m6.4.4.5.cmml" xref="S1.p2.6.m6.4.4.5">𝑝</ci><vector id="S1.p2.6.m6.4.4.3.4.cmml" xref="S1.p2.6.m6.4.4.3.3"><apply id="S1.p2.6.m6.2.2.1.1.1.cmml" xref="S1.p2.6.m6.2.2.1.1.1"><csymbol cd="ambiguous" id="S1.p2.6.m6.2.2.1.1.1.1.cmml" xref="S1.p2.6.m6.2.2.1.1.1">subscript</csymbol><ci id="S1.p2.6.m6.2.2.1.1.1.2.cmml" xref="S1.p2.6.m6.2.2.1.1.1.2">𝑝</ci><cn type="integer" id="S1.p2.6.m6.2.2.1.1.1.3.cmml" xref="S1.p2.6.m6.2.2.1.1.1.3">1</cn></apply><apply id="S1.p2.6.m6.3.3.2.2.2.cmml" xref="S1.p2.6.m6.3.3.2.2.2"><csymbol cd="ambiguous" id="S1.p2.6.m6.3.3.2.2.2.1.cmml" xref="S1.p2.6.m6.3.3.2.2.2">subscript</csymbol><ci id="S1.p2.6.m6.3.3.2.2.2.2.cmml" xref="S1.p2.6.m6.3.3.2.2.2.2">𝑝</ci><cn type="integer" id="S1.p2.6.m6.3.3.2.2.2.3.cmml" xref="S1.p2.6.m6.3.3.2.2.2.3">2</cn></apply><ci id="S1.p2.6.m6.1.1.cmml" xref="S1.p2.6.m6.1.1">…</ci><apply id="S1.p2.6.m6.4.4.3.3.3.cmml" xref="S1.p2.6.m6.4.4.3.3.3"><csymbol cd="ambiguous" id="S1.p2.6.m6.4.4.3.3.3.1.cmml" xref="S1.p2.6.m6.4.4.3.3.3">subscript</csymbol><ci id="S1.p2.6.m6.4.4.3.3.3.2.cmml" xref="S1.p2.6.m6.4.4.3.3.3.2">𝑝</ci><ci id="S1.p2.6.m6.4.4.3.3.3.3.cmml" xref="S1.p2.6.m6.4.4.3.3.3.3">𝑑</ci></apply></vector></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.p2.6.m6.4c">p=(p_{1},p_{2},\ldots,p_{d})</annotation><annotation encoding="application/x-llamapun" id="S1.p2.6.m6.4d">italic_p = ( italic_p start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_p start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , … , italic_p start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT )</annotation></semantics></math> and <math id="S1.p2.7.m7.4" class="ltx_Math" alttext="q=(q_{1},q_{2},\ldots,q_{d})" display="inline"><semantics id="S1.p2.7.m7.4a"><mrow id="S1.p2.7.m7.4.4" xref="S1.p2.7.m7.4.4.cmml"><mi id="S1.p2.7.m7.4.4.5" xref="S1.p2.7.m7.4.4.5.cmml">q</mi><mo id="S1.p2.7.m7.4.4.4" xref="S1.p2.7.m7.4.4.4.cmml">=</mo><mrow id="S1.p2.7.m7.4.4.3.3" xref="S1.p2.7.m7.4.4.3.4.cmml"><mo stretchy="false" id="S1.p2.7.m7.4.4.3.3.4" xref="S1.p2.7.m7.4.4.3.4.cmml">(</mo><msub id="S1.p2.7.m7.2.2.1.1.1" xref="S1.p2.7.m7.2.2.1.1.1.cmml"><mi id="S1.p2.7.m7.2.2.1.1.1.2" xref="S1.p2.7.m7.2.2.1.1.1.2.cmml">q</mi><mn id="S1.p2.7.m7.2.2.1.1.1.3" xref="S1.p2.7.m7.2.2.1.1.1.3.cmml">1</mn></msub><mo id="S1.p2.7.m7.4.4.3.3.5" xref="S1.p2.7.m7.4.4.3.4.cmml">,</mo><msub id="S1.p2.7.m7.3.3.2.2.2" xref="S1.p2.7.m7.3.3.2.2.2.cmml"><mi id="S1.p2.7.m7.3.3.2.2.2.2" xref="S1.p2.7.m7.3.3.2.2.2.2.cmml">q</mi><mn id="S1.p2.7.m7.3.3.2.2.2.3" xref="S1.p2.7.m7.3.3.2.2.2.3.cmml">2</mn></msub><mo id="S1.p2.7.m7.4.4.3.3.6" xref="S1.p2.7.m7.4.4.3.4.cmml">,</mo><mi mathvariant="normal" id="S1.p2.7.m7.1.1" xref="S1.p2.7.m7.1.1.cmml">…</mi><mo id="S1.p2.7.m7.4.4.3.3.7" xref="S1.p2.7.m7.4.4.3.4.cmml">,</mo><msub id="S1.p2.7.m7.4.4.3.3.3" xref="S1.p2.7.m7.4.4.3.3.3.cmml"><mi id="S1.p2.7.m7.4.4.3.3.3.2" xref="S1.p2.7.m7.4.4.3.3.3.2.cmml">q</mi><mi id="S1.p2.7.m7.4.4.3.3.3.3" xref="S1.p2.7.m7.4.4.3.3.3.3.cmml">d</mi></msub><mo stretchy="false" id="S1.p2.7.m7.4.4.3.3.8" xref="S1.p2.7.m7.4.4.3.4.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S1.p2.7.m7.4b"><apply id="S1.p2.7.m7.4.4.cmml" xref="S1.p2.7.m7.4.4"><eq id="S1.p2.7.m7.4.4.4.cmml" xref="S1.p2.7.m7.4.4.4"></eq><ci id="S1.p2.7.m7.4.4.5.cmml" xref="S1.p2.7.m7.4.4.5">𝑞</ci><vector id="S1.p2.7.m7.4.4.3.4.cmml" xref="S1.p2.7.m7.4.4.3.3"><apply id="S1.p2.7.m7.2.2.1.1.1.cmml" xref="S1.p2.7.m7.2.2.1.1.1"><csymbol cd="ambiguous" id="S1.p2.7.m7.2.2.1.1.1.1.cmml" xref="S1.p2.7.m7.2.2.1.1.1">subscript</csymbol><ci id="S1.p2.7.m7.2.2.1.1.1.2.cmml" xref="S1.p2.7.m7.2.2.1.1.1.2">𝑞</ci><cn type="integer" id="S1.p2.7.m7.2.2.1.1.1.3.cmml" xref="S1.p2.7.m7.2.2.1.1.1.3">1</cn></apply><apply id="S1.p2.7.m7.3.3.2.2.2.cmml" xref="S1.p2.7.m7.3.3.2.2.2"><csymbol cd="ambiguous" id="S1.p2.7.m7.3.3.2.2.2.1.cmml" xref="S1.p2.7.m7.3.3.2.2.2">subscript</csymbol><ci id="S1.p2.7.m7.3.3.2.2.2.2.cmml" xref="S1.p2.7.m7.3.3.2.2.2.2">𝑞</ci><cn type="integer" id="S1.p2.7.m7.3.3.2.2.2.3.cmml" xref="S1.p2.7.m7.3.3.2.2.2.3">2</cn></apply><ci id="S1.p2.7.m7.1.1.cmml" xref="S1.p2.7.m7.1.1">…</ci><apply id="S1.p2.7.m7.4.4.3.3.3.cmml" xref="S1.p2.7.m7.4.4.3.3.3"><csymbol cd="ambiguous" id="S1.p2.7.m7.4.4.3.3.3.1.cmml" xref="S1.p2.7.m7.4.4.3.3.3">subscript</csymbol><ci id="S1.p2.7.m7.4.4.3.3.3.2.cmml" xref="S1.p2.7.m7.4.4.3.3.3.2">𝑞</ci><ci id="S1.p2.7.m7.4.4.3.3.3.3.cmml" xref="S1.p2.7.m7.4.4.3.3.3.3">𝑑</ci></apply></vector></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.p2.7.m7.4c">q=(q_{1},q_{2},\ldots,q_{d})</annotation><annotation encoding="application/x-llamapun" id="S1.p2.7.m7.4d">italic_q = ( italic_q start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT , italic_q start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT , … , italic_q start_POSTSUBSCRIPT italic_d end_POSTSUBSCRIPT )</annotation></semantics></math> in <math id="S1.p2.8.m8.1" class="ltx_Math" alttext="R^{d}" display="inline"><semantics id="S1.p2.8.m8.1a"><msup id="S1.p2.8.m8.1.1" xref="S1.p2.8.m8.1.1.cmml"><mi id="S1.p2.8.m8.1.1.2" xref="S1.p2.8.m8.1.1.2.cmml">R</mi><mi id="S1.p2.8.m8.1.1.3" xref="S1.p2.8.m8.1.1.3.cmml">d</mi></msup><annotation-xml encoding="MathML-Content" id="S1.p2.8.m8.1b"><apply id="S1.p2.8.m8.1.1.cmml" xref="S1.p2.8.m8.1.1"><csymbol cd="ambiguous" id="S1.p2.8.m8.1.1.1.cmml" xref="S1.p2.8.m8.1.1">superscript</csymbol><ci id="S1.p2.8.m8.1.1.2.cmml" xref="S1.p2.8.m8.1.1.2">𝑅</ci><ci id="S1.p2.8.m8.1.1.3.cmml" xref="S1.p2.8.m8.1.1.3">𝑑</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.p2.8.m8.1c">R^{d}</annotation><annotation encoding="application/x-llamapun" id="S1.p2.8.m8.1d">italic_R start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT</annotation></semantics></math> is defined
to be the <math id="S1.p2.9.m9.1" class="ltx_Math" alttext="m" display="inline"><semantics id="S1.p2.9.m9.1a"><mi id="S1.p2.9.m9.1.1" xref="S1.p2.9.m9.1.1.cmml">m</mi><annotation-xml encoding="MathML-Content" id="S1.p2.9.m9.1b"><ci id="S1.p2.9.m9.1.1.cmml" xref="S1.p2.9.m9.1.1">𝑚</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.p2.9.m9.1c">m</annotation><annotation encoding="application/x-llamapun" id="S1.p2.9.m9.1d">italic_m</annotation></semantics></math>-th root of <math id="S1.p2.10.m10.1" class="ltx_Math" alttext="\sum_{1\leq i\leq d}|p_{i}-q_{i}|^{m}" display="inline"><semantics id="S1.p2.10.m10.1a"><mrow id="S1.p2.10.m10.1.1" xref="S1.p2.10.m10.1.1.cmml"><msub id="S1.p2.10.m10.1.1.2" xref="S1.p2.10.m10.1.1.2.cmml"><mo id="S1.p2.10.m10.1.1.2.2" xref="S1.p2.10.m10.1.1.2.2.cmml">∑</mo><mrow id="S1.p2.10.m10.1.1.2.3" xref="S1.p2.10.m10.1.1.2.3.cmml"><mn id="S1.p2.10.m10.1.1.2.3.2" xref="S1.p2.10.m10.1.1.2.3.2.cmml">1</mn><mo id="S1.p2.10.m10.1.1.2.3.3" xref="S1.p2.10.m10.1.1.2.3.3.cmml">≤</mo><mi id="S1.p2.10.m10.1.1.2.3.4" xref="S1.p2.10.m10.1.1.2.3.4.cmml">i</mi><mo id="S1.p2.10.m10.1.1.2.3.5" xref="S1.p2.10.m10.1.1.2.3.5.cmml">≤</mo><mi id="S1.p2.10.m10.1.1.2.3.6" xref="S1.p2.10.m10.1.1.2.3.6.cmml">d</mi></mrow></msub><msup id="S1.p2.10.m10.1.1.1" xref="S1.p2.10.m10.1.1.1.cmml"><mrow id="S1.p2.10.m10.1.1.1.1.1" xref="S1.p2.10.m10.1.1.1.1.2.cmml"><mo lspace="0em" stretchy="false" id="S1.p2.10.m10.1.1.1.1.1.2" xref="S1.p2.10.m10.1.1.1.1.2.1.cmml">|</mo><mrow id="S1.p2.10.m10.1.1.1.1.1.1" xref="S1.p2.10.m10.1.1.1.1.1.1.cmml"><msub id="S1.p2.10.m10.1.1.1.1.1.1.2" xref="S1.p2.10.m10.1.1.1.1.1.1.2.cmml"><mi id="S1.p2.10.m10.1.1.1.1.1.1.2.2" xref="S1.p2.10.m10.1.1.1.1.1.1.2.2.cmml">p</mi><mi id="S1.p2.10.m10.1.1.1.1.1.1.2.3" xref="S1.p2.10.m10.1.1.1.1.1.1.2.3.cmml">i</mi></msub><mo id="S1.p2.10.m10.1.1.1.1.1.1.1" xref="S1.p2.10.m10.1.1.1.1.1.1.1.cmml">−</mo><msub id="S1.p2.10.m10.1.1.1.1.1.1.3" xref="S1.p2.10.m10.1.1.1.1.1.1.3.cmml"><mi id="S1.p2.10.m10.1.1.1.1.1.1.3.2" xref="S1.p2.10.m10.1.1.1.1.1.1.3.2.cmml">q</mi><mi id="S1.p2.10.m10.1.1.1.1.1.1.3.3" xref="S1.p2.10.m10.1.1.1.1.1.1.3.3.cmml">i</mi></msub></mrow><mo stretchy="false" id="S1.p2.10.m10.1.1.1.1.1.3" xref="S1.p2.10.m10.1.1.1.1.2.1.cmml">|</mo></mrow><mi id="S1.p2.10.m10.1.1.1.3" xref="S1.p2.10.m10.1.1.1.3.cmml">m</mi></msup></mrow><annotation-xml encoding="MathML-Content" id="S1.p2.10.m10.1b"><apply id="S1.p2.10.m10.1.1.cmml" xref="S1.p2.10.m10.1.1"><apply id="S1.p2.10.m10.1.1.2.cmml" xref="S1.p2.10.m10.1.1.2"><csymbol cd="ambiguous" id="S1.p2.10.m10.1.1.2.1.cmml" xref="S1.p2.10.m10.1.1.2">subscript</csymbol><sum id="S1.p2.10.m10.1.1.2.2.cmml" xref="S1.p2.10.m10.1.1.2.2"></sum><apply id="S1.p2.10.m10.1.1.2.3.cmml" xref="S1.p2.10.m10.1.1.2.3"><and id="S1.p2.10.m10.1.1.2.3a.cmml" xref="S1.p2.10.m10.1.1.2.3"></and><apply id="S1.p2.10.m10.1.1.2.3b.cmml" xref="S1.p2.10.m10.1.1.2.3"><leq id="S1.p2.10.m10.1.1.2.3.3.cmml" xref="S1.p2.10.m10.1.1.2.3.3"></leq><cn type="integer" id="S1.p2.10.m10.1.1.2.3.2.cmml" xref="S1.p2.10.m10.1.1.2.3.2">1</cn><ci id="S1.p2.10.m10.1.1.2.3.4.cmml" xref="S1.p2.10.m10.1.1.2.3.4">𝑖</ci></apply><apply id="S1.p2.10.m10.1.1.2.3c.cmml" xref="S1.p2.10.m10.1.1.2.3"><leq id="S1.p2.10.m10.1.1.2.3.5.cmml" xref="S1.p2.10.m10.1.1.2.3.5"></leq><share href="#S1.p2.10.m10.1.1.2.3.4.cmml" id="S1.p2.10.m10.1.1.2.3d.cmml" xref="S1.p2.10.m10.1.1.2.3"></share><ci id="S1.p2.10.m10.1.1.2.3.6.cmml" xref="S1.p2.10.m10.1.1.2.3.6">𝑑</ci></apply></apply></apply><apply id="S1.p2.10.m10.1.1.1.cmml" xref="S1.p2.10.m10.1.1.1"><csymbol cd="ambiguous" id="S1.p2.10.m10.1.1.1.2.cmml" xref="S1.p2.10.m10.1.1.1">superscript</csymbol><apply id="S1.p2.10.m10.1.1.1.1.2.cmml" xref="S1.p2.10.m10.1.1.1.1.1"><abs id="S1.p2.10.m10.1.1.1.1.2.1.cmml" xref="S1.p2.10.m10.1.1.1.1.1.2"></abs><apply id="S1.p2.10.m10.1.1.1.1.1.1.cmml" xref="S1.p2.10.m10.1.1.1.1.1.1"><minus id="S1.p2.10.m10.1.1.1.1.1.1.1.cmml" xref="S1.p2.10.m10.1.1.1.1.1.1.1"></minus><apply id="S1.p2.10.m10.1.1.1.1.1.1.2.cmml" xref="S1.p2.10.m10.1.1.1.1.1.1.2"><csymbol cd="ambiguous" id="S1.p2.10.m10.1.1.1.1.1.1.2.1.cmml" xref="S1.p2.10.m10.1.1.1.1.1.1.2">subscript</csymbol><ci id="S1.p2.10.m10.1.1.1.1.1.1.2.2.cmml" xref="S1.p2.10.m10.1.1.1.1.1.1.2.2">𝑝</ci><ci id="S1.p2.10.m10.1.1.1.1.1.1.2.3.cmml" xref="S1.p2.10.m10.1.1.1.1.1.1.2.3">𝑖</ci></apply><apply id="S1.p2.10.m10.1.1.1.1.1.1.3.cmml" xref="S1.p2.10.m10.1.1.1.1.1.1.3"><csymbol cd="ambiguous" id="S1.p2.10.m10.1.1.1.1.1.1.3.1.cmml" xref="S1.p2.10.m10.1.1.1.1.1.1.3">subscript</csymbol><ci id="S1.p2.10.m10.1.1.1.1.1.1.3.2.cmml" xref="S1.p2.10.m10.1.1.1.1.1.1.3.2">𝑞</ci><ci id="S1.p2.10.m10.1.1.1.1.1.1.3.3.cmml" xref="S1.p2.10.m10.1.1.1.1.1.1.3.3">𝑖</ci></apply></apply></apply><ci id="S1.p2.10.m10.1.1.1.3.cmml" xref="S1.p2.10.m10.1.1.1.3">𝑚</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.p2.10.m10.1c">\sum_{1\leq i\leq d}|p_{i}-q_{i}|^{m}</annotation><annotation encoding="application/x-llamapun" id="S1.p2.10.m10.1d">∑ start_POSTSUBSCRIPT 1 ≤ italic_i ≤ italic_d end_POSTSUBSCRIPT | italic_p start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT - italic_q start_POSTSUBSCRIPT italic_i end_POSTSUBSCRIPT | start_POSTSUPERSCRIPT italic_m end_POSTSUPERSCRIPT</annotation></semantics></math>. The <math id="S1.p2.11.m11.1" class="ltx_Math" alttext="L_{1}" display="inline"><semantics id="S1.p2.11.m11.1a"><msub id="S1.p2.11.m11.1.1" xref="S1.p2.11.m11.1.1.cmml"><mi id="S1.p2.11.m11.1.1.2" xref="S1.p2.11.m11.1.1.2.cmml">L</mi><mn id="S1.p2.11.m11.1.1.3" xref="S1.p2.11.m11.1.1.3.cmml">1</mn></msub><annotation-xml encoding="MathML-Content" id="S1.p2.11.m11.1b"><apply id="S1.p2.11.m11.1.1.cmml" xref="S1.p2.11.m11.1.1"><csymbol cd="ambiguous" id="S1.p2.11.m11.1.1.1.cmml" xref="S1.p2.11.m11.1.1">subscript</csymbol><ci id="S1.p2.11.m11.1.1.2.cmml" xref="S1.p2.11.m11.1.1.2">𝐿</ci><cn type="integer" id="S1.p2.11.m11.1.1.3.cmml" xref="S1.p2.11.m11.1.1.3">1</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.p2.11.m11.1c">L_{1}</annotation><annotation encoding="application/x-llamapun" id="S1.p2.11.m11.1d">italic_L start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT</annotation></semantics></math>,
<math id="S1.p2.12.m12.1" class="ltx_Math" alttext="L_{2}" display="inline"><semantics id="S1.p2.12.m12.1a"><msub id="S1.p2.12.m12.1.1" xref="S1.p2.12.m12.1.1.cmml"><mi id="S1.p2.12.m12.1.1.2" xref="S1.p2.12.m12.1.1.2.cmml">L</mi><mn id="S1.p2.12.m12.1.1.3" xref="S1.p2.12.m12.1.1.3.cmml">2</mn></msub><annotation-xml encoding="MathML-Content" id="S1.p2.12.m12.1b"><apply id="S1.p2.12.m12.1.1.cmml" xref="S1.p2.12.m12.1.1"><csymbol cd="ambiguous" id="S1.p2.12.m12.1.1.1.cmml" xref="S1.p2.12.m12.1.1">subscript</csymbol><ci id="S1.p2.12.m12.1.1.2.cmml" xref="S1.p2.12.m12.1.1.2">𝐿</ci><cn type="integer" id="S1.p2.12.m12.1.1.3.cmml" xref="S1.p2.12.m12.1.1.3">2</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.p2.12.m12.1c">L_{2}</annotation><annotation encoding="application/x-llamapun" id="S1.p2.12.m12.1d">italic_L start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT</annotation></semantics></math>, and <math id="S1.p2.13.m13.1" class="ltx_Math" alttext="L_{\infty}" display="inline"><semantics id="S1.p2.13.m13.1a"><msub id="S1.p2.13.m13.1.1" xref="S1.p2.13.m13.1.1.cmml"><mi id="S1.p2.13.m13.1.1.2" xref="S1.p2.13.m13.1.1.2.cmml">L</mi><mi mathvariant="normal" id="S1.p2.13.m13.1.1.3" xref="S1.p2.13.m13.1.1.3.cmml">∞</mi></msub><annotation-xml encoding="MathML-Content" id="S1.p2.13.m13.1b"><apply id="S1.p2.13.m13.1.1.cmml" xref="S1.p2.13.m13.1.1"><csymbol cd="ambiguous" id="S1.p2.13.m13.1.1.1.cmml" xref="S1.p2.13.m13.1.1">subscript</csymbol><ci id="S1.p2.13.m13.1.1.2.cmml" xref="S1.p2.13.m13.1.1.2">𝐿</ci><infinity id="S1.p2.13.m13.1.1.3.cmml" xref="S1.p2.13.m13.1.1.3"></infinity></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.p2.13.m13.1c">L_{\infty}</annotation><annotation encoding="application/x-llamapun" id="S1.p2.13.m13.1d">italic_L start_POSTSUBSCRIPT ∞ end_POSTSUBSCRIPT</annotation></semantics></math> metrics are the well-known Manhattan, Euclidean
and max metrics, respectively.</p>
</div>
<div id="S1.p3" class="ltx_para">
<p id="S1.p3.4" class="ltx_p">Our primary focus is on data structures that are stored in main memory.
Since data sets can be large, we limit ourselves to consideration of
data structures whose total space grows linearly with <math id="S1.p3.1.m1.1" class="ltx_Math" alttext="d" display="inline"><semantics id="S1.p3.1.m1.1a"><mi id="S1.p3.1.m1.1.1" xref="S1.p3.1.m1.1.1.cmml">d</mi><annotation-xml encoding="MathML-Content" id="S1.p3.1.m1.1b"><ci id="S1.p3.1.m1.1.1.cmml" xref="S1.p3.1.m1.1.1">𝑑</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.p3.1.m1.1c">d</annotation><annotation encoding="application/x-llamapun" id="S1.p3.1.m1.1d">italic_d</annotation></semantics></math> and <math id="S1.p3.2.m2.1" class="ltx_Math" alttext="n" display="inline"><semantics id="S1.p3.2.m2.1a"><mi id="S1.p3.2.m2.1.1" xref="S1.p3.2.m2.1.1.cmml">n</mi><annotation-xml encoding="MathML-Content" id="S1.p3.2.m2.1b"><ci id="S1.p3.2.m2.1.1.cmml" xref="S1.p3.2.m2.1.1">𝑛</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.p3.2.m2.1c">n</annotation><annotation encoding="application/x-llamapun" id="S1.p3.2.m2.1d">italic_n</annotation></semantics></math>.
Among the most popular methods are those based on hierarchical
decompositions of space. The seminal work in this area was by Friedman,
Bentley, and Finkel <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib21" title="" class="ltx_ref">21</a>]</cite> who showed that <math id="S1.p3.3.m3.1" class="ltx_Math" alttext="O(n)" display="inline"><semantics id="S1.p3.3.m3.1a"><mrow id="S1.p3.3.m3.1.2" xref="S1.p3.3.m3.1.2.cmml"><mi id="S1.p3.3.m3.1.2.2" xref="S1.p3.3.m3.1.2.2.cmml">O</mi><mo id="S1.p3.3.m3.1.2.1" xref="S1.p3.3.m3.1.2.1.cmml">⁢</mo><mrow id="S1.p3.3.m3.1.2.3.2" xref="S1.p3.3.m3.1.2.cmml"><mo stretchy="false" id="S1.p3.3.m3.1.2.3.2.1" xref="S1.p3.3.m3.1.2.cmml">(</mo><mi id="S1.p3.3.m3.1.1" xref="S1.p3.3.m3.1.1.cmml">n</mi><mo stretchy="false" id="S1.p3.3.m3.1.2.3.2.2" xref="S1.p3.3.m3.1.2.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S1.p3.3.m3.1b"><apply id="S1.p3.3.m3.1.2.cmml" xref="S1.p3.3.m3.1.2"><times id="S1.p3.3.m3.1.2.1.cmml" xref="S1.p3.3.m3.1.2.1"></times><ci id="S1.p3.3.m3.1.2.2.cmml" xref="S1.p3.3.m3.1.2.2">𝑂</ci><ci id="S1.p3.3.m3.1.1.cmml" xref="S1.p3.3.m3.1.1">𝑛</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.p3.3.m3.1c">O(n)</annotation><annotation encoding="application/x-llamapun" id="S1.p3.3.m3.1d">italic_O ( italic_n )</annotation></semantics></math> space and
<math id="S1.p3.4.m4.1" class="ltx_Math" alttext="O(\log n)" display="inline"><semantics id="S1.p3.4.m4.1a"><mrow id="S1.p3.4.m4.1.1" xref="S1.p3.4.m4.1.1.cmml"><mi id="S1.p3.4.m4.1.1.3" xref="S1.p3.4.m4.1.1.3.cmml">O</mi><mo id="S1.p3.4.m4.1.1.2" xref="S1.p3.4.m4.1.1.2.cmml">⁢</mo><mrow id="S1.p3.4.m4.1.1.1.1" xref="S1.p3.4.m4.1.1.1.1.1.cmml"><mo stretchy="false" id="S1.p3.4.m4.1.1.1.1.2" xref="S1.p3.4.m4.1.1.1.1.1.cmml">(</mo><mrow id="S1.p3.4.m4.1.1.1.1.1" xref="S1.p3.4.m4.1.1.1.1.1.cmml"><mi id="S1.p3.4.m4.1.1.1.1.1.1" xref="S1.p3.4.m4.1.1.1.1.1.1.cmml">log</mi><mo lspace="0.167em" id="S1.p3.4.m4.1.1.1.1.1a" xref="S1.p3.4.m4.1.1.1.1.1.cmml">⁡</mo><mi id="S1.p3.4.m4.1.1.1.1.1.2" xref="S1.p3.4.m4.1.1.1.1.1.2.cmml">n</mi></mrow><mo stretchy="false" id="S1.p3.4.m4.1.1.1.1.3" xref="S1.p3.4.m4.1.1.1.1.1.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S1.p3.4.m4.1b"><apply id="S1.p3.4.m4.1.1.cmml" xref="S1.p3.4.m4.1.1"><times id="S1.p3.4.m4.1.1.2.cmml" xref="S1.p3.4.m4.1.1.2"></times><ci id="S1.p3.4.m4.1.1.3.cmml" xref="S1.p3.4.m4.1.1.3">𝑂</ci><apply id="S1.p3.4.m4.1.1.1.1.1.cmml" xref="S1.p3.4.m4.1.1.1.1"><log id="S1.p3.4.m4.1.1.1.1.1.1.cmml" xref="S1.p3.4.m4.1.1.1.1.1.1"></log><ci id="S1.p3.4.m4.1.1.1.1.1.2.cmml" xref="S1.p3.4.m4.1.1.1.1.1.2">𝑛</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.p3.4.m4.1c">O(\log n)</annotation><annotation encoding="application/x-llamapun" id="S1.p3.4.m4.1d">italic_O ( roman_log italic_n )</annotation></semantics></math> query time are achievable for fixed dimensional spaces in
the expected case for data distributions of bounded density through the
use of kd-trees. There have been numerous variations on this theme.
However, all known methods suffer from the fact that as dimension
increases, either running time or space increase exponentially with
dimension.</p>
</div>
<div id="S1.p4" class="ltx_para">
<p id="S1.p4.7" class="ltx_p">The difficulty of obtaining algorithms that are efficient in the worst
case with respect to both space and query time suggests the alternative
problem of finding <span id="S1.p4.7.1" class="ltx_text ltx_font_italic">approximate</span> nearest neighbors. Consider a set
<math id="S1.p4.1.m1.1" class="ltx_Math" alttext="S" display="inline"><semantics id="S1.p4.1.m1.1a"><mi id="S1.p4.1.m1.1.1" xref="S1.p4.1.m1.1.1.cmml">S</mi><annotation-xml encoding="MathML-Content" id="S1.p4.1.m1.1b"><ci id="S1.p4.1.m1.1.1.cmml" xref="S1.p4.1.m1.1.1">𝑆</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.p4.1.m1.1c">S</annotation><annotation encoding="application/x-llamapun" id="S1.p4.1.m1.1d">italic_S</annotation></semantics></math> of data points in <math id="S1.p4.2.m2.1" class="ltx_Math" alttext="R^{d}" display="inline"><semantics id="S1.p4.2.m2.1a"><msup id="S1.p4.2.m2.1.1" xref="S1.p4.2.m2.1.1.cmml"><mi id="S1.p4.2.m2.1.1.2" xref="S1.p4.2.m2.1.1.2.cmml">R</mi><mi id="S1.p4.2.m2.1.1.3" xref="S1.p4.2.m2.1.1.3.cmml">d</mi></msup><annotation-xml encoding="MathML-Content" id="S1.p4.2.m2.1b"><apply id="S1.p4.2.m2.1.1.cmml" xref="S1.p4.2.m2.1.1"><csymbol cd="ambiguous" id="S1.p4.2.m2.1.1.1.cmml" xref="S1.p4.2.m2.1.1">superscript</csymbol><ci id="S1.p4.2.m2.1.1.2.cmml" xref="S1.p4.2.m2.1.1.2">𝑅</ci><ci id="S1.p4.2.m2.1.1.3.cmml" xref="S1.p4.2.m2.1.1.3">𝑑</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.p4.2.m2.1c">R^{d}</annotation><annotation encoding="application/x-llamapun" id="S1.p4.2.m2.1d">italic_R start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT</annotation></semantics></math> and a query point <math id="S1.p4.3.m3.1" class="ltx_Math" alttext="q\in R^{d}" display="inline"><semantics id="S1.p4.3.m3.1a"><mrow id="S1.p4.3.m3.1.1" xref="S1.p4.3.m3.1.1.cmml"><mi id="S1.p4.3.m3.1.1.2" xref="S1.p4.3.m3.1.1.2.cmml">q</mi><mo id="S1.p4.3.m3.1.1.1" xref="S1.p4.3.m3.1.1.1.cmml">∈</mo><msup id="S1.p4.3.m3.1.1.3" xref="S1.p4.3.m3.1.1.3.cmml"><mi id="S1.p4.3.m3.1.1.3.2" xref="S1.p4.3.m3.1.1.3.2.cmml">R</mi><mi id="S1.p4.3.m3.1.1.3.3" xref="S1.p4.3.m3.1.1.3.3.cmml">d</mi></msup></mrow><annotation-xml encoding="MathML-Content" id="S1.p4.3.m3.1b"><apply id="S1.p4.3.m3.1.1.cmml" xref="S1.p4.3.m3.1.1"><in id="S1.p4.3.m3.1.1.1.cmml" xref="S1.p4.3.m3.1.1.1"></in><ci id="S1.p4.3.m3.1.1.2.cmml" xref="S1.p4.3.m3.1.1.2">𝑞</ci><apply id="S1.p4.3.m3.1.1.3.cmml" xref="S1.p4.3.m3.1.1.3"><csymbol cd="ambiguous" id="S1.p4.3.m3.1.1.3.1.cmml" xref="S1.p4.3.m3.1.1.3">superscript</csymbol><ci id="S1.p4.3.m3.1.1.3.2.cmml" xref="S1.p4.3.m3.1.1.3.2">𝑅</ci><ci id="S1.p4.3.m3.1.1.3.3.cmml" xref="S1.p4.3.m3.1.1.3.3">𝑑</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.p4.3.m3.1c">q\in R^{d}</annotation><annotation encoding="application/x-llamapun" id="S1.p4.3.m3.1d">italic_q ∈ italic_R start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT</annotation></semantics></math>. Given
<math id="S1.p4.4.m4.1" class="ltx_Math" alttext="\epsilon&gt;0" display="inline"><semantics id="S1.p4.4.m4.1a"><mrow id="S1.p4.4.m4.1.1" xref="S1.p4.4.m4.1.1.cmml"><mi id="S1.p4.4.m4.1.1.2" xref="S1.p4.4.m4.1.1.2.cmml">ϵ</mi><mo id="S1.p4.4.m4.1.1.1" xref="S1.p4.4.m4.1.1.1.cmml">&gt;</mo><mn id="S1.p4.4.m4.1.1.3" xref="S1.p4.4.m4.1.1.3.cmml">0</mn></mrow><annotation-xml encoding="MathML-Content" id="S1.p4.4.m4.1b"><apply id="S1.p4.4.m4.1.1.cmml" xref="S1.p4.4.m4.1.1"><gt id="S1.p4.4.m4.1.1.1.cmml" xref="S1.p4.4.m4.1.1.1"></gt><ci id="S1.p4.4.m4.1.1.2.cmml" xref="S1.p4.4.m4.1.1.2">italic-ϵ</ci><cn type="integer" id="S1.p4.4.m4.1.1.3.cmml" xref="S1.p4.4.m4.1.1.3">0</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.p4.4.m4.1c">\epsilon&gt;0</annotation><annotation encoding="application/x-llamapun" id="S1.p4.4.m4.1d">italic_ϵ &gt; 0</annotation></semantics></math>, we say that a point <math id="S1.p4.5.m5.1" class="ltx_Math" alttext="p\in S" display="inline"><semantics id="S1.p4.5.m5.1a"><mrow id="S1.p4.5.m5.1.1" xref="S1.p4.5.m5.1.1.cmml"><mi id="S1.p4.5.m5.1.1.2" xref="S1.p4.5.m5.1.1.2.cmml">p</mi><mo id="S1.p4.5.m5.1.1.1" xref="S1.p4.5.m5.1.1.1.cmml">∈</mo><mi id="S1.p4.5.m5.1.1.3" xref="S1.p4.5.m5.1.1.3.cmml">S</mi></mrow><annotation-xml encoding="MathML-Content" id="S1.p4.5.m5.1b"><apply id="S1.p4.5.m5.1.1.cmml" xref="S1.p4.5.m5.1.1"><in id="S1.p4.5.m5.1.1.1.cmml" xref="S1.p4.5.m5.1.1.1"></in><ci id="S1.p4.5.m5.1.1.2.cmml" xref="S1.p4.5.m5.1.1.2">𝑝</ci><ci id="S1.p4.5.m5.1.1.3.cmml" xref="S1.p4.5.m5.1.1.3">𝑆</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.p4.5.m5.1c">p\in S</annotation><annotation encoding="application/x-llamapun" id="S1.p4.5.m5.1d">italic_p ∈ italic_S</annotation></semantics></math> is a <math id="S1.p4.6.m6.1" class="ltx_Math" alttext="(1+\epsilon)" display="inline"><semantics id="S1.p4.6.m6.1a"><mrow id="S1.p4.6.m6.1.1.1" xref="S1.p4.6.m6.1.1.1.1.cmml"><mo stretchy="false" id="S1.p4.6.m6.1.1.1.2" xref="S1.p4.6.m6.1.1.1.1.cmml">(</mo><mrow id="S1.p4.6.m6.1.1.1.1" xref="S1.p4.6.m6.1.1.1.1.cmml"><mn id="S1.p4.6.m6.1.1.1.1.2" xref="S1.p4.6.m6.1.1.1.1.2.cmml">1</mn><mo id="S1.p4.6.m6.1.1.1.1.1" xref="S1.p4.6.m6.1.1.1.1.1.cmml">+</mo><mi id="S1.p4.6.m6.1.1.1.1.3" xref="S1.p4.6.m6.1.1.1.1.3.cmml">ϵ</mi></mrow><mo stretchy="false" id="S1.p4.6.m6.1.1.1.3" xref="S1.p4.6.m6.1.1.1.1.cmml">)</mo></mrow><annotation-xml encoding="MathML-Content" id="S1.p4.6.m6.1b"><apply id="S1.p4.6.m6.1.1.1.1.cmml" xref="S1.p4.6.m6.1.1.1"><plus id="S1.p4.6.m6.1.1.1.1.1.cmml" xref="S1.p4.6.m6.1.1.1.1.1"></plus><cn type="integer" id="S1.p4.6.m6.1.1.1.1.2.cmml" xref="S1.p4.6.m6.1.1.1.1.2">1</cn><ci id="S1.p4.6.m6.1.1.1.1.3.cmml" xref="S1.p4.6.m6.1.1.1.1.3">italic-ϵ</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.p4.6.m6.1c">(1+\epsilon)</annotation><annotation encoding="application/x-llamapun" id="S1.p4.6.m6.1d">( 1 + italic_ϵ )</annotation></semantics></math><span id="S1.p4.7.2" class="ltx_text ltx_font_italic">-approximate nearest neighbor</span> of <math id="S1.p4.7.m7.1" class="ltx_Math" alttext="q" display="inline"><semantics id="S1.p4.7.m7.1a"><mi id="S1.p4.7.m7.1.1" xref="S1.p4.7.m7.1.1.cmml">q</mi><annotation-xml encoding="MathML-Content" id="S1.p4.7.m7.1b"><ci id="S1.p4.7.m7.1.1.cmml" xref="S1.p4.7.m7.1.1">𝑞</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.p4.7.m7.1c">q</annotation><annotation encoding="application/x-llamapun" id="S1.p4.7.m7.1d">italic_q</annotation></semantics></math> if</p>
<table id="S1.Ex1" class="ltx_equation ltx_eqn_table">

<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S1.Ex1.m1.4" class="ltx_Math" alttext="\hbox{\it dist}(p,q)\leq(1+\epsilon)\hbox{\it dist}(p^{*},q)," display="block"><semantics id="S1.Ex1.m1.4a"><mrow id="S1.Ex1.m1.4.4.1" xref="S1.Ex1.m1.4.4.1.1.cmml"><mrow id="S1.Ex1.m1.4.4.1.1" xref="S1.Ex1.m1.4.4.1.1.cmml"><mrow id="S1.Ex1.m1.4.4.1.1.4" xref="S1.Ex1.m1.4.4.1.1.4.cmml"><mtext id="S1.Ex1.m1.4.4.1.1.4.2" xref="S1.Ex1.m1.4.4.1.1.4.2a.cmml">𝑑𝑖𝑠𝑡</mtext><mo id="S1.Ex1.m1.4.4.1.1.4.1" xref="S1.Ex1.m1.4.4.1.1.4.1.cmml">⁢</mo><mrow id="S1.Ex1.m1.4.4.1.1.4.3.2" xref="S1.Ex1.m1.4.4.1.1.4.3.1.cmml"><mo stretchy="false" id="S1.Ex1.m1.4.4.1.1.4.3.2.1" xref="S1.Ex1.m1.4.4.1.1.4.3.1.cmml">(</mo><mi id="S1.Ex1.m1.1.1" xref="S1.Ex1.m1.1.1.cmml">p</mi><mo id="S1.Ex1.m1.4.4.1.1.4.3.2.2" xref="S1.Ex1.m1.4.4.1.1.4.3.1.cmml">,</mo><mi id="S1.Ex1.m1.2.2" xref="S1.Ex1.m1.2.2.cmml">q</mi><mo stretchy="false" id="S1.Ex1.m1.4.4.1.1.4.3.2.3" xref="S1.Ex1.m1.4.4.1.1.4.3.1.cmml">)</mo></mrow></mrow><mo id="S1.Ex1.m1.4.4.1.1.3" xref="S1.Ex1.m1.4.4.1.1.3.cmml">≤</mo><mrow id="S1.Ex1.m1.4.4.1.1.2" xref="S1.Ex1.m1.4.4.1.1.2.cmml"><mrow id="S1.Ex1.m1.4.4.1.1.1.1.1" xref="S1.Ex1.m1.4.4.1.1.1.1.1.1.cmml"><mo stretchy="false" id="S1.Ex1.m1.4.4.1.1.1.1.1.2" xref="S1.Ex1.m1.4.4.1.1.1.1.1.1.cmml">(</mo><mrow id="S1.Ex1.m1.4.4.1.1.1.1.1.1" xref="S1.Ex1.m1.4.4.1.1.1.1.1.1.cmml"><mn id="S1.Ex1.m1.4.4.1.1.1.1.1.1.2" xref="S1.Ex1.m1.4.4.1.1.1.1.1.1.2.cmml">1</mn><mo id="S1.Ex1.m1.4.4.1.1.1.1.1.1.1" xref="S1.Ex1.m1.4.4.1.1.1.1.1.1.1.cmml">+</mo><mi id="S1.Ex1.m1.4.4.1.1.1.1.1.1.3" xref="S1.Ex1.m1.4.4.1.1.1.1.1.1.3.cmml">ϵ</mi></mrow><mo stretchy="false" id="S1.Ex1.m1.4.4.1.1.1.1.1.3" xref="S1.Ex1.m1.4.4.1.1.1.1.1.1.cmml">)</mo></mrow><mo id="S1.Ex1.m1.4.4.1.1.2.3" xref="S1.Ex1.m1.4.4.1.1.2.3.cmml">⁢</mo><mtext id="S1.Ex1.m1.4.4.1.1.2.4" xref="S1.Ex1.m1.4.4.1.1.2.4a.cmml">𝑑𝑖𝑠𝑡</mtext><mo id="S1.Ex1.m1.4.4.1.1.2.3a" xref="S1.Ex1.m1.4.4.1.1.2.3.cmml">⁢</mo><mrow id="S1.Ex1.m1.4.4.1.1.2.2.1" xref="S1.Ex1.m1.4.4.1.1.2.2.2.cmml"><mo stretchy="false" id="S1.Ex1.m1.4.4.1.1.2.2.1.2" xref="S1.Ex1.m1.4.4.1.1.2.2.2.cmml">(</mo><msup id="S1.Ex1.m1.4.4.1.1.2.2.1.1" xref="S1.Ex1.m1.4.4.1.1.2.2.1.1.cmml"><mi id="S1.Ex1.m1.4.4.1.1.2.2.1.1.2" xref="S1.Ex1.m1.4.4.1.1.2.2.1.1.2.cmml">p</mi><mo id="S1.Ex1.m1.4.4.1.1.2.2.1.1.3" xref="S1.Ex1.m1.4.4.1.1.2.2.1.1.3.cmml">*</mo></msup><mo id="S1.Ex1.m1.4.4.1.1.2.2.1.3" xref="S1.Ex1.m1.4.4.1.1.2.2.2.cmml">,</mo><mi id="S1.Ex1.m1.3.3" xref="S1.Ex1.m1.3.3.cmml">q</mi><mo stretchy="false" id="S1.Ex1.m1.4.4.1.1.2.2.1.4" xref="S1.Ex1.m1.4.4.1.1.2.2.2.cmml">)</mo></mrow></mrow></mrow><mo id="S1.Ex1.m1.4.4.1.2" xref="S1.Ex1.m1.4.4.1.1.cmml">,</mo></mrow><annotation-xml encoding="MathML-Content" id="S1.Ex1.m1.4b"><apply id="S1.Ex1.m1.4.4.1.1.cmml" xref="S1.Ex1.m1.4.4.1"><leq id="S1.Ex1.m1.4.4.1.1.3.cmml" xref="S1.Ex1.m1.4.4.1.1.3"></leq><apply id="S1.Ex1.m1.4.4.1.1.4.cmml" xref="S1.Ex1.m1.4.4.1.1.4"><times id="S1.Ex1.m1.4.4.1.1.4.1.cmml" xref="S1.Ex1.m1.4.4.1.1.4.1"></times><ci id="S1.Ex1.m1.4.4.1.1.4.2a.cmml" xref="S1.Ex1.m1.4.4.1.1.4.2"><mtext id="S1.Ex1.m1.4.4.1.1.4.2.cmml" xref="S1.Ex1.m1.4.4.1.1.4.2">𝑑𝑖𝑠𝑡</mtext></ci><interval closure="open" id="S1.Ex1.m1.4.4.1.1.4.3.1.cmml" xref="S1.Ex1.m1.4.4.1.1.4.3.2"><ci id="S1.Ex1.m1.1.1.cmml" xref="S1.Ex1.m1.1.1">𝑝</ci><ci id="S1.Ex1.m1.2.2.cmml" xref="S1.Ex1.m1.2.2">𝑞</ci></interval></apply><apply id="S1.Ex1.m1.4.4.1.1.2.cmml" xref="S1.Ex1.m1.4.4.1.1.2"><times id="S1.Ex1.m1.4.4.1.1.2.3.cmml" xref="S1.Ex1.m1.4.4.1.1.2.3"></times><apply id="S1.Ex1.m1.4.4.1.1.1.1.1.1.cmml" xref="S1.Ex1.m1.4.4.1.1.1.1.1"><plus id="S1.Ex1.m1.4.4.1.1.1.1.1.1.1.cmml" xref="S1.Ex1.m1.4.4.1.1.1.1.1.1.1"></plus><cn type="integer" id="S1.Ex1.m1.4.4.1.1.1.1.1.1.2.cmml" xref="S1.Ex1.m1.4.4.1.1.1.1.1.1.2">1</cn><ci id="S1.Ex1.m1.4.4.1.1.1.1.1.1.3.cmml" xref="S1.Ex1.m1.4.4.1.1.1.1.1.1.3">italic-ϵ</ci></apply><ci id="S1.Ex1.m1.4.4.1.1.2.4a.cmml" xref="S1.Ex1.m1.4.4.1.1.2.4"><mtext id="S1.Ex1.m1.4.4.1.1.2.4.cmml" xref="S1.Ex1.m1.4.4.1.1.2.4">𝑑𝑖𝑠𝑡</mtext></ci><interval closure="open" id="S1.Ex1.m1.4.4.1.1.2.2.2.cmml" xref="S1.Ex1.m1.4.4.1.1.2.2.1"><apply id="S1.Ex1.m1.4.4.1.1.2.2.1.1.cmml" xref="S1.Ex1.m1.4.4.1.1.2.2.1.1"><csymbol cd="ambiguous" id="S1.Ex1.m1.4.4.1.1.2.2.1.1.1.cmml" xref="S1.Ex1.m1.4.4.1.1.2.2.1.1">superscript</csymbol><ci id="S1.Ex1.m1.4.4.1.1.2.2.1.1.2.cmml" xref="S1.Ex1.m1.4.4.1.1.2.2.1.1.2">𝑝</ci><times id="S1.Ex1.m1.4.4.1.1.2.2.1.1.3.cmml" xref="S1.Ex1.m1.4.4.1.1.2.2.1.1.3"></times></apply><ci id="S1.Ex1.m1.3.3.cmml" xref="S1.Ex1.m1.3.3">𝑞</ci></interval></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.Ex1.m1.4c">\hbox{\it dist}(p,q)\leq(1+\epsilon)\hbox{\it dist}(p^{*},q),</annotation><annotation encoding="application/x-llamapun" id="S1.Ex1.m1.4d">dist ( italic_p , italic_q ) ≤ ( 1 + italic_ϵ ) dist ( italic_p start_POSTSUPERSCRIPT * end_POSTSUPERSCRIPT , italic_q ) ,</annotation></semantics></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
<p id="S1.p4.11" class="ltx_p">where <math id="S1.p4.8.m1.1" class="ltx_Math" alttext="p^{*}" display="inline"><semantics id="S1.p4.8.m1.1a"><msup id="S1.p4.8.m1.1.1" xref="S1.p4.8.m1.1.1.cmml"><mi id="S1.p4.8.m1.1.1.2" xref="S1.p4.8.m1.1.1.2.cmml">p</mi><mo id="S1.p4.8.m1.1.1.3" xref="S1.p4.8.m1.1.1.3.cmml">*</mo></msup><annotation-xml encoding="MathML-Content" id="S1.p4.8.m1.1b"><apply id="S1.p4.8.m1.1.1.cmml" xref="S1.p4.8.m1.1.1"><csymbol cd="ambiguous" id="S1.p4.8.m1.1.1.1.cmml" xref="S1.p4.8.m1.1.1">superscript</csymbol><ci id="S1.p4.8.m1.1.1.2.cmml" xref="S1.p4.8.m1.1.1.2">𝑝</ci><times id="S1.p4.8.m1.1.1.3.cmml" xref="S1.p4.8.m1.1.1.3"></times></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.p4.8.m1.1c">p^{*}</annotation><annotation encoding="application/x-llamapun" id="S1.p4.8.m1.1d">italic_p start_POSTSUPERSCRIPT * end_POSTSUPERSCRIPT</annotation></semantics></math> is the true nearest neighbor to <math id="S1.p4.9.m2.1" class="ltx_Math" alttext="q" display="inline"><semantics id="S1.p4.9.m2.1a"><mi id="S1.p4.9.m2.1.1" xref="S1.p4.9.m2.1.1.cmml">q</mi><annotation-xml encoding="MathML-Content" id="S1.p4.9.m2.1b"><ci id="S1.p4.9.m2.1.1.cmml" xref="S1.p4.9.m2.1.1">𝑞</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.p4.9.m2.1c">q</annotation><annotation encoding="application/x-llamapun" id="S1.p4.9.m2.1d">italic_q</annotation></semantics></math>. In other words, <math id="S1.p4.10.m3.1" class="ltx_Math" alttext="p" display="inline"><semantics id="S1.p4.10.m3.1a"><mi id="S1.p4.10.m3.1.1" xref="S1.p4.10.m3.1.1.cmml">p</mi><annotation-xml encoding="MathML-Content" id="S1.p4.10.m3.1b"><ci id="S1.p4.10.m3.1.1.cmml" xref="S1.p4.10.m3.1.1">𝑝</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.p4.10.m3.1c">p</annotation><annotation encoding="application/x-llamapun" id="S1.p4.10.m3.1d">italic_p</annotation></semantics></math>
is within relative error <math id="S1.p4.11.m4.1" class="ltx_Math" alttext="\epsilon" display="inline"><semantics id="S1.p4.11.m4.1a"><mi id="S1.p4.11.m4.1.1" xref="S1.p4.11.m4.1.1.cmml">ϵ</mi><annotation-xml encoding="MathML-Content" id="S1.p4.11.m4.1b"><ci id="S1.p4.11.m4.1.1.cmml" xref="S1.p4.11.m4.1.1">italic-ϵ</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.p4.11.m4.1c">\epsilon</annotation><annotation encoding="application/x-llamapun" id="S1.p4.11.m4.1d">italic_ϵ</annotation></semantics></math> of the true nearest neighbor.
The approximate nearest neighbor problem has been heavily studied
recently. Examples include algorithms by Bern <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib8" title="" class="ltx_ref">8</a>]</cite>,
Arya and Mount <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib2" title="" class="ltx_ref">2</a>]</cite>, Arya, et al. <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib3" title="" class="ltx_ref">3</a>]</cite>,
Clarkson <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib11" title="" class="ltx_ref">11</a>]</cite>, Chan <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib10" title="" class="ltx_ref">10</a>]</cite>, Kleinberg
<cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib26" title="" class="ltx_ref">26</a>]</cite>, Indyk and Motwani <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib23" title="" class="ltx_ref">23</a>]</cite>, and
Kushilevitz, Ostrovsky and Rabani <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib27" title="" class="ltx_ref">27</a>]</cite>.</p>
</div>
<div id="S1.p5" class="ltx_para">
<p id="S1.p5.1" class="ltx_p">In this study we restrict attention to data structures of size <math id="S1.p5.1.m1.1" class="ltx_Math" alttext="O(dn)" display="inline"><semantics id="S1.p5.1.m1.1a"><mrow id="S1.p5.1.m1.1.1" xref="S1.p5.1.m1.1.1.cmml"><mi id="S1.p5.1.m1.1.1.3" xref="S1.p5.1.m1.1.1.3.cmml">O</mi><mo id="S1.p5.1.m1.1.1.2" xref="S1.p5.1.m1.1.1.2.cmml">⁢</mo><mrow id="S1.p5.1.m1.1.1.1.1" xref="S1.p5.1.m1.1.1.1.1.1.cmml"><mo stretchy="false" id="S1.p5.1.m1.1.1.1.1.2" xref="S1.p5.1.m1.1.1.1.1.1.cmml">(</mo><mrow id="S1.p5.1.m1.1.1.1.1.1" xref="S1.p5.1.m1.1.1.1.1.1.cmml"><mi id="S1.p5.1.m1.1.1.1.1.1.2" xref="S1.p5.1.m1.1.1.1.1.1.2.cmml">d</mi><mo id="S1.p5.1.m1.1.1.1.1.1.1" xref="S1.p5.1.m1.1.1.1.1.1.1.cmml">⁢</mo><mi id="S1.p5.1.m1.1.1.1.1.1.3" xref="S1.p5.1.m1.1.1.1.1.1.3.cmml">n</mi></mrow><mo stretchy="false" id="S1.p5.1.m1.1.1.1.1.3" xref="S1.p5.1.m1.1.1.1.1.1.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S1.p5.1.m1.1b"><apply id="S1.p5.1.m1.1.1.cmml" xref="S1.p5.1.m1.1.1"><times id="S1.p5.1.m1.1.1.2.cmml" xref="S1.p5.1.m1.1.1.2"></times><ci id="S1.p5.1.m1.1.1.3.cmml" xref="S1.p5.1.m1.1.1.3">𝑂</ci><apply id="S1.p5.1.m1.1.1.1.1.1.cmml" xref="S1.p5.1.m1.1.1.1.1"><times id="S1.p5.1.m1.1.1.1.1.1.1.cmml" xref="S1.p5.1.m1.1.1.1.1.1.1"></times><ci id="S1.p5.1.m1.1.1.1.1.1.2.cmml" xref="S1.p5.1.m1.1.1.1.1.1.2">𝑑</ci><ci id="S1.p5.1.m1.1.1.1.1.1.3.cmml" xref="S1.p5.1.m1.1.1.1.1.1.3">𝑛</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.p5.1.m1.1c">O(dn)</annotation><annotation encoding="application/x-llamapun" id="S1.p5.1.m1.1d">italic_O ( italic_d italic_n )</annotation></semantics></math>
based on hierarchical spatial decompositions, and the kd-tree in
particular. In large part this is because of the simplicity and
widespread popularity of this data structure. A kd-tree is binary tree
based on a hierarchical subdivision of space by splitting hyperplanes
that are orthogonal to the coordinate axes <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib21" title="" class="ltx_ref">21</a>]</cite>. It is
described further in the next section. A key issue in the design of the
kd-tree is the choice of the splitting hyperplane. Friedman, Bentley,
and Finkel proposed a splitting method based on selecting the plane
orthogonal to the median coordinate along which the points have the
greatest spread. They called the resulting tree an optimized kd-tree,
and henceforth we call the resulting splitting method the <span id="S1.p5.1.1" class="ltx_text ltx_font_italic">standard
splitting method</span>. Another common alternative uses the shape of the
cell, rather than the distribution of the data points. It splits
each cell through its midpoint by a hyperplane orthogonal to its longest
side. We call this the <span id="S1.p5.1.2" class="ltx_text ltx_font_italic">midpoint split method</span>.</p>
</div>
<div id="S1.p6" class="ltx_para">
<p id="S1.p6.2" class="ltx_p">A number of other data structures for nearest neighbor searching based
on hierarchical spatial decompositions have been proposed. Yianilos
introduced the <span id="S1.p6.2.1" class="ltx_text ltx_font_italic">vp-tree</span> <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib34" title="" class="ltx_ref">34</a>]</cite>. Rather than using an
axis-aligned plane to split a node as in kd-tree, it uses a data point,
called the vantage point, as the center of a hypersphere that partitions
the space into two regions. There has also been quite a bit of
interest from the field of databases. There are several data structures
for database applications based on <math id="S1.p6.1.m1.1" class="ltx_Math" alttext="R" display="inline"><semantics id="S1.p6.1.m1.1a"><mi id="S1.p6.1.m1.1.1" xref="S1.p6.1.m1.1.1.cmml">R</mi><annotation-xml encoding="MathML-Content" id="S1.p6.1.m1.1b"><ci id="S1.p6.1.m1.1.1.cmml" xref="S1.p6.1.m1.1.1">𝑅</ci></annotation-xml><annotation encoding="application/x-tex" id="S1.p6.1.m1.1c">R</annotation><annotation encoding="application/x-llamapun" id="S1.p6.1.m1.1d">italic_R</annotation></semantics></math>-trees and their variants
<cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib4" title="" class="ltx_ref">4</a>, <a href="#bib.bib31" title="" class="ltx_ref">31</a>]</cite>. For example, the <span id="S1.p6.2.2" class="ltx_text ltx_font_italic">X-tree</span>
<cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib7" title="" class="ltx_ref">7</a>]</cite> improves the performance of the R<math id="S1.p6.2.m2.1" class="ltx_Math" alttext="{}^{*}" display="inline"><semantics id="S1.p6.2.m2.1a"><msup id="S1.p6.2.m2.1.1" xref="S1.p6.2.m2.1.1.cmml"><mi id="S1.p6.2.m2.1.1a" xref="S1.p6.2.m2.1.1.cmml"></mi><mo id="S1.p6.2.m2.1.1.1" xref="S1.p6.2.m2.1.1.1.cmml">*</mo></msup><annotation-xml encoding="MathML-Content" id="S1.p6.2.m2.1b"><apply id="S1.p6.2.m2.1.1.cmml" xref="S1.p6.2.m2.1.1"><times id="S1.p6.2.m2.1.1.1.cmml" xref="S1.p6.2.m2.1.1.1"></times></apply></annotation-xml><annotation encoding="application/x-tex" id="S1.p6.2.m2.1c">{}^{*}</annotation><annotation encoding="application/x-llamapun" id="S1.p6.2.m2.1d">start_FLOATSUPERSCRIPT * end_FLOATSUPERSCRIPT</annotation></semantics></math>-tree by
avoiding high overlap. Another example is the SR-tree
<cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib25" title="" class="ltx_ref">25</a>]</cite>. The <span id="S1.p6.2.3" class="ltx_text ltx_font_italic">TV-tree</span> <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib28" title="" class="ltx_ref">28</a>]</cite> uses a
different approach to deal with high dimensional spaces. It reduces
dimensionality by maintaining a number of active dimensions. When all
data points in a node share the same coordinate of an active dimension,
that dimension will be deactivated and the set of active dimensions
shifts.</p>
</div>
<div id="S1.p7" class="ltx_para">
<p id="S1.p7.1" class="ltx_p">In this paper we study the performance of two other splitting methods,
and compare them against the kd-tree splitting method. The first,
called <span id="S1.p7.1.1" class="ltx_text ltx_font_italic">sliding-midpoint</span>, is a splitting method that was introduced
by Mount and Arya in the ANN library for approximate nearest neighbor
searching <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib30" title="" class="ltx_ref">30</a>]</cite>. This method was introduced into the
library in order to better handle highly clustered data sets. We know
of no analysis (empirical or theoretical) of this method. This method
was designed as a simple technique for addressing one of the most
serious flaws in the standard kd-tree splitting method. The flaw is
that when the data points are highly clustered in low dimensional
subspaces, then the standard kd-tree splitting method may produce highly
elongated cells, and these can lead to slow query times. This splitting
method starts with a simple midpoint split of the longest side of the
cell, but if this split results in either subcell containing no data
points, it translates (or “slides”) the splitting plane in the
direction of the points until hitting the first data point. In
Section <a href="#S3.SS1" title="3.1 Sliding-Midpoint ‣ 3 Splitting Methods ‣ Analysis of Approximate Nearest Neighbor Searching with Clustered Point SetsThe support of the National Science Foundation under grant CCR–9712379 is gratefully acknowledged." class="ltx_ref"><span class="ltx_text ltx_ref_tag">3.1</span></a> we describe this splitting method and analyze
some of its properties.</p>
</div>
<div id="S1.p8" class="ltx_para">
<p id="S1.p8.1" class="ltx_p">The second splitting method, called <span id="S1.p8.1.1" class="ltx_text ltx_font_italic">minimum-ambiguity</span>, is a
query-based technique. The tree is given not only the data points, but
also a collection of sample query points, called the <span id="S1.p8.1.2" class="ltx_text ltx_font_italic">training
points</span>. The algorithm applies a greedy heuristic to build the tree in
an attempt to minimize the expected query time on the training points.
We model query processing as the problem of eliminating data points from
consideration as the possible candidates for the nearest neighbor.
Given a collection of query points, we can model any stage of the
nearest neighbor algorithm as a bipartite graph, called the <span id="S1.p8.1.3" class="ltx_text ltx_font_italic">candidate graph</span>, whose vertices correspond to the union of the data
points and the query points, and in which each query point is adjacent
to the subset of data points that might be its nearest neighbor. The
minimum-ambiguity selects the splitting plane at each stage that
eliminates the maximum number of remaining edges in the candidate graph.
In Section <a href="#S3.SS2" title="3.2 Minimum-Ambiguity ‣ 3 Splitting Methods ‣ Analysis of Approximate Nearest Neighbor Searching with Clustered Point SetsThe support of the National Science Foundation under grant CCR–9712379 is gratefully acknowledged." class="ltx_ref"><span class="ltx_text ltx_ref_tag">3.2</span></a> we describe this splitting method in greater
detail.</p>
</div>
<div id="S1.p9" class="ltx_para">
<p id="S1.p9.1" class="ltx_p">We implemented these two splitting methods, along with the standard
kd-tree splitting method. We compared them on a number of synthetically
generated point distributions, which were designed to model
low-dimensional clustering. We believe this type of clustering is not
uncommon in many application data sets <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib24" title="" class="ltx_ref">24</a>]</cite>. We used
synthetic data sets, as opposed to standard benchmarks, so that we could
adjust the strength and dimensionality of the clustering. Our results
show that these new splitting methods can provide significant
improvements over the standard kd-tree splitting method for data sets
with low-dimensional clustering. The rest of the paper is organized as
follows. In the next section we present background information on the
kd-tree and how to perform nearest neighbor searches in this tree. In
Section <a href="#S3" title="3 Splitting Methods ‣ Analysis of Approximate Nearest Neighbor Searching with Clustered Point SetsThe support of the National Science Foundation under grant CCR–9712379 is gratefully acknowledged." class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a> we present the two new splitting methods. In
Section <a href="#S4" title="4 Empirical Results ‣ Analysis of Approximate Nearest Neighbor Searching with Clustered Point SetsThe support of the National Science Foundation under grant CCR–9712379 is gratefully acknowledged." class="ltx_ref"><span class="ltx_text ltx_ref_tag">4</span></a> we describe our implementation and present our
empirical results.</p>
</div>
</section>
<section id="S2" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">2 </span>Background</h2>

<div id="S2.p1" class="ltx_para">
<p id="S2.p1.1" class="ltx_p">In this section we describe how kd-trees are used for performing exact
and approximate nearest neighbor searching. Bentley introduced the
kd-tree as a generalization of the binary search tree in higher
dimensions <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib6" title="" class="ltx_ref">6</a>]</cite>. Each node of the tree is implicitly associated
with a <math id="S2.p1.1.m1.1" class="ltx_Math" alttext="d" display="inline"><semantics id="S2.p1.1.m1.1a"><mi id="S2.p1.1.m1.1.1" xref="S2.p1.1.m1.1.1.cmml">d</mi><annotation-xml encoding="MathML-Content" id="S2.p1.1.m1.1b"><ci id="S2.p1.1.m1.1.1.cmml" xref="S2.p1.1.m1.1.1">𝑑</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p1.1.m1.1c">d</annotation><annotation encoding="application/x-llamapun" id="S2.p1.1.m1.1d">italic_d</annotation></semantics></math>-dimensional rectangle, called its <span id="S2.p1.1.1" class="ltx_text ltx_font_italic">cell</span>. The root node
is associated with the bounding rectangle, which encloses all of the
data points. Each node is also implicitly associated with the subset of
data points that lie within this rectangle. (Data points lying on the
boundary between two rectangles, may be associated with either.) If the
number of points associated with a node falls below a given threshold,
called the <span id="S2.p1.1.2" class="ltx_text ltx_font_italic">bucket size</span>, then this node is a leaf, and these points
are stored with the leaf. (In our experiments we used a bucket size of
one.) Otherwise, the construction algorithm selects a splitting
hyperplane, which is orthogonal to one of the coordinate axes and passes
through the cell. There are a number of <span id="S2.p1.1.3" class="ltx_text ltx_font_italic">splitting methods</span> that may
be used for choosing this hyperplane. We will discuss these in greater
detail below. The hyperplane subdivides the associated cell into
two subrectangles, which are then associated with the children of this
node, and the points are subdivided among these children according to
which side of the hyperplane they lie. Each internal node of the tree
is associated with its splitting hyperplane (which may be given as the
index of the orthogonal axis and a cutting value along this axis).</p>
</div>
<div id="S2.p2" class="ltx_para">
<p id="S2.p2.2" class="ltx_p">Friedman, Bentley and Finkel <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib21" title="" class="ltx_ref">21</a>]</cite> present an algorithm to
find the nearest neighbor using the kd-trees. They introduce the
following splitting method, which we call the <span id="S2.p2.2.1" class="ltx_text ltx_font_italic">standard splitting
method</span>. For each internal node, the splitting hyperplane is chosen to
be orthogonal to the axis along which the points have the greatest <span id="S2.p2.2.2" class="ltx_text ltx_font_italic">spread</span> (difference of maximum and minimum). The splitting point is
chosen at the median coordinate, so that the two subsets of data points
have nearly equal sizes. The resulting tree has <math id="S2.p2.1.m1.1" class="ltx_Math" alttext="O(n)" display="inline"><semantics id="S2.p2.1.m1.1a"><mrow id="S2.p2.1.m1.1.2" xref="S2.p2.1.m1.1.2.cmml"><mi id="S2.p2.1.m1.1.2.2" xref="S2.p2.1.m1.1.2.2.cmml">O</mi><mo id="S2.p2.1.m1.1.2.1" xref="S2.p2.1.m1.1.2.1.cmml">⁢</mo><mrow id="S2.p2.1.m1.1.2.3.2" xref="S2.p2.1.m1.1.2.cmml"><mo stretchy="false" id="S2.p2.1.m1.1.2.3.2.1" xref="S2.p2.1.m1.1.2.cmml">(</mo><mi id="S2.p2.1.m1.1.1" xref="S2.p2.1.m1.1.1.cmml">n</mi><mo stretchy="false" id="S2.p2.1.m1.1.2.3.2.2" xref="S2.p2.1.m1.1.2.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S2.p2.1.m1.1b"><apply id="S2.p2.1.m1.1.2.cmml" xref="S2.p2.1.m1.1.2"><times id="S2.p2.1.m1.1.2.1.cmml" xref="S2.p2.1.m1.1.2.1"></times><ci id="S2.p2.1.m1.1.2.2.cmml" xref="S2.p2.1.m1.1.2.2">𝑂</ci><ci id="S2.p2.1.m1.1.1.cmml" xref="S2.p2.1.m1.1.1">𝑛</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.1.m1.1c">O(n)</annotation><annotation encoding="application/x-llamapun" id="S2.p2.1.m1.1d">italic_O ( italic_n )</annotation></semantics></math> size and <math id="S2.p2.2.m2.1" class="ltx_Math" alttext="O(\log n)" display="inline"><semantics id="S2.p2.2.m2.1a"><mrow id="S2.p2.2.m2.1.1" xref="S2.p2.2.m2.1.1.cmml"><mi id="S2.p2.2.m2.1.1.3" xref="S2.p2.2.m2.1.1.3.cmml">O</mi><mo id="S2.p2.2.m2.1.1.2" xref="S2.p2.2.m2.1.1.2.cmml">⁢</mo><mrow id="S2.p2.2.m2.1.1.1.1" xref="S2.p2.2.m2.1.1.1.1.1.cmml"><mo stretchy="false" id="S2.p2.2.m2.1.1.1.1.2" xref="S2.p2.2.m2.1.1.1.1.1.cmml">(</mo><mrow id="S2.p2.2.m2.1.1.1.1.1" xref="S2.p2.2.m2.1.1.1.1.1.cmml"><mi id="S2.p2.2.m2.1.1.1.1.1.1" xref="S2.p2.2.m2.1.1.1.1.1.1.cmml">log</mi><mo lspace="0.167em" id="S2.p2.2.m2.1.1.1.1.1a" xref="S2.p2.2.m2.1.1.1.1.1.cmml">⁡</mo><mi id="S2.p2.2.m2.1.1.1.1.1.2" xref="S2.p2.2.m2.1.1.1.1.1.2.cmml">n</mi></mrow><mo stretchy="false" id="S2.p2.2.m2.1.1.1.1.3" xref="S2.p2.2.m2.1.1.1.1.1.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S2.p2.2.m2.1b"><apply id="S2.p2.2.m2.1.1.cmml" xref="S2.p2.2.m2.1.1"><times id="S2.p2.2.m2.1.1.2.cmml" xref="S2.p2.2.m2.1.1.2"></times><ci id="S2.p2.2.m2.1.1.3.cmml" xref="S2.p2.2.m2.1.1.3">𝑂</ci><apply id="S2.p2.2.m2.1.1.1.1.1.cmml" xref="S2.p2.2.m2.1.1.1.1"><log id="S2.p2.2.m2.1.1.1.1.1.1.cmml" xref="S2.p2.2.m2.1.1.1.1.1.1"></log><ci id="S2.p2.2.m2.1.1.1.1.1.2.cmml" xref="S2.p2.2.m2.1.1.1.1.1.2">𝑛</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p2.2.m2.1c">O(\log n)</annotation><annotation encoding="application/x-llamapun" id="S2.p2.2.m2.1d">italic_O ( roman_log italic_n )</annotation></semantics></math> height. White and Jain <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib33" title="" class="ltx_ref">33</a>]</cite> proposed an alternative,
called the <span id="S2.p2.2.3" class="ltx_text ltx_font_italic">VAM-split</span>, with the same basic idea, but the splitting
dimension is chosen to be the one with the maximum variance.</p>
</div>
<div id="S2.p3" class="ltx_para">
<p id="S2.p3.1" class="ltx_p">Queries are answered by a simple recursive algorithm. In the basis
case, when the algorithm arrives at a leaf of the tree, it computes the
distance from the query point to each of the data points associated with
this node. The smallest such distance is saved. When arriving at an
internal node, it first determines the side of the associated hyperplane
on which the query point lies. The query point is necessarily closer to
this child’s cell. The search recursively visits this child. On
returning from the search, it determines whether the cell associated
with the other child is closer to the query point than the closest point
seen so far. If so, then this child is also visited recursively. When
the search returns from the root, the closest point seen is returned.
An important observation is that for each query point, every leaf whose
distance from the query point is less than the nearest neighbor will be
visited by the algorithm.</p>
</div>
<div id="S2.p4" class="ltx_para">
<p id="S2.p4.3" class="ltx_p">It is an easy matter to generalize this search algorithm for answering
<span id="S2.p4.3.1" class="ltx_text ltx_font_italic">approximate</span> nearest neighbor queries. Let <math id="S2.p4.1.m1.1" class="ltx_Math" alttext="\epsilon" display="inline"><semantics id="S2.p4.1.m1.1a"><mi id="S2.p4.1.m1.1.1" xref="S2.p4.1.m1.1.1.cmml">ϵ</mi><annotation-xml encoding="MathML-Content" id="S2.p4.1.m1.1b"><ci id="S2.p4.1.m1.1.1.cmml" xref="S2.p4.1.m1.1.1">italic-ϵ</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p4.1.m1.1c">\epsilon</annotation><annotation encoding="application/x-llamapun" id="S2.p4.1.m1.1d">italic_ϵ</annotation></semantics></math> denote the
allowed error bound. In the processing of an internal node, the further
child is visited only if its distance from the query point is less than
the distance to the closest point so far, divided by <math id="S2.p4.2.m2.1" class="ltx_Math" alttext="(1+\epsilon)" display="inline"><semantics id="S2.p4.2.m2.1a"><mrow id="S2.p4.2.m2.1.1.1" xref="S2.p4.2.m2.1.1.1.1.cmml"><mo stretchy="false" id="S2.p4.2.m2.1.1.1.2" xref="S2.p4.2.m2.1.1.1.1.cmml">(</mo><mrow id="S2.p4.2.m2.1.1.1.1" xref="S2.p4.2.m2.1.1.1.1.cmml"><mn id="S2.p4.2.m2.1.1.1.1.2" xref="S2.p4.2.m2.1.1.1.1.2.cmml">1</mn><mo id="S2.p4.2.m2.1.1.1.1.1" xref="S2.p4.2.m2.1.1.1.1.1.cmml">+</mo><mi id="S2.p4.2.m2.1.1.1.1.3" xref="S2.p4.2.m2.1.1.1.1.3.cmml">ϵ</mi></mrow><mo stretchy="false" id="S2.p4.2.m2.1.1.1.3" xref="S2.p4.2.m2.1.1.1.1.cmml">)</mo></mrow><annotation-xml encoding="MathML-Content" id="S2.p4.2.m2.1b"><apply id="S2.p4.2.m2.1.1.1.1.cmml" xref="S2.p4.2.m2.1.1.1"><plus id="S2.p4.2.m2.1.1.1.1.1.cmml" xref="S2.p4.2.m2.1.1.1.1.1"></plus><cn type="integer" id="S2.p4.2.m2.1.1.1.1.2.cmml" xref="S2.p4.2.m2.1.1.1.1.2">1</cn><ci id="S2.p4.2.m2.1.1.1.1.3.cmml" xref="S2.p4.2.m2.1.1.1.1.3">italic-ϵ</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p4.2.m2.1c">(1+\epsilon)</annotation><annotation encoding="application/x-llamapun" id="S2.p4.2.m2.1d">( 1 + italic_ϵ )</annotation></semantics></math>.
Arya et al. <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib3" title="" class="ltx_ref">3</a>]</cite> show the correctness of this
procedure. They also show how to generalize the search algorithm for
computing the <math id="S2.p4.3.m3.1" class="ltx_Math" alttext="k" display="inline"><semantics id="S2.p4.3.m3.1a"><mi id="S2.p4.3.m3.1.1" xref="S2.p4.3.m3.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S2.p4.3.m3.1b"><ci id="S2.p4.3.m3.1.1.cmml" xref="S2.p4.3.m3.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p4.3.m3.1c">k</annotation><annotation encoding="application/x-llamapun" id="S2.p4.3.m3.1d">italic_k</annotation></semantics></math>-closest neighbors, either exactly or approximately.</p>
</div>
<div id="S2.p5" class="ltx_para">
<p id="S2.p5.1" class="ltx_p">Arya and Mount <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib1" title="" class="ltx_ref">1</a>]</cite> proposed a number of improvements to
this basic algorithm. The first is called <span id="S2.p5.1.1" class="ltx_text ltx_font_italic">incremental distance
calculation</span>. This technique can be applied for any Minkowski metric.
In addition to storing the splitting hyperplane, each internal node of
the tree also stores the extents of associated cell projected
orthogonally onto its splitting axis. The algorithm does not maintain
true distances, but instead (for the Euclidean metric) maintains squared
distances. When the algorithm arrives at an internal node, it knows the
squared distance from the query point to the associated cell. They show
that in constant time (independent of dimension) it is possible to use
this information to compute the squared distance to each of the
children’s cell. They also presented a method called <span id="S2.p5.1.2" class="ltx_text ltx_font_italic">priority
search</span>, which uses a heap to visit the leaves of the tree in increasing
order of distance from the query point, rather than in the recursive
order dictated by the structure of the tree. Yet another improvement is
a well-known technique from nearest neighbor searching, called <span id="S2.p5.1.3" class="ltx_text ltx_font_italic">partial distance calculation</span> <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib5" title="" class="ltx_ref">5</a>, <a href="#bib.bib32" title="" class="ltx_ref">32</a>]</cite>. When
computing the distance between the query point and a data point, if the
accumulated sum of squared components ever exceeds the squared distance
to the nearest point so far, then the distance computation is
terminated.</p>
</div>
<div id="S2.p6" class="ltx_para">
<p id="S2.p6.1" class="ltx_p">One of the important elements of approximate nearest neighbor searching,
which was observed by Arya et al. <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib3" title="" class="ltx_ref">3</a>]</cite>, is that there
are two important properties of any data structure for approximate
nearest neighbor searching based on spatial decomposition.</p>
</div>
<div id="S2.p7" class="ltx_para">
<dl id="S2.I1" class="ltx_description">
<dt id="S2.I1.ix1" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S2.I1.ix1.1.1.1" class="ltx_text ltx_font_bold">Balance:</span></span></dt>
<dd class="ltx_item">
<div id="S2.I1.ix1.p1" class="ltx_para">
<p id="S2.I1.ix1.p1.2" class="ltx_p">The height of the tree should be <math id="S2.I1.ix1.p1.1.m1.1" class="ltx_Math" alttext="O(\log n)" display="inline"><semantics id="S2.I1.ix1.p1.1.m1.1a"><mrow id="S2.I1.ix1.p1.1.m1.1.1" xref="S2.I1.ix1.p1.1.m1.1.1.cmml"><mi id="S2.I1.ix1.p1.1.m1.1.1.3" xref="S2.I1.ix1.p1.1.m1.1.1.3.cmml">O</mi><mo id="S2.I1.ix1.p1.1.m1.1.1.2" xref="S2.I1.ix1.p1.1.m1.1.1.2.cmml">⁢</mo><mrow id="S2.I1.ix1.p1.1.m1.1.1.1.1" xref="S2.I1.ix1.p1.1.m1.1.1.1.1.1.cmml"><mo stretchy="false" id="S2.I1.ix1.p1.1.m1.1.1.1.1.2" xref="S2.I1.ix1.p1.1.m1.1.1.1.1.1.cmml">(</mo><mrow id="S2.I1.ix1.p1.1.m1.1.1.1.1.1" xref="S2.I1.ix1.p1.1.m1.1.1.1.1.1.cmml"><mi id="S2.I1.ix1.p1.1.m1.1.1.1.1.1.1" xref="S2.I1.ix1.p1.1.m1.1.1.1.1.1.1.cmml">log</mi><mo lspace="0.167em" id="S2.I1.ix1.p1.1.m1.1.1.1.1.1a" xref="S2.I1.ix1.p1.1.m1.1.1.1.1.1.cmml">⁡</mo><mi id="S2.I1.ix1.p1.1.m1.1.1.1.1.1.2" xref="S2.I1.ix1.p1.1.m1.1.1.1.1.1.2.cmml">n</mi></mrow><mo stretchy="false" id="S2.I1.ix1.p1.1.m1.1.1.1.1.3" xref="S2.I1.ix1.p1.1.m1.1.1.1.1.1.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S2.I1.ix1.p1.1.m1.1b"><apply id="S2.I1.ix1.p1.1.m1.1.1.cmml" xref="S2.I1.ix1.p1.1.m1.1.1"><times id="S2.I1.ix1.p1.1.m1.1.1.2.cmml" xref="S2.I1.ix1.p1.1.m1.1.1.2"></times><ci id="S2.I1.ix1.p1.1.m1.1.1.3.cmml" xref="S2.I1.ix1.p1.1.m1.1.1.3">𝑂</ci><apply id="S2.I1.ix1.p1.1.m1.1.1.1.1.1.cmml" xref="S2.I1.ix1.p1.1.m1.1.1.1.1"><log id="S2.I1.ix1.p1.1.m1.1.1.1.1.1.1.cmml" xref="S2.I1.ix1.p1.1.m1.1.1.1.1.1.1"></log><ci id="S2.I1.ix1.p1.1.m1.1.1.1.1.1.2.cmml" xref="S2.I1.ix1.p1.1.m1.1.1.1.1.1.2">𝑛</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.I1.ix1.p1.1.m1.1c">O(\log n)</annotation><annotation encoding="application/x-llamapun" id="S2.I1.ix1.p1.1.m1.1d">italic_O ( roman_log italic_n )</annotation></semantics></math>, where
<math id="S2.I1.ix1.p1.2.m2.1" class="ltx_Math" alttext="n" display="inline"><semantics id="S2.I1.ix1.p1.2.m2.1a"><mi id="S2.I1.ix1.p1.2.m2.1.1" xref="S2.I1.ix1.p1.2.m2.1.1.cmml">n</mi><annotation-xml encoding="MathML-Content" id="S2.I1.ix1.p1.2.m2.1b"><ci id="S2.I1.ix1.p1.2.m2.1.1.cmml" xref="S2.I1.ix1.p1.2.m2.1.1">𝑛</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.I1.ix1.p1.2.m2.1c">n</annotation><annotation encoding="application/x-llamapun" id="S2.I1.ix1.p1.2.m2.1d">italic_n</annotation></semantics></math> is the number of data points.</p>
</div>
</dd>
<dt id="S2.I1.ix2" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S2.I1.ix2.1.1.1" class="ltx_text ltx_font_bold">Bounded aspect ratio:</span></span></dt>
<dd class="ltx_item">
<div id="S2.I1.ix2.p1" class="ltx_para">
<p id="S2.I1.ix2.p1.1" class="ltx_p">The leaf cells of the tree should have
bounded aspect ratio, meaning that the ratio of the longest
to shortest side of each leaf cell should be bounded above
by a constant.
</p>
</div>
</dd>
</dl>
</div>
<div id="S2.p8" class="ltx_para">
<p id="S2.p8.3" class="ltx_p">Given these two constraints, they show that approximate nearest neighbor
searching (using priority search) can be performed in <math id="S2.p8.1.m1.1" class="ltx_Math" alttext="O(\log n)" display="inline"><semantics id="S2.p8.1.m1.1a"><mrow id="S2.p8.1.m1.1.1" xref="S2.p8.1.m1.1.1.cmml"><mi id="S2.p8.1.m1.1.1.3" xref="S2.p8.1.m1.1.1.3.cmml">O</mi><mo id="S2.p8.1.m1.1.1.2" xref="S2.p8.1.m1.1.1.2.cmml">⁢</mo><mrow id="S2.p8.1.m1.1.1.1.1" xref="S2.p8.1.m1.1.1.1.1.1.cmml"><mo stretchy="false" id="S2.p8.1.m1.1.1.1.1.2" xref="S2.p8.1.m1.1.1.1.1.1.cmml">(</mo><mrow id="S2.p8.1.m1.1.1.1.1.1" xref="S2.p8.1.m1.1.1.1.1.1.cmml"><mi id="S2.p8.1.m1.1.1.1.1.1.1" xref="S2.p8.1.m1.1.1.1.1.1.1.cmml">log</mi><mo lspace="0.167em" id="S2.p8.1.m1.1.1.1.1.1a" xref="S2.p8.1.m1.1.1.1.1.1.cmml">⁡</mo><mi id="S2.p8.1.m1.1.1.1.1.1.2" xref="S2.p8.1.m1.1.1.1.1.1.2.cmml">n</mi></mrow><mo stretchy="false" id="S2.p8.1.m1.1.1.1.1.3" xref="S2.p8.1.m1.1.1.1.1.1.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S2.p8.1.m1.1b"><apply id="S2.p8.1.m1.1.1.cmml" xref="S2.p8.1.m1.1.1"><times id="S2.p8.1.m1.1.1.2.cmml" xref="S2.p8.1.m1.1.1.2"></times><ci id="S2.p8.1.m1.1.1.3.cmml" xref="S2.p8.1.m1.1.1.3">𝑂</ci><apply id="S2.p8.1.m1.1.1.1.1.1.cmml" xref="S2.p8.1.m1.1.1.1.1"><log id="S2.p8.1.m1.1.1.1.1.1.1.cmml" xref="S2.p8.1.m1.1.1.1.1.1.1"></log><ci id="S2.p8.1.m1.1.1.1.1.1.2.cmml" xref="S2.p8.1.m1.1.1.1.1.1.2">𝑛</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p8.1.m1.1c">O(\log n)</annotation><annotation encoding="application/x-llamapun" id="S2.p8.1.m1.1d">italic_O ( roman_log italic_n )</annotation></semantics></math> time
from a data structure of size <math id="S2.p8.2.m2.1" class="ltx_Math" alttext="O(dn)" display="inline"><semantics id="S2.p8.2.m2.1a"><mrow id="S2.p8.2.m2.1.1" xref="S2.p8.2.m2.1.1.cmml"><mi id="S2.p8.2.m2.1.1.3" xref="S2.p8.2.m2.1.1.3.cmml">O</mi><mo id="S2.p8.2.m2.1.1.2" xref="S2.p8.2.m2.1.1.2.cmml">⁢</mo><mrow id="S2.p8.2.m2.1.1.1.1" xref="S2.p8.2.m2.1.1.1.1.1.cmml"><mo stretchy="false" id="S2.p8.2.m2.1.1.1.1.2" xref="S2.p8.2.m2.1.1.1.1.1.cmml">(</mo><mrow id="S2.p8.2.m2.1.1.1.1.1" xref="S2.p8.2.m2.1.1.1.1.1.cmml"><mi id="S2.p8.2.m2.1.1.1.1.1.2" xref="S2.p8.2.m2.1.1.1.1.1.2.cmml">d</mi><mo id="S2.p8.2.m2.1.1.1.1.1.1" xref="S2.p8.2.m2.1.1.1.1.1.1.cmml">⁢</mo><mi id="S2.p8.2.m2.1.1.1.1.1.3" xref="S2.p8.2.m2.1.1.1.1.1.3.cmml">n</mi></mrow><mo stretchy="false" id="S2.p8.2.m2.1.1.1.1.3" xref="S2.p8.2.m2.1.1.1.1.1.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S2.p8.2.m2.1b"><apply id="S2.p8.2.m2.1.1.cmml" xref="S2.p8.2.m2.1.1"><times id="S2.p8.2.m2.1.1.2.cmml" xref="S2.p8.2.m2.1.1.2"></times><ci id="S2.p8.2.m2.1.1.3.cmml" xref="S2.p8.2.m2.1.1.3">𝑂</ci><apply id="S2.p8.2.m2.1.1.1.1.1.cmml" xref="S2.p8.2.m2.1.1.1.1"><times id="S2.p8.2.m2.1.1.1.1.1.1.cmml" xref="S2.p8.2.m2.1.1.1.1.1.1"></times><ci id="S2.p8.2.m2.1.1.1.1.1.2.cmml" xref="S2.p8.2.m2.1.1.1.1.1.2">𝑑</ci><ci id="S2.p8.2.m2.1.1.1.1.1.3.cmml" xref="S2.p8.2.m2.1.1.1.1.1.3">𝑛</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p8.2.m2.1c">O(dn)</annotation><annotation encoding="application/x-llamapun" id="S2.p8.2.m2.1d">italic_O ( italic_d italic_n )</annotation></semantics></math>. The hidden constant factors in
time grow as <math id="S2.p8.3.m3.1" class="ltx_Math" alttext="O(d/\epsilon)^{d}" display="inline"><semantics id="S2.p8.3.m3.1a"><mrow id="S2.p8.3.m3.1.1" xref="S2.p8.3.m3.1.1.cmml"><mi id="S2.p8.3.m3.1.1.3" xref="S2.p8.3.m3.1.1.3.cmml">O</mi><mo id="S2.p8.3.m3.1.1.2" xref="S2.p8.3.m3.1.1.2.cmml">⁢</mo><msup id="S2.p8.3.m3.1.1.1" xref="S2.p8.3.m3.1.1.1.cmml"><mrow id="S2.p8.3.m3.1.1.1.1.1" xref="S2.p8.3.m3.1.1.1.1.1.1.cmml"><mo stretchy="false" id="S2.p8.3.m3.1.1.1.1.1.2" xref="S2.p8.3.m3.1.1.1.1.1.1.cmml">(</mo><mrow id="S2.p8.3.m3.1.1.1.1.1.1" xref="S2.p8.3.m3.1.1.1.1.1.1.cmml"><mi id="S2.p8.3.m3.1.1.1.1.1.1.2" xref="S2.p8.3.m3.1.1.1.1.1.1.2.cmml">d</mi><mo id="S2.p8.3.m3.1.1.1.1.1.1.1" xref="S2.p8.3.m3.1.1.1.1.1.1.1.cmml">/</mo><mi id="S2.p8.3.m3.1.1.1.1.1.1.3" xref="S2.p8.3.m3.1.1.1.1.1.1.3.cmml">ϵ</mi></mrow><mo stretchy="false" id="S2.p8.3.m3.1.1.1.1.1.3" xref="S2.p8.3.m3.1.1.1.1.1.1.cmml">)</mo></mrow><mi id="S2.p8.3.m3.1.1.1.3" xref="S2.p8.3.m3.1.1.1.3.cmml">d</mi></msup></mrow><annotation-xml encoding="MathML-Content" id="S2.p8.3.m3.1b"><apply id="S2.p8.3.m3.1.1.cmml" xref="S2.p8.3.m3.1.1"><times id="S2.p8.3.m3.1.1.2.cmml" xref="S2.p8.3.m3.1.1.2"></times><ci id="S2.p8.3.m3.1.1.3.cmml" xref="S2.p8.3.m3.1.1.3">𝑂</ci><apply id="S2.p8.3.m3.1.1.1.cmml" xref="S2.p8.3.m3.1.1.1"><csymbol cd="ambiguous" id="S2.p8.3.m3.1.1.1.2.cmml" xref="S2.p8.3.m3.1.1.1">superscript</csymbol><apply id="S2.p8.3.m3.1.1.1.1.1.1.cmml" xref="S2.p8.3.m3.1.1.1.1.1"><divide id="S2.p8.3.m3.1.1.1.1.1.1.1.cmml" xref="S2.p8.3.m3.1.1.1.1.1.1.1"></divide><ci id="S2.p8.3.m3.1.1.1.1.1.1.2.cmml" xref="S2.p8.3.m3.1.1.1.1.1.1.2">𝑑</ci><ci id="S2.p8.3.m3.1.1.1.1.1.1.3.cmml" xref="S2.p8.3.m3.1.1.1.1.1.1.3">italic-ϵ</ci></apply><ci id="S2.p8.3.m3.1.1.1.3.cmml" xref="S2.p8.3.m3.1.1.1.3">𝑑</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p8.3.m3.1c">O(d/\epsilon)^{d}</annotation><annotation encoding="application/x-llamapun" id="S2.p8.3.m3.1d">italic_O ( italic_d / italic_ϵ ) start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT</annotation></semantics></math>. Unfortunately, achieving both of these
properties does not always seem to be possible for kd-trees. This is
particularly true when the point distribution is highly clustered. Arya
et al. present a somewhat more complex data structure called a <span id="S2.p8.3.1" class="ltx_text ltx_font_italic">balanced box-decomposition tree</span>, which does satisfy these properties.
The extra complexity seems to be necessary in order to prove their
theoretical results, and they show empirically that it is important when
data sets are highly clustered in low-dimensional subspaces. An
interesting practical question is whether there exist methods that
retain the essential simplicity of the kd-tree, while providing
practical efficiency for clustered data distributions (at least in most
instances, if not in the worst case).</p>
</div>
<div id="S2.p9" class="ltx_para">
<p id="S2.p9.3" class="ltx_p">Bounded aspect ratio is a sufficient condition for efficiency, but it is
not necessary. The more precise condition in order for their results to
apply is called the <span id="S2.p9.3.1" class="ltx_text ltx_font_italic">packing constraint</span> <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib3" title="" class="ltx_ref">3</a>]</cite>.
Define a <span id="S2.p9.3.2" class="ltx_text ltx_font_italic">ball</span> of radius <math id="S2.p9.1.m1.1" class="ltx_Math" alttext="r" display="inline"><semantics id="S2.p9.1.m1.1a"><mi id="S2.p9.1.m1.1.1" xref="S2.p9.1.m1.1.1.cmml">r</mi><annotation-xml encoding="MathML-Content" id="S2.p9.1.m1.1b"><ci id="S2.p9.1.m1.1.1.cmml" xref="S2.p9.1.m1.1.1">𝑟</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p9.1.m1.1c">r</annotation><annotation encoding="application/x-llamapun" id="S2.p9.1.m1.1d">italic_r</annotation></semantics></math> to be the locus of points that are
within distance <math id="S2.p9.2.m2.1" class="ltx_Math" alttext="r" display="inline"><semantics id="S2.p9.2.m2.1a"><mi id="S2.p9.2.m2.1.1" xref="S2.p9.2.m2.1.1.cmml">r</mi><annotation-xml encoding="MathML-Content" id="S2.p9.2.m2.1b"><ci id="S2.p9.2.m2.1.1.cmml" xref="S2.p9.2.m2.1.1">𝑟</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p9.2.m2.1c">r</annotation><annotation encoding="application/x-llamapun" id="S2.p9.2.m2.1d">italic_r</annotation></semantics></math> of some point in <math id="S2.p9.3.m3.1" class="ltx_Math" alttext="R^{d}" display="inline"><semantics id="S2.p9.3.m3.1a"><msup id="S2.p9.3.m3.1.1" xref="S2.p9.3.m3.1.1.cmml"><mi id="S2.p9.3.m3.1.1.2" xref="S2.p9.3.m3.1.1.2.cmml">R</mi><mi id="S2.p9.3.m3.1.1.3" xref="S2.p9.3.m3.1.1.3.cmml">d</mi></msup><annotation-xml encoding="MathML-Content" id="S2.p9.3.m3.1b"><apply id="S2.p9.3.m3.1.1.cmml" xref="S2.p9.3.m3.1.1"><csymbol cd="ambiguous" id="S2.p9.3.m3.1.1.1.cmml" xref="S2.p9.3.m3.1.1">superscript</csymbol><ci id="S2.p9.3.m3.1.1.2.cmml" xref="S2.p9.3.m3.1.1.2">𝑅</ci><ci id="S2.p9.3.m3.1.1.3.cmml" xref="S2.p9.3.m3.1.1.3">𝑑</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p9.3.m3.1c">R^{d}</annotation><annotation encoding="application/x-llamapun" id="S2.p9.3.m3.1d">italic_R start_POSTSUPERSCRIPT italic_d end_POSTSUPERSCRIPT</annotation></semantics></math> according to the chosen
metric. The packing constraint says that the number of large cells that
intersect any such ball is bounded.
</p>
</div>
<div id="S2.p10" class="ltx_para">
<dl id="S2.I2" class="ltx_description">
<dt id="S2.I2.ix1" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S2.I2.ix1.1.1.1" class="ltx_text ltx_font_bold">Packing Constraint:</span></span></dt>
<dd class="ltx_item">
<div id="S2.I2.ix1.p1" class="ltx_para">
<p id="S2.I2.ix1.p1.5" class="ltx_p">The number of leaf cells of size at least
<math id="S2.I2.ix1.p1.1.m1.1" class="ltx_Math" alttext="s" display="inline"><semantics id="S2.I2.ix1.p1.1.m1.1a"><mi id="S2.I2.ix1.p1.1.m1.1.1" xref="S2.I2.ix1.p1.1.m1.1.1.cmml">s</mi><annotation-xml encoding="MathML-Content" id="S2.I2.ix1.p1.1.m1.1b"><ci id="S2.I2.ix1.p1.1.m1.1.1.cmml" xref="S2.I2.ix1.p1.1.m1.1.1">𝑠</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.I2.ix1.p1.1.m1.1c">s</annotation><annotation encoding="application/x-llamapun" id="S2.I2.ix1.p1.1.m1.1d">italic_s</annotation></semantics></math> that intersect an open ball of radius <math id="S2.I2.ix1.p1.2.m2.1" class="ltx_Math" alttext="r&gt;0" display="inline"><semantics id="S2.I2.ix1.p1.2.m2.1a"><mrow id="S2.I2.ix1.p1.2.m2.1.1" xref="S2.I2.ix1.p1.2.m2.1.1.cmml"><mi id="S2.I2.ix1.p1.2.m2.1.1.2" xref="S2.I2.ix1.p1.2.m2.1.1.2.cmml">r</mi><mo id="S2.I2.ix1.p1.2.m2.1.1.1" xref="S2.I2.ix1.p1.2.m2.1.1.1.cmml">&gt;</mo><mn id="S2.I2.ix1.p1.2.m2.1.1.3" xref="S2.I2.ix1.p1.2.m2.1.1.3.cmml">0</mn></mrow><annotation-xml encoding="MathML-Content" id="S2.I2.ix1.p1.2.m2.1b"><apply id="S2.I2.ix1.p1.2.m2.1.1.cmml" xref="S2.I2.ix1.p1.2.m2.1.1"><gt id="S2.I2.ix1.p1.2.m2.1.1.1.cmml" xref="S2.I2.ix1.p1.2.m2.1.1.1"></gt><ci id="S2.I2.ix1.p1.2.m2.1.1.2.cmml" xref="S2.I2.ix1.p1.2.m2.1.1.2">𝑟</ci><cn type="integer" id="S2.I2.ix1.p1.2.m2.1.1.3.cmml" xref="S2.I2.ix1.p1.2.m2.1.1.3">0</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.I2.ix1.p1.2.m2.1c">r&gt;0</annotation><annotation encoding="application/x-llamapun" id="S2.I2.ix1.p1.2.m2.1d">italic_r &gt; 0</annotation></semantics></math> is bounded
above by a function of <math id="S2.I2.ix1.p1.3.m3.1" class="ltx_Math" alttext="r/s" display="inline"><semantics id="S2.I2.ix1.p1.3.m3.1a"><mrow id="S2.I2.ix1.p1.3.m3.1.1" xref="S2.I2.ix1.p1.3.m3.1.1.cmml"><mi id="S2.I2.ix1.p1.3.m3.1.1.2" xref="S2.I2.ix1.p1.3.m3.1.1.2.cmml">r</mi><mo id="S2.I2.ix1.p1.3.m3.1.1.1" xref="S2.I2.ix1.p1.3.m3.1.1.1.cmml">/</mo><mi id="S2.I2.ix1.p1.3.m3.1.1.3" xref="S2.I2.ix1.p1.3.m3.1.1.3.cmml">s</mi></mrow><annotation-xml encoding="MathML-Content" id="S2.I2.ix1.p1.3.m3.1b"><apply id="S2.I2.ix1.p1.3.m3.1.1.cmml" xref="S2.I2.ix1.p1.3.m3.1.1"><divide id="S2.I2.ix1.p1.3.m3.1.1.1.cmml" xref="S2.I2.ix1.p1.3.m3.1.1.1"></divide><ci id="S2.I2.ix1.p1.3.m3.1.1.2.cmml" xref="S2.I2.ix1.p1.3.m3.1.1.2">𝑟</ci><ci id="S2.I2.ix1.p1.3.m3.1.1.3.cmml" xref="S2.I2.ix1.p1.3.m3.1.1.3">𝑠</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.I2.ix1.p1.3.m3.1c">r/s</annotation><annotation encoding="application/x-llamapun" id="S2.I2.ix1.p1.3.m3.1d">italic_r / italic_s</annotation></semantics></math> and <math id="S2.I2.ix1.p1.4.m4.1" class="ltx_Math" alttext="d" display="inline"><semantics id="S2.I2.ix1.p1.4.m4.1a"><mi id="S2.I2.ix1.p1.4.m4.1.1" xref="S2.I2.ix1.p1.4.m4.1.1.cmml">d</mi><annotation-xml encoding="MathML-Content" id="S2.I2.ix1.p1.4.m4.1b"><ci id="S2.I2.ix1.p1.4.m4.1.1.cmml" xref="S2.I2.ix1.p1.4.m4.1.1">𝑑</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.I2.ix1.p1.4.m4.1c">d</annotation><annotation encoding="application/x-llamapun" id="S2.I2.ix1.p1.4.m4.1d">italic_d</annotation></semantics></math>, but independent of <math id="S2.I2.ix1.p1.5.m5.1" class="ltx_Math" alttext="n" display="inline"><semantics id="S2.I2.ix1.p1.5.m5.1a"><mi id="S2.I2.ix1.p1.5.m5.1.1" xref="S2.I2.ix1.p1.5.m5.1.1.cmml">n</mi><annotation-xml encoding="MathML-Content" id="S2.I2.ix1.p1.5.m5.1b"><ci id="S2.I2.ix1.p1.5.m5.1.1.cmml" xref="S2.I2.ix1.p1.5.m5.1.1">𝑛</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.I2.ix1.p1.5.m5.1c">n</annotation><annotation encoding="application/x-llamapun" id="S2.I2.ix1.p1.5.m5.1d">italic_n</annotation></semantics></math>.</p>
</div>
</dd>
</dl>
</div>
<div id="S2.p11" class="ltx_para">
<p id="S2.p11.3" class="ltx_p">If a tree has cells of bounded aspect ratio, then it satisfies the
packing constraint. Arya et al., show that if this assumption is
satisfied, then priority search runs in time that is proportional to the
depth of the tree, times the number of cells of maximum side length
<math id="S2.p11.1.m1.1" class="ltx_Math" alttext="r\epsilon/d" display="inline"><semantics id="S2.p11.1.m1.1a"><mrow id="S2.p11.1.m1.1.1" xref="S2.p11.1.m1.1.1.cmml"><mrow id="S2.p11.1.m1.1.1.2" xref="S2.p11.1.m1.1.1.2.cmml"><mi id="S2.p11.1.m1.1.1.2.2" xref="S2.p11.1.m1.1.1.2.2.cmml">r</mi><mo id="S2.p11.1.m1.1.1.2.1" xref="S2.p11.1.m1.1.1.2.1.cmml">⁢</mo><mi id="S2.p11.1.m1.1.1.2.3" xref="S2.p11.1.m1.1.1.2.3.cmml">ϵ</mi></mrow><mo id="S2.p11.1.m1.1.1.1" xref="S2.p11.1.m1.1.1.1.cmml">/</mo><mi id="S2.p11.1.m1.1.1.3" xref="S2.p11.1.m1.1.1.3.cmml">d</mi></mrow><annotation-xml encoding="MathML-Content" id="S2.p11.1.m1.1b"><apply id="S2.p11.1.m1.1.1.cmml" xref="S2.p11.1.m1.1.1"><divide id="S2.p11.1.m1.1.1.1.cmml" xref="S2.p11.1.m1.1.1.1"></divide><apply id="S2.p11.1.m1.1.1.2.cmml" xref="S2.p11.1.m1.1.1.2"><times id="S2.p11.1.m1.1.1.2.1.cmml" xref="S2.p11.1.m1.1.1.2.1"></times><ci id="S2.p11.1.m1.1.1.2.2.cmml" xref="S2.p11.1.m1.1.1.2.2">𝑟</ci><ci id="S2.p11.1.m1.1.1.2.3.cmml" xref="S2.p11.1.m1.1.1.2.3">italic-ϵ</ci></apply><ci id="S2.p11.1.m1.1.1.3.cmml" xref="S2.p11.1.m1.1.1.3">𝑑</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S2.p11.1.m1.1c">r\epsilon/d</annotation><annotation encoding="application/x-llamapun" id="S2.p11.1.m1.1d">italic_r italic_ϵ / italic_d</annotation></semantics></math> that intersect a ball of radius <math id="S2.p11.2.m2.1" class="ltx_Math" alttext="r" display="inline"><semantics id="S2.p11.2.m2.1a"><mi id="S2.p11.2.m2.1.1" xref="S2.p11.2.m2.1.1.cmml">r</mi><annotation-xml encoding="MathML-Content" id="S2.p11.2.m2.1b"><ci id="S2.p11.2.m2.1.1.cmml" xref="S2.p11.2.m2.1.1">𝑟</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p11.2.m2.1c">r</annotation><annotation encoding="application/x-llamapun" id="S2.p11.2.m2.1d">italic_r</annotation></semantics></math>. By the packing
constraint this number of cells depends only on the dimension and
<math id="S2.p11.3.m3.1" class="ltx_Math" alttext="\epsilon" display="inline"><semantics id="S2.p11.3.m3.1a"><mi id="S2.p11.3.m3.1.1" xref="S2.p11.3.m3.1.1.cmml">ϵ</mi><annotation-xml encoding="MathML-Content" id="S2.p11.3.m3.1b"><ci id="S2.p11.3.m3.1.1.cmml" xref="S2.p11.3.m3.1.1">italic-ϵ</ci></annotation-xml><annotation encoding="application/x-tex" id="S2.p11.3.m3.1c">\epsilon</annotation><annotation encoding="application/x-llamapun" id="S2.p11.3.m3.1d">italic_ϵ</annotation></semantics></math>. The main shortcoming of the standard splitting method is
that it may result in cells of unbounded aspect ratio.</p>
</div>
</section>
<section id="S3" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">3 </span>Splitting Methods</h2>

<div id="S3.p1" class="ltx_para">
<p id="S3.p1.1" class="ltx_p">In this section we describe the splitting methods that are considered
in our experiments. As mentioned in the introduction, we implemented
two splitting methods, in addition to the standard kd-tree splitting
method. We describe them further in each of the following sections.</p>
</div>
<section id="S3.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">3.1 </span>Sliding-Midpoint</h3>

<div id="S3.SS1.p1" class="ltx_para">
<p id="S3.SS1.p1.1" class="ltx_p">The sliding-midpoint splitting method was first introduced in the ANN
library for approximate nearest neighbor searching <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib30" title="" class="ltx_ref">30</a>]</cite>.
This method was motivated to remedy the deficiencies of two other
splitting methods, the standard kd-tree splitting method and the
midpoint splitting method. To understand the problem, suppose that the
data points are highly clustered along a few dimensions but vary greatly
along some the others (see Fig. <a href="#S3.F1" title="Figure 1 ‣ 3.1 Sliding-Midpoint ‣ 3 Splitting Methods ‣ Analysis of Approximate Nearest Neighbor Searching with Clustered Point SetsThe support of the National Science Foundation under grant CCR–9712379 is gratefully acknowledged." class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a>). The standard kd-tree
splitting method will repeatedly split along the dimension in which the
data points have the greatest spread, leading to many cells with high
aspect ratio. A nearest neighbor query near the center of the bounding
square would visit a large number of these cells. In contrast, the
midpoint splitting method bisects the cell along its longest side,
irrespective of the point distribution. (If there are ties for the
longest side, then the tie is broken in favor of the dimension along
which the points have the highest spread.) This method produces cells of
aspect ratio at most 2, but it may produce leaf cells that contain no
data points. The size of the resulting tree may be very large when the
data distribution is highly clustered data and the dimension is high.</p>
</div>
<figure id="S3.F1" class="ltx_figure">
<p id="S3.F1.1" class="ltx_p ltx_align_center"><span id="S3.F1.1.1" class="ltx_text"><img src="/html/cs/9901013/assets/x1.png" id="S3.F1.1.1.g1" class="ltx_graphics ltx_img_landscape" width="480" height="173" alt="Refer to caption"></span></p>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 1: </span>Splitting methods with clustered point sets.</figcaption>
</figure>
<div id="S3.SS1.p2" class="ltx_para">
<p id="S3.SS1.p2.7" class="ltx_p">The sliding midpoint method works as follows. It first attempts to
perform a midpoint split, by the same method described above. If data
points lie on both sides of the splitting plane then the algorithm acts
exactly as it would for the midpoint split. However, if a trivial split
were to result (in which all the points lie to one side of the splitting
plane), then it attempts to avoid this by “sliding” the splitting plane
towards the points until it encounters the first data point. More
formally, if the split is performed orthogonal to the <math id="S3.SS1.p2.1.m1.1" class="ltx_Math" alttext="i" display="inline"><semantics id="S3.SS1.p2.1.m1.1a"><mi id="S3.SS1.p2.1.m1.1.1" xref="S3.SS1.p2.1.m1.1.1.cmml">i</mi><annotation-xml encoding="MathML-Content" id="S3.SS1.p2.1.m1.1b"><ci id="S3.SS1.p2.1.m1.1.1.cmml" xref="S3.SS1.p2.1.m1.1.1">𝑖</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS1.p2.1.m1.1c">i</annotation><annotation encoding="application/x-llamapun" id="S3.SS1.p2.1.m1.1d">italic_i</annotation></semantics></math>th coordinate,
and all the data points have <math id="S3.SS1.p2.2.m2.1" class="ltx_Math" alttext="i" display="inline"><semantics id="S3.SS1.p2.2.m2.1a"><mi id="S3.SS1.p2.2.m2.1.1" xref="S3.SS1.p2.2.m2.1.1.cmml">i</mi><annotation-xml encoding="MathML-Content" id="S3.SS1.p2.2.m2.1b"><ci id="S3.SS1.p2.2.m2.1.1.cmml" xref="S3.SS1.p2.2.m2.1.1">𝑖</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS1.p2.2.m2.1c">i</annotation><annotation encoding="application/x-llamapun" id="S3.SS1.p2.2.m2.1d">italic_i</annotation></semantics></math>-coordinates that are larger than that
of the splitting plane, then the splitting plane is translated so that
its <math id="S3.SS1.p2.3.m3.1" class="ltx_Math" alttext="i" display="inline"><semantics id="S3.SS1.p2.3.m3.1a"><mi id="S3.SS1.p2.3.m3.1.1" xref="S3.SS1.p2.3.m3.1.1.cmml">i</mi><annotation-xml encoding="MathML-Content" id="S3.SS1.p2.3.m3.1b"><ci id="S3.SS1.p2.3.m3.1.1.cmml" xref="S3.SS1.p2.3.m3.1.1">𝑖</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS1.p2.3.m3.1c">i</annotation><annotation encoding="application/x-llamapun" id="S3.SS1.p2.3.m3.1d">italic_i</annotation></semantics></math>th coordinate equals the minimum <math id="S3.SS1.p2.4.m4.1" class="ltx_Math" alttext="i" display="inline"><semantics id="S3.SS1.p2.4.m4.1a"><mi id="S3.SS1.p2.4.m4.1.1" xref="S3.SS1.p2.4.m4.1.1.cmml">i</mi><annotation-xml encoding="MathML-Content" id="S3.SS1.p2.4.m4.1b"><ci id="S3.SS1.p2.4.m4.1.1.cmml" xref="S3.SS1.p2.4.m4.1.1">𝑖</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS1.p2.4.m4.1c">i</annotation><annotation encoding="application/x-llamapun" id="S3.SS1.p2.4.m4.1d">italic_i</annotation></semantics></math>th coordinate among all the
data points. Let this point be <math id="S3.SS1.p2.5.m5.1" class="ltx_Math" alttext="p_{1}" display="inline"><semantics id="S3.SS1.p2.5.m5.1a"><msub id="S3.SS1.p2.5.m5.1.1" xref="S3.SS1.p2.5.m5.1.1.cmml"><mi id="S3.SS1.p2.5.m5.1.1.2" xref="S3.SS1.p2.5.m5.1.1.2.cmml">p</mi><mn id="S3.SS1.p2.5.m5.1.1.3" xref="S3.SS1.p2.5.m5.1.1.3.cmml">1</mn></msub><annotation-xml encoding="MathML-Content" id="S3.SS1.p2.5.m5.1b"><apply id="S3.SS1.p2.5.m5.1.1.cmml" xref="S3.SS1.p2.5.m5.1.1"><csymbol cd="ambiguous" id="S3.SS1.p2.5.m5.1.1.1.cmml" xref="S3.SS1.p2.5.m5.1.1">subscript</csymbol><ci id="S3.SS1.p2.5.m5.1.1.2.cmml" xref="S3.SS1.p2.5.m5.1.1.2">𝑝</ci><cn type="integer" id="S3.SS1.p2.5.m5.1.1.3.cmml" xref="S3.SS1.p2.5.m5.1.1.3">1</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS1.p2.5.m5.1c">p_{1}</annotation><annotation encoding="application/x-llamapun" id="S3.SS1.p2.5.m5.1d">italic_p start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT</annotation></semantics></math>. Then the points are partitioned
with <math id="S3.SS1.p2.6.m6.1" class="ltx_Math" alttext="p_{1}" display="inline"><semantics id="S3.SS1.p2.6.m6.1a"><msub id="S3.SS1.p2.6.m6.1.1" xref="S3.SS1.p2.6.m6.1.1.cmml"><mi id="S3.SS1.p2.6.m6.1.1.2" xref="S3.SS1.p2.6.m6.1.1.2.cmml">p</mi><mn id="S3.SS1.p2.6.m6.1.1.3" xref="S3.SS1.p2.6.m6.1.1.3.cmml">1</mn></msub><annotation-xml encoding="MathML-Content" id="S3.SS1.p2.6.m6.1b"><apply id="S3.SS1.p2.6.m6.1.1.cmml" xref="S3.SS1.p2.6.m6.1.1"><csymbol cd="ambiguous" id="S3.SS1.p2.6.m6.1.1.1.cmml" xref="S3.SS1.p2.6.m6.1.1">subscript</csymbol><ci id="S3.SS1.p2.6.m6.1.1.2.cmml" xref="S3.SS1.p2.6.m6.1.1.2">𝑝</ci><cn type="integer" id="S3.SS1.p2.6.m6.1.1.3.cmml" xref="S3.SS1.p2.6.m6.1.1.3">1</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS1.p2.6.m6.1c">p_{1}</annotation><annotation encoding="application/x-llamapun" id="S3.SS1.p2.6.m6.1d">italic_p start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT</annotation></semantics></math> in one part of the partition, and all the other data points
in the other part. A symmetrical rule is applied if the points all have
<math id="S3.SS1.p2.7.m7.1" class="ltx_Math" alttext="i" display="inline"><semantics id="S3.SS1.p2.7.m7.1a"><mi id="S3.SS1.p2.7.m7.1.1" xref="S3.SS1.p2.7.m7.1.1.cmml">i</mi><annotation-xml encoding="MathML-Content" id="S3.SS1.p2.7.m7.1b"><ci id="S3.SS1.p2.7.m7.1.1.cmml" xref="S3.SS1.p2.7.m7.1.1">𝑖</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS1.p2.7.m7.1c">i</annotation><annotation encoding="application/x-llamapun" id="S3.SS1.p2.7.m7.1d">italic_i</annotation></semantics></math>th coordinates smaller than the splitting plane.</p>
</div>
<div id="S3.SS1.p3" class="ltx_para">
<p id="S3.SS1.p3.2" class="ltx_p">This method cannot result in any trivial splits, implying that the
resulting tree has size <math id="S3.SS1.p3.1.m1.1" class="ltx_Math" alttext="O(n)" display="inline"><semantics id="S3.SS1.p3.1.m1.1a"><mrow id="S3.SS1.p3.1.m1.1.2" xref="S3.SS1.p3.1.m1.1.2.cmml"><mi id="S3.SS1.p3.1.m1.1.2.2" xref="S3.SS1.p3.1.m1.1.2.2.cmml">O</mi><mo id="S3.SS1.p3.1.m1.1.2.1" xref="S3.SS1.p3.1.m1.1.2.1.cmml">⁢</mo><mrow id="S3.SS1.p3.1.m1.1.2.3.2" xref="S3.SS1.p3.1.m1.1.2.cmml"><mo stretchy="false" id="S3.SS1.p3.1.m1.1.2.3.2.1" xref="S3.SS1.p3.1.m1.1.2.cmml">(</mo><mi id="S3.SS1.p3.1.m1.1.1" xref="S3.SS1.p3.1.m1.1.1.cmml">n</mi><mo stretchy="false" id="S3.SS1.p3.1.m1.1.2.3.2.2" xref="S3.SS1.p3.1.m1.1.2.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S3.SS1.p3.1.m1.1b"><apply id="S3.SS1.p3.1.m1.1.2.cmml" xref="S3.SS1.p3.1.m1.1.2"><times id="S3.SS1.p3.1.m1.1.2.1.cmml" xref="S3.SS1.p3.1.m1.1.2.1"></times><ci id="S3.SS1.p3.1.m1.1.2.2.cmml" xref="S3.SS1.p3.1.m1.1.2.2">𝑂</ci><ci id="S3.SS1.p3.1.m1.1.1.cmml" xref="S3.SS1.p3.1.m1.1.1">𝑛</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS1.p3.1.m1.1c">O(n)</annotation><annotation encoding="application/x-llamapun" id="S3.SS1.p3.1.m1.1d">italic_O ( italic_n )</annotation></semantics></math>. Thus it avoids the problem of large
trees, which the midpoint splitting method is susceptible to. Because
there is no guarantee that the point partition is balanced, the
depth of the resulting tree may exceed <math id="S3.SS1.p3.2.m2.1" class="ltx_Math" alttext="O(\log n)" display="inline"><semantics id="S3.SS1.p3.2.m2.1a"><mrow id="S3.SS1.p3.2.m2.1.1" xref="S3.SS1.p3.2.m2.1.1.cmml"><mi id="S3.SS1.p3.2.m2.1.1.3" xref="S3.SS1.p3.2.m2.1.1.3.cmml">O</mi><mo id="S3.SS1.p3.2.m2.1.1.2" xref="S3.SS1.p3.2.m2.1.1.2.cmml">⁢</mo><mrow id="S3.SS1.p3.2.m2.1.1.1.1" xref="S3.SS1.p3.2.m2.1.1.1.1.1.cmml"><mo stretchy="false" id="S3.SS1.p3.2.m2.1.1.1.1.2" xref="S3.SS1.p3.2.m2.1.1.1.1.1.cmml">(</mo><mrow id="S3.SS1.p3.2.m2.1.1.1.1.1" xref="S3.SS1.p3.2.m2.1.1.1.1.1.cmml"><mi id="S3.SS1.p3.2.m2.1.1.1.1.1.1" xref="S3.SS1.p3.2.m2.1.1.1.1.1.1.cmml">log</mi><mo lspace="0.167em" id="S3.SS1.p3.2.m2.1.1.1.1.1a" xref="S3.SS1.p3.2.m2.1.1.1.1.1.cmml">⁡</mo><mi id="S3.SS1.p3.2.m2.1.1.1.1.1.2" xref="S3.SS1.p3.2.m2.1.1.1.1.1.2.cmml">n</mi></mrow><mo stretchy="false" id="S3.SS1.p3.2.m2.1.1.1.1.3" xref="S3.SS1.p3.2.m2.1.1.1.1.1.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S3.SS1.p3.2.m2.1b"><apply id="S3.SS1.p3.2.m2.1.1.cmml" xref="S3.SS1.p3.2.m2.1.1"><times id="S3.SS1.p3.2.m2.1.1.2.cmml" xref="S3.SS1.p3.2.m2.1.1.2"></times><ci id="S3.SS1.p3.2.m2.1.1.3.cmml" xref="S3.SS1.p3.2.m2.1.1.3">𝑂</ci><apply id="S3.SS1.p3.2.m2.1.1.1.1.1.cmml" xref="S3.SS1.p3.2.m2.1.1.1.1"><log id="S3.SS1.p3.2.m2.1.1.1.1.1.1.cmml" xref="S3.SS1.p3.2.m2.1.1.1.1.1.1"></log><ci id="S3.SS1.p3.2.m2.1.1.1.1.1.2.cmml" xref="S3.SS1.p3.2.m2.1.1.1.1.1.2">𝑛</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS1.p3.2.m2.1c">O(\log n)</annotation><annotation encoding="application/x-llamapun" id="S3.SS1.p3.2.m2.1d">italic_O ( roman_log italic_n )</annotation></semantics></math>. However, based on
our empirical observations, the height of this tree rarely exceeds the
height of the standard kd-tree by more than a small constant factor.</p>
</div>
<div id="S3.SS1.p4" class="ltx_para">
<p id="S3.SS1.p4.4" class="ltx_p">It is possible to generate a cell <math id="S3.SS1.p4.1.m1.1" class="ltx_Math" alttext="C" display="inline"><semantics id="S3.SS1.p4.1.m1.1a"><mi id="S3.SS1.p4.1.m1.1.1" xref="S3.SS1.p4.1.m1.1.1.cmml">C</mi><annotation-xml encoding="MathML-Content" id="S3.SS1.p4.1.m1.1b"><ci id="S3.SS1.p4.1.m1.1.1.cmml" xref="S3.SS1.p4.1.m1.1.1">𝐶</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS1.p4.1.m1.1c">C</annotation><annotation encoding="application/x-llamapun" id="S3.SS1.p4.1.m1.1d">italic_C</annotation></semantics></math> of very high aspect ratio, but it
can be shown that if it does, then <math id="S3.SS1.p4.2.m2.1" class="ltx_Math" alttext="C" display="inline"><semantics id="S3.SS1.p4.2.m2.1a"><mi id="S3.SS1.p4.2.m2.1.1" xref="S3.SS1.p4.2.m2.1.1.cmml">C</mi><annotation-xml encoding="MathML-Content" id="S3.SS1.p4.2.m2.1b"><ci id="S3.SS1.p4.2.m2.1.1.cmml" xref="S3.SS1.p4.2.m2.1.1">𝐶</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS1.p4.2.m2.1c">C</annotation><annotation encoding="application/x-llamapun" id="S3.SS1.p4.2.m2.1d">italic_C</annotation></semantics></math> is necessarily adjacent to a
sibling cell <math id="S3.SS1.p4.3.m3.1" class="ltx_Math" alttext="C^{\prime}" display="inline"><semantics id="S3.SS1.p4.3.m3.1a"><msup id="S3.SS1.p4.3.m3.1.1" xref="S3.SS1.p4.3.m3.1.1.cmml"><mi id="S3.SS1.p4.3.m3.1.1.2" xref="S3.SS1.p4.3.m3.1.1.2.cmml">C</mi><mo id="S3.SS1.p4.3.m3.1.1.3" xref="S3.SS1.p4.3.m3.1.1.3.cmml">′</mo></msup><annotation-xml encoding="MathML-Content" id="S3.SS1.p4.3.m3.1b"><apply id="S3.SS1.p4.3.m3.1.1.cmml" xref="S3.SS1.p4.3.m3.1.1"><csymbol cd="ambiguous" id="S3.SS1.p4.3.m3.1.1.1.cmml" xref="S3.SS1.p4.3.m3.1.1">superscript</csymbol><ci id="S3.SS1.p4.3.m3.1.1.2.cmml" xref="S3.SS1.p4.3.m3.1.1.2">𝐶</ci><ci id="S3.SS1.p4.3.m3.1.1.3.cmml" xref="S3.SS1.p4.3.m3.1.1.3">′</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS1.p4.3.m3.1c">C^{\prime}</annotation><annotation encoding="application/x-llamapun" id="S3.SS1.p4.3.m3.1d">italic_C start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT</annotation></semantics></math> that is fat along the same dimension that <math id="S3.SS1.p4.4.m4.1" class="ltx_Math" alttext="C" display="inline"><semantics id="S3.SS1.p4.4.m4.1a"><mi id="S3.SS1.p4.4.m4.1.1" xref="S3.SS1.p4.4.m4.1.1.cmml">C</mi><annotation-xml encoding="MathML-Content" id="S3.SS1.p4.4.m4.1b"><ci id="S3.SS1.p4.4.m4.1.1.cmml" xref="S3.SS1.p4.4.m4.1.1">𝐶</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS1.p4.4.m4.1c">C</annotation><annotation encoding="application/x-llamapun" id="S3.SS1.p4.4.m4.1d">italic_C</annotation></semantics></math> is
skinny. As a result, it is not possible to generate arbitrarily long
squences of skinny cells, as the standard splitting method could.</p>
</div>
<div id="S3.SS1.p5" class="ltx_para">
<p id="S3.SS1.p5.3" class="ltx_p">The sliding midpoint method can be implemented with little more effort
than the standard kd-tree splitting method. But, because the depth of
the tree is not necessarily <math id="S3.SS1.p5.1.m1.1" class="ltx_Math" alttext="O(\log n)" display="inline"><semantics id="S3.SS1.p5.1.m1.1a"><mrow id="S3.SS1.p5.1.m1.1.1" xref="S3.SS1.p5.1.m1.1.1.cmml"><mi id="S3.SS1.p5.1.m1.1.1.3" xref="S3.SS1.p5.1.m1.1.1.3.cmml">O</mi><mo id="S3.SS1.p5.1.m1.1.1.2" xref="S3.SS1.p5.1.m1.1.1.2.cmml">⁢</mo><mrow id="S3.SS1.p5.1.m1.1.1.1.1" xref="S3.SS1.p5.1.m1.1.1.1.1.1.cmml"><mo stretchy="false" id="S3.SS1.p5.1.m1.1.1.1.1.2" xref="S3.SS1.p5.1.m1.1.1.1.1.1.cmml">(</mo><mrow id="S3.SS1.p5.1.m1.1.1.1.1.1" xref="S3.SS1.p5.1.m1.1.1.1.1.1.cmml"><mi id="S3.SS1.p5.1.m1.1.1.1.1.1.1" xref="S3.SS1.p5.1.m1.1.1.1.1.1.1.cmml">log</mi><mo lspace="0.167em" id="S3.SS1.p5.1.m1.1.1.1.1.1a" xref="S3.SS1.p5.1.m1.1.1.1.1.1.cmml">⁡</mo><mi id="S3.SS1.p5.1.m1.1.1.1.1.1.2" xref="S3.SS1.p5.1.m1.1.1.1.1.1.2.cmml">n</mi></mrow><mo stretchy="false" id="S3.SS1.p5.1.m1.1.1.1.1.3" xref="S3.SS1.p5.1.m1.1.1.1.1.1.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S3.SS1.p5.1.m1.1b"><apply id="S3.SS1.p5.1.m1.1.1.cmml" xref="S3.SS1.p5.1.m1.1.1"><times id="S3.SS1.p5.1.m1.1.1.2.cmml" xref="S3.SS1.p5.1.m1.1.1.2"></times><ci id="S3.SS1.p5.1.m1.1.1.3.cmml" xref="S3.SS1.p5.1.m1.1.1.3">𝑂</ci><apply id="S3.SS1.p5.1.m1.1.1.1.1.1.cmml" xref="S3.SS1.p5.1.m1.1.1.1.1"><log id="S3.SS1.p5.1.m1.1.1.1.1.1.1.cmml" xref="S3.SS1.p5.1.m1.1.1.1.1.1.1"></log><ci id="S3.SS1.p5.1.m1.1.1.1.1.1.2.cmml" xref="S3.SS1.p5.1.m1.1.1.1.1.1.2">𝑛</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS1.p5.1.m1.1c">O(\log n)</annotation><annotation encoding="application/x-llamapun" id="S3.SS1.p5.1.m1.1d">italic_O ( roman_log italic_n )</annotation></semantics></math>, the <math id="S3.SS1.p5.2.m2.1" class="ltx_Math" alttext="O(n\log n)" display="inline"><semantics id="S3.SS1.p5.2.m2.1a"><mrow id="S3.SS1.p5.2.m2.1.1" xref="S3.SS1.p5.2.m2.1.1.cmml"><mi id="S3.SS1.p5.2.m2.1.1.3" xref="S3.SS1.p5.2.m2.1.1.3.cmml">O</mi><mo id="S3.SS1.p5.2.m2.1.1.2" xref="S3.SS1.p5.2.m2.1.1.2.cmml">⁢</mo><mrow id="S3.SS1.p5.2.m2.1.1.1.1" xref="S3.SS1.p5.2.m2.1.1.1.1.1.cmml"><mo stretchy="false" id="S3.SS1.p5.2.m2.1.1.1.1.2" xref="S3.SS1.p5.2.m2.1.1.1.1.1.cmml">(</mo><mrow id="S3.SS1.p5.2.m2.1.1.1.1.1" xref="S3.SS1.p5.2.m2.1.1.1.1.1.cmml"><mi id="S3.SS1.p5.2.m2.1.1.1.1.1.2" xref="S3.SS1.p5.2.m2.1.1.1.1.1.2.cmml">n</mi><mo lspace="0.167em" id="S3.SS1.p5.2.m2.1.1.1.1.1.1" xref="S3.SS1.p5.2.m2.1.1.1.1.1.1.cmml">⁢</mo><mrow id="S3.SS1.p5.2.m2.1.1.1.1.1.3" xref="S3.SS1.p5.2.m2.1.1.1.1.1.3.cmml"><mi id="S3.SS1.p5.2.m2.1.1.1.1.1.3.1" xref="S3.SS1.p5.2.m2.1.1.1.1.1.3.1.cmml">log</mi><mo lspace="0.167em" id="S3.SS1.p5.2.m2.1.1.1.1.1.3a" xref="S3.SS1.p5.2.m2.1.1.1.1.1.3.cmml">⁡</mo><mi id="S3.SS1.p5.2.m2.1.1.1.1.1.3.2" xref="S3.SS1.p5.2.m2.1.1.1.1.1.3.2.cmml">n</mi></mrow></mrow><mo stretchy="false" id="S3.SS1.p5.2.m2.1.1.1.1.3" xref="S3.SS1.p5.2.m2.1.1.1.1.1.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S3.SS1.p5.2.m2.1b"><apply id="S3.SS1.p5.2.m2.1.1.cmml" xref="S3.SS1.p5.2.m2.1.1"><times id="S3.SS1.p5.2.m2.1.1.2.cmml" xref="S3.SS1.p5.2.m2.1.1.2"></times><ci id="S3.SS1.p5.2.m2.1.1.3.cmml" xref="S3.SS1.p5.2.m2.1.1.3">𝑂</ci><apply id="S3.SS1.p5.2.m2.1.1.1.1.1.cmml" xref="S3.SS1.p5.2.m2.1.1.1.1"><times id="S3.SS1.p5.2.m2.1.1.1.1.1.1.cmml" xref="S3.SS1.p5.2.m2.1.1.1.1.1.1"></times><ci id="S3.SS1.p5.2.m2.1.1.1.1.1.2.cmml" xref="S3.SS1.p5.2.m2.1.1.1.1.1.2">𝑛</ci><apply id="S3.SS1.p5.2.m2.1.1.1.1.1.3.cmml" xref="S3.SS1.p5.2.m2.1.1.1.1.1.3"><log id="S3.SS1.p5.2.m2.1.1.1.1.1.3.1.cmml" xref="S3.SS1.p5.2.m2.1.1.1.1.1.3.1"></log><ci id="S3.SS1.p5.2.m2.1.1.1.1.1.3.2.cmml" xref="S3.SS1.p5.2.m2.1.1.1.1.1.3.2">𝑛</ci></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS1.p5.2.m2.1c">O(n\log n)</annotation><annotation encoding="application/x-llamapun" id="S3.SS1.p5.2.m2.1d">italic_O ( italic_n roman_log italic_n )</annotation></semantics></math> construction
time bound does not necessarily hold. There are more complex algorithms
for constructing the tree that run in <math id="S3.SS1.p5.3.m3.1" class="ltx_Math" alttext="O(n\log n)" display="inline"><semantics id="S3.SS1.p5.3.m3.1a"><mrow id="S3.SS1.p5.3.m3.1.1" xref="S3.SS1.p5.3.m3.1.1.cmml"><mi id="S3.SS1.p5.3.m3.1.1.3" xref="S3.SS1.p5.3.m3.1.1.3.cmml">O</mi><mo id="S3.SS1.p5.3.m3.1.1.2" xref="S3.SS1.p5.3.m3.1.1.2.cmml">⁢</mo><mrow id="S3.SS1.p5.3.m3.1.1.1.1" xref="S3.SS1.p5.3.m3.1.1.1.1.1.cmml"><mo stretchy="false" id="S3.SS1.p5.3.m3.1.1.1.1.2" xref="S3.SS1.p5.3.m3.1.1.1.1.1.cmml">(</mo><mrow id="S3.SS1.p5.3.m3.1.1.1.1.1" xref="S3.SS1.p5.3.m3.1.1.1.1.1.cmml"><mi id="S3.SS1.p5.3.m3.1.1.1.1.1.2" xref="S3.SS1.p5.3.m3.1.1.1.1.1.2.cmml">n</mi><mo lspace="0.167em" id="S3.SS1.p5.3.m3.1.1.1.1.1.1" xref="S3.SS1.p5.3.m3.1.1.1.1.1.1.cmml">⁢</mo><mrow id="S3.SS1.p5.3.m3.1.1.1.1.1.3" xref="S3.SS1.p5.3.m3.1.1.1.1.1.3.cmml"><mi id="S3.SS1.p5.3.m3.1.1.1.1.1.3.1" xref="S3.SS1.p5.3.m3.1.1.1.1.1.3.1.cmml">log</mi><mo lspace="0.167em" id="S3.SS1.p5.3.m3.1.1.1.1.1.3a" xref="S3.SS1.p5.3.m3.1.1.1.1.1.3.cmml">⁡</mo><mi id="S3.SS1.p5.3.m3.1.1.1.1.1.3.2" xref="S3.SS1.p5.3.m3.1.1.1.1.1.3.2.cmml">n</mi></mrow></mrow><mo stretchy="false" id="S3.SS1.p5.3.m3.1.1.1.1.3" xref="S3.SS1.p5.3.m3.1.1.1.1.1.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S3.SS1.p5.3.m3.1b"><apply id="S3.SS1.p5.3.m3.1.1.cmml" xref="S3.SS1.p5.3.m3.1.1"><times id="S3.SS1.p5.3.m3.1.1.2.cmml" xref="S3.SS1.p5.3.m3.1.1.2"></times><ci id="S3.SS1.p5.3.m3.1.1.3.cmml" xref="S3.SS1.p5.3.m3.1.1.3">𝑂</ci><apply id="S3.SS1.p5.3.m3.1.1.1.1.1.cmml" xref="S3.SS1.p5.3.m3.1.1.1.1"><times id="S3.SS1.p5.3.m3.1.1.1.1.1.1.cmml" xref="S3.SS1.p5.3.m3.1.1.1.1.1.1"></times><ci id="S3.SS1.p5.3.m3.1.1.1.1.1.2.cmml" xref="S3.SS1.p5.3.m3.1.1.1.1.1.2">𝑛</ci><apply id="S3.SS1.p5.3.m3.1.1.1.1.1.3.cmml" xref="S3.SS1.p5.3.m3.1.1.1.1.1.3"><log id="S3.SS1.p5.3.m3.1.1.1.1.1.3.1.cmml" xref="S3.SS1.p5.3.m3.1.1.1.1.1.3.1"></log><ci id="S3.SS1.p5.3.m3.1.1.1.1.1.3.2.cmml" xref="S3.SS1.p5.3.m3.1.1.1.1.1.3.2">𝑛</ci></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS1.p5.3.m3.1c">O(n\log n)</annotation><annotation encoding="application/x-llamapun" id="S3.SS1.p5.3.m3.1d">italic_O ( italic_n roman_log italic_n )</annotation></semantics></math> time
<cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib3" title="" class="ltx_ref">3</a>]</cite>. However, in spite of these shortcomings, we will
see that the sliding-midpoint method, can perform quite well for highly
clustered data sets.</p>
</div>
</section>
<section id="S3.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">3.2 </span>Minimum-Ambiguity</h3>

<div id="S3.SS2.p1" class="ltx_para">
<p id="S3.SS2.p1.1" class="ltx_p">All of the splitting methods described so far are based solely on
the data points. This may be quite reasonable in applications where
data points and query points come from the same distribution. However
this is not always the case. (For example, a common use of nearest
neighbor searching is in iterative clustering algorithms, such as the
<span id="S3.SS2.p1.1.1" class="ltx_text ltx_font_italic">k-means algorithm</span> <cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib20" title="" class="ltx_ref">20</a>, <a href="#bib.bib22" title="" class="ltx_ref">22</a>, <a href="#bib.bib29" title="" class="ltx_ref">29</a>]</cite>.
Depending on the starting conditions of the algorithm, the data points
and query points may be quite different from one another.) If the two
distributions are different, then it is reasonable that preprocessing
should be informed of the expected distribution of the query points, as
well as the data points. One way to do this is to provide the
preprocessing phase with the data points and a collection of sample
query points, called <span id="S3.SS2.p1.1.2" class="ltx_text ltx_font_italic">training points</span>. The goal is to compute a
data structure which is efficient, assuming that the query distribution
is well-represented by the training points. The idea of presenting
a training set of query points is not new. For example, Clarkson
<cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib12" title="" class="ltx_ref">12</a>]</cite> described a nearest neighbor algorithm that uses
this concept.</p>
</div>
<div id="S3.SS2.p2" class="ltx_para">
<p id="S3.SS2.p2.12" class="ltx_p">The <span id="S3.SS2.p2.12.1" class="ltx_text ltx_font_italic">minimum-ambiguity splitting method</span> is given a set <math id="S3.SS2.p2.1.m1.1" class="ltx_Math" alttext="S" display="inline"><semantics id="S3.SS2.p2.1.m1.1a"><mi id="S3.SS2.p2.1.m1.1.1" xref="S3.SS2.p2.1.m1.1.1.cmml">S</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p2.1.m1.1b"><ci id="S3.SS2.p2.1.m1.1.1.cmml" xref="S3.SS2.p2.1.m1.1.1">𝑆</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p2.1.m1.1c">S</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p2.1.m1.1d">italic_S</annotation></semantics></math> of data
points and a training set <math id="S3.SS2.p2.2.m2.1" class="ltx_Math" alttext="T" display="inline"><semantics id="S3.SS2.p2.2.m2.1a"><mi id="S3.SS2.p2.2.m2.1.1" xref="S3.SS2.p2.2.m2.1.1.cmml">T</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p2.2.m2.1b"><ci id="S3.SS2.p2.2.m2.1.1.cmml" xref="S3.SS2.p2.2.m2.1.1">𝑇</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p2.2.m2.1c">T</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p2.2.m2.1d">italic_T</annotation></semantics></math> of sample query points. For each query
point <math id="S3.SS2.p2.3.m3.1" class="ltx_Math" alttext="q\in T" display="inline"><semantics id="S3.SS2.p2.3.m3.1a"><mrow id="S3.SS2.p2.3.m3.1.1" xref="S3.SS2.p2.3.m3.1.1.cmml"><mi id="S3.SS2.p2.3.m3.1.1.2" xref="S3.SS2.p2.3.m3.1.1.2.cmml">q</mi><mo id="S3.SS2.p2.3.m3.1.1.1" xref="S3.SS2.p2.3.m3.1.1.1.cmml">∈</mo><mi id="S3.SS2.p2.3.m3.1.1.3" xref="S3.SS2.p2.3.m3.1.1.3.cmml">T</mi></mrow><annotation-xml encoding="MathML-Content" id="S3.SS2.p2.3.m3.1b"><apply id="S3.SS2.p2.3.m3.1.1.cmml" xref="S3.SS2.p2.3.m3.1.1"><in id="S3.SS2.p2.3.m3.1.1.1.cmml" xref="S3.SS2.p2.3.m3.1.1.1"></in><ci id="S3.SS2.p2.3.m3.1.1.2.cmml" xref="S3.SS2.p2.3.m3.1.1.2">𝑞</ci><ci id="S3.SS2.p2.3.m3.1.1.3.cmml" xref="S3.SS2.p2.3.m3.1.1.3">𝑇</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p2.3.m3.1c">q\in T</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p2.3.m3.1d">italic_q ∈ italic_T</annotation></semantics></math>, we compute the nearest neighbor of <math id="S3.SS2.p2.4.m4.1" class="ltx_Math" alttext="q" display="inline"><semantics id="S3.SS2.p2.4.m4.1a"><mi id="S3.SS2.p2.4.m4.1.1" xref="S3.SS2.p2.4.m4.1.1.cmml">q</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p2.4.m4.1b"><ci id="S3.SS2.p2.4.m4.1.1.cmml" xref="S3.SS2.p2.4.m4.1.1">𝑞</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p2.4.m4.1c">q</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p2.4.m4.1d">italic_q</annotation></semantics></math> in <math id="S3.SS2.p2.5.m5.1" class="ltx_Math" alttext="S" display="inline"><semantics id="S3.SS2.p2.5.m5.1a"><mi id="S3.SS2.p2.5.m5.1.1" xref="S3.SS2.p2.5.m5.1.1.cmml">S</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p2.5.m5.1b"><ci id="S3.SS2.p2.5.m5.1.1.cmml" xref="S3.SS2.p2.5.m5.1.1">𝑆</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p2.5.m5.1c">S</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p2.5.m5.1d">italic_S</annotation></semantics></math> as part
of the preprocessing. For each such <math id="S3.SS2.p2.6.m6.1" class="ltx_Math" alttext="q" display="inline"><semantics id="S3.SS2.p2.6.m6.1a"><mi id="S3.SS2.p2.6.m6.1.1" xref="S3.SS2.p2.6.m6.1.1.cmml">q</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p2.6.m6.1b"><ci id="S3.SS2.p2.6.m6.1.1.cmml" xref="S3.SS2.p2.6.m6.1.1">𝑞</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p2.6.m6.1c">q</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p2.6.m6.1d">italic_q</annotation></semantics></math>, let <math id="S3.SS2.p2.7.m7.1" class="ltx_Math" alttext="r(q)" display="inline"><semantics id="S3.SS2.p2.7.m7.1a"><mrow id="S3.SS2.p2.7.m7.1.2" xref="S3.SS2.p2.7.m7.1.2.cmml"><mi id="S3.SS2.p2.7.m7.1.2.2" xref="S3.SS2.p2.7.m7.1.2.2.cmml">r</mi><mo id="S3.SS2.p2.7.m7.1.2.1" xref="S3.SS2.p2.7.m7.1.2.1.cmml">⁢</mo><mrow id="S3.SS2.p2.7.m7.1.2.3.2" xref="S3.SS2.p2.7.m7.1.2.cmml"><mo stretchy="false" id="S3.SS2.p2.7.m7.1.2.3.2.1" xref="S3.SS2.p2.7.m7.1.2.cmml">(</mo><mi id="S3.SS2.p2.7.m7.1.1" xref="S3.SS2.p2.7.m7.1.1.cmml">q</mi><mo stretchy="false" id="S3.SS2.p2.7.m7.1.2.3.2.2" xref="S3.SS2.p2.7.m7.1.2.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S3.SS2.p2.7.m7.1b"><apply id="S3.SS2.p2.7.m7.1.2.cmml" xref="S3.SS2.p2.7.m7.1.2"><times id="S3.SS2.p2.7.m7.1.2.1.cmml" xref="S3.SS2.p2.7.m7.1.2.1"></times><ci id="S3.SS2.p2.7.m7.1.2.2.cmml" xref="S3.SS2.p2.7.m7.1.2.2">𝑟</ci><ci id="S3.SS2.p2.7.m7.1.1.cmml" xref="S3.SS2.p2.7.m7.1.1">𝑞</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p2.7.m7.1c">r(q)</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p2.7.m7.1d">italic_r ( italic_q )</annotation></semantics></math> denote the distance
to the nearest point in <math id="S3.SS2.p2.8.m8.1" class="ltx_Math" alttext="S" display="inline"><semantics id="S3.SS2.p2.8.m8.1a"><mi id="S3.SS2.p2.8.m8.1.1" xref="S3.SS2.p2.8.m8.1.1.cmml">S</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p2.8.m8.1b"><ci id="S3.SS2.p2.8.m8.1.1.cmml" xref="S3.SS2.p2.8.m8.1.1">𝑆</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p2.8.m8.1c">S</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p2.8.m8.1d">italic_S</annotation></semantics></math>. Let <math id="S3.SS2.p2.9.m9.1" class="ltx_Math" alttext="b(q)" display="inline"><semantics id="S3.SS2.p2.9.m9.1a"><mrow id="S3.SS2.p2.9.m9.1.2" xref="S3.SS2.p2.9.m9.1.2.cmml"><mi id="S3.SS2.p2.9.m9.1.2.2" xref="S3.SS2.p2.9.m9.1.2.2.cmml">b</mi><mo id="S3.SS2.p2.9.m9.1.2.1" xref="S3.SS2.p2.9.m9.1.2.1.cmml">⁢</mo><mrow id="S3.SS2.p2.9.m9.1.2.3.2" xref="S3.SS2.p2.9.m9.1.2.cmml"><mo stretchy="false" id="S3.SS2.p2.9.m9.1.2.3.2.1" xref="S3.SS2.p2.9.m9.1.2.cmml">(</mo><mi id="S3.SS2.p2.9.m9.1.1" xref="S3.SS2.p2.9.m9.1.1.cmml">q</mi><mo stretchy="false" id="S3.SS2.p2.9.m9.1.2.3.2.2" xref="S3.SS2.p2.9.m9.1.2.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S3.SS2.p2.9.m9.1b"><apply id="S3.SS2.p2.9.m9.1.2.cmml" xref="S3.SS2.p2.9.m9.1.2"><times id="S3.SS2.p2.9.m9.1.2.1.cmml" xref="S3.SS2.p2.9.m9.1.2.1"></times><ci id="S3.SS2.p2.9.m9.1.2.2.cmml" xref="S3.SS2.p2.9.m9.1.2.2">𝑏</ci><ci id="S3.SS2.p2.9.m9.1.1.cmml" xref="S3.SS2.p2.9.m9.1.1">𝑞</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p2.9.m9.1c">b(q)</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p2.9.m9.1d">italic_b ( italic_q )</annotation></semantics></math> denote the <span id="S3.SS2.p2.12.2" class="ltx_text ltx_font_italic">nearest
neighbor ball</span>, that is, the locus of points (in the current metric)
whose distance from <math id="S3.SS2.p2.10.m10.1" class="ltx_Math" alttext="q" display="inline"><semantics id="S3.SS2.p2.10.m10.1a"><mi id="S3.SS2.p2.10.m10.1.1" xref="S3.SS2.p2.10.m10.1.1.cmml">q</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p2.10.m10.1b"><ci id="S3.SS2.p2.10.m10.1.1.cmml" xref="S3.SS2.p2.10.m10.1.1">𝑞</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p2.10.m10.1c">q</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p2.10.m10.1d">italic_q</annotation></semantics></math> is at most <math id="S3.SS2.p2.11.m11.1" class="ltx_Math" alttext="r(q)" display="inline"><semantics id="S3.SS2.p2.11.m11.1a"><mrow id="S3.SS2.p2.11.m11.1.2" xref="S3.SS2.p2.11.m11.1.2.cmml"><mi id="S3.SS2.p2.11.m11.1.2.2" xref="S3.SS2.p2.11.m11.1.2.2.cmml">r</mi><mo id="S3.SS2.p2.11.m11.1.2.1" xref="S3.SS2.p2.11.m11.1.2.1.cmml">⁢</mo><mrow id="S3.SS2.p2.11.m11.1.2.3.2" xref="S3.SS2.p2.11.m11.1.2.cmml"><mo stretchy="false" id="S3.SS2.p2.11.m11.1.2.3.2.1" xref="S3.SS2.p2.11.m11.1.2.cmml">(</mo><mi id="S3.SS2.p2.11.m11.1.1" xref="S3.SS2.p2.11.m11.1.1.cmml">q</mi><mo stretchy="false" id="S3.SS2.p2.11.m11.1.2.3.2.2" xref="S3.SS2.p2.11.m11.1.2.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S3.SS2.p2.11.m11.1b"><apply id="S3.SS2.p2.11.m11.1.2.cmml" xref="S3.SS2.p2.11.m11.1.2"><times id="S3.SS2.p2.11.m11.1.2.1.cmml" xref="S3.SS2.p2.11.m11.1.2.1"></times><ci id="S3.SS2.p2.11.m11.1.2.2.cmml" xref="S3.SS2.p2.11.m11.1.2.2">𝑟</ci><ci id="S3.SS2.p2.11.m11.1.1.cmml" xref="S3.SS2.p2.11.m11.1.1">𝑞</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p2.11.m11.1c">r(q)</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p2.11.m11.1d">italic_r ( italic_q )</annotation></semantics></math>. As observed earlier, the
search algorithm visits every leaf cell that overlaps <math id="S3.SS2.p2.12.m12.1" class="ltx_Math" alttext="b(q)" display="inline"><semantics id="S3.SS2.p2.12.m12.1a"><mrow id="S3.SS2.p2.12.m12.1.2" xref="S3.SS2.p2.12.m12.1.2.cmml"><mi id="S3.SS2.p2.12.m12.1.2.2" xref="S3.SS2.p2.12.m12.1.2.2.cmml">b</mi><mo id="S3.SS2.p2.12.m12.1.2.1" xref="S3.SS2.p2.12.m12.1.2.1.cmml">⁢</mo><mrow id="S3.SS2.p2.12.m12.1.2.3.2" xref="S3.SS2.p2.12.m12.1.2.cmml"><mo stretchy="false" id="S3.SS2.p2.12.m12.1.2.3.2.1" xref="S3.SS2.p2.12.m12.1.2.cmml">(</mo><mi id="S3.SS2.p2.12.m12.1.1" xref="S3.SS2.p2.12.m12.1.1.cmml">q</mi><mo stretchy="false" id="S3.SS2.p2.12.m12.1.2.3.2.2" xref="S3.SS2.p2.12.m12.1.2.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S3.SS2.p2.12.m12.1b"><apply id="S3.SS2.p2.12.m12.1.2.cmml" xref="S3.SS2.p2.12.m12.1.2"><times id="S3.SS2.p2.12.m12.1.2.1.cmml" xref="S3.SS2.p2.12.m12.1.2.1"></times><ci id="S3.SS2.p2.12.m12.1.2.2.cmml" xref="S3.SS2.p2.12.m12.1.2.2">𝑏</ci><ci id="S3.SS2.p2.12.m12.1.1.cmml" xref="S3.SS2.p2.12.m12.1.1">𝑞</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p2.12.m12.1c">b(q)</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p2.12.m12.1d">italic_b ( italic_q )</annotation></semantics></math> (and
it may generally visit a large set of leaves).</p>
</div>
<div id="S3.SS2.p3" class="ltx_para">
<p id="S3.SS2.p3.7" class="ltx_p">Given any kd-tree, let <math id="S3.SS2.p3.1.m1.1" class="ltx_Math" alttext="C(q)" display="inline"><semantics id="S3.SS2.p3.1.m1.1a"><mrow id="S3.SS2.p3.1.m1.1.2" xref="S3.SS2.p3.1.m1.1.2.cmml"><mi id="S3.SS2.p3.1.m1.1.2.2" xref="S3.SS2.p3.1.m1.1.2.2.cmml">C</mi><mo id="S3.SS2.p3.1.m1.1.2.1" xref="S3.SS2.p3.1.m1.1.2.1.cmml">⁢</mo><mrow id="S3.SS2.p3.1.m1.1.2.3.2" xref="S3.SS2.p3.1.m1.1.2.cmml"><mo stretchy="false" id="S3.SS2.p3.1.m1.1.2.3.2.1" xref="S3.SS2.p3.1.m1.1.2.cmml">(</mo><mi id="S3.SS2.p3.1.m1.1.1" xref="S3.SS2.p3.1.m1.1.1.cmml">q</mi><mo stretchy="false" id="S3.SS2.p3.1.m1.1.2.3.2.2" xref="S3.SS2.p3.1.m1.1.2.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S3.SS2.p3.1.m1.1b"><apply id="S3.SS2.p3.1.m1.1.2.cmml" xref="S3.SS2.p3.1.m1.1.2"><times id="S3.SS2.p3.1.m1.1.2.1.cmml" xref="S3.SS2.p3.1.m1.1.2.1"></times><ci id="S3.SS2.p3.1.m1.1.2.2.cmml" xref="S3.SS2.p3.1.m1.1.2.2">𝐶</ci><ci id="S3.SS2.p3.1.m1.1.1.cmml" xref="S3.SS2.p3.1.m1.1.1">𝑞</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p3.1.m1.1c">C(q)</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p3.1.m1.1d">italic_C ( italic_q )</annotation></semantics></math> denote the set of leaf cells of the tree
that overlap <math id="S3.SS2.p3.2.m2.1" class="ltx_Math" alttext="b(q)" display="inline"><semantics id="S3.SS2.p3.2.m2.1a"><mrow id="S3.SS2.p3.2.m2.1.2" xref="S3.SS2.p3.2.m2.1.2.cmml"><mi id="S3.SS2.p3.2.m2.1.2.2" xref="S3.SS2.p3.2.m2.1.2.2.cmml">b</mi><mo id="S3.SS2.p3.2.m2.1.2.1" xref="S3.SS2.p3.2.m2.1.2.1.cmml">⁢</mo><mrow id="S3.SS2.p3.2.m2.1.2.3.2" xref="S3.SS2.p3.2.m2.1.2.cmml"><mo stretchy="false" id="S3.SS2.p3.2.m2.1.2.3.2.1" xref="S3.SS2.p3.2.m2.1.2.cmml">(</mo><mi id="S3.SS2.p3.2.m2.1.1" xref="S3.SS2.p3.2.m2.1.1.cmml">q</mi><mo stretchy="false" id="S3.SS2.p3.2.m2.1.2.3.2.2" xref="S3.SS2.p3.2.m2.1.2.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S3.SS2.p3.2.m2.1b"><apply id="S3.SS2.p3.2.m2.1.2.cmml" xref="S3.SS2.p3.2.m2.1.2"><times id="S3.SS2.p3.2.m2.1.2.1.cmml" xref="S3.SS2.p3.2.m2.1.2.1"></times><ci id="S3.SS2.p3.2.m2.1.2.2.cmml" xref="S3.SS2.p3.2.m2.1.2.2">𝑏</ci><ci id="S3.SS2.p3.2.m2.1.1.cmml" xref="S3.SS2.p3.2.m2.1.1">𝑞</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p3.2.m2.1c">b(q)</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p3.2.m2.1d">italic_b ( italic_q )</annotation></semantics></math>. This suggests the following optimization problem,
given point sets <math id="S3.SS2.p3.3.m3.1" class="ltx_Math" alttext="S" display="inline"><semantics id="S3.SS2.p3.3.m3.1a"><mi id="S3.SS2.p3.3.m3.1.1" xref="S3.SS2.p3.3.m3.1.1.cmml">S</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p3.3.m3.1b"><ci id="S3.SS2.p3.3.m3.1.1.cmml" xref="S3.SS2.p3.3.m3.1.1">𝑆</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p3.3.m3.1c">S</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p3.3.m3.1d">italic_S</annotation></semantics></math> and <math id="S3.SS2.p3.4.m4.1" class="ltx_Math" alttext="T" display="inline"><semantics id="S3.SS2.p3.4.m4.1a"><mi id="S3.SS2.p3.4.m4.1.1" xref="S3.SS2.p3.4.m4.1.1.cmml">T</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p3.4.m4.1b"><ci id="S3.SS2.p3.4.m4.1.1.cmml" xref="S3.SS2.p3.4.m4.1.1">𝑇</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p3.4.m4.1c">T</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p3.4.m4.1d">italic_T</annotation></semantics></math>, determine a hierarchical subdivision of
<math id="S3.SS2.p3.5.m5.1" class="ltx_Math" alttext="S" display="inline"><semantics id="S3.SS2.p3.5.m5.1a"><mi id="S3.SS2.p3.5.m5.1.1" xref="S3.SS2.p3.5.m5.1.1.cmml">S</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p3.5.m5.1b"><ci id="S3.SS2.p3.5.m5.1.1.cmml" xref="S3.SS2.p3.5.m5.1.1">𝑆</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p3.5.m5.1c">S</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p3.5.m5.1d">italic_S</annotation></semantics></math> of size <math id="S3.SS2.p3.6.m6.1" class="ltx_Math" alttext="O(n)" display="inline"><semantics id="S3.SS2.p3.6.m6.1a"><mrow id="S3.SS2.p3.6.m6.1.2" xref="S3.SS2.p3.6.m6.1.2.cmml"><mi id="S3.SS2.p3.6.m6.1.2.2" xref="S3.SS2.p3.6.m6.1.2.2.cmml">O</mi><mo id="S3.SS2.p3.6.m6.1.2.1" xref="S3.SS2.p3.6.m6.1.2.1.cmml">⁢</mo><mrow id="S3.SS2.p3.6.m6.1.2.3.2" xref="S3.SS2.p3.6.m6.1.2.cmml"><mo stretchy="false" id="S3.SS2.p3.6.m6.1.2.3.2.1" xref="S3.SS2.p3.6.m6.1.2.cmml">(</mo><mi id="S3.SS2.p3.6.m6.1.1" xref="S3.SS2.p3.6.m6.1.1.cmml">n</mi><mo stretchy="false" id="S3.SS2.p3.6.m6.1.2.3.2.2" xref="S3.SS2.p3.6.m6.1.2.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S3.SS2.p3.6.m6.1b"><apply id="S3.SS2.p3.6.m6.1.2.cmml" xref="S3.SS2.p3.6.m6.1.2"><times id="S3.SS2.p3.6.m6.1.2.1.cmml" xref="S3.SS2.p3.6.m6.1.2.1"></times><ci id="S3.SS2.p3.6.m6.1.2.2.cmml" xref="S3.SS2.p3.6.m6.1.2.2">𝑂</ci><ci id="S3.SS2.p3.6.m6.1.1.cmml" xref="S3.SS2.p3.6.m6.1.1">𝑛</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p3.6.m6.1c">O(n)</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p3.6.m6.1d">italic_O ( italic_n )</annotation></semantics></math> such that the <span id="S3.SS2.p3.7.1" class="ltx_text ltx_font_italic">total overlap</span>, <math id="S3.SS2.p3.7.m7.2" class="ltx_Math" alttext="\sum_{q\in T}|C(q)|" display="inline"><semantics id="S3.SS2.p3.7.m7.2a"><mrow id="S3.SS2.p3.7.m7.2.2" xref="S3.SS2.p3.7.m7.2.2.cmml"><msub id="S3.SS2.p3.7.m7.2.2.2" xref="S3.SS2.p3.7.m7.2.2.2.cmml"><mo id="S3.SS2.p3.7.m7.2.2.2.2" xref="S3.SS2.p3.7.m7.2.2.2.2.cmml">∑</mo><mrow id="S3.SS2.p3.7.m7.2.2.2.3" xref="S3.SS2.p3.7.m7.2.2.2.3.cmml"><mi id="S3.SS2.p3.7.m7.2.2.2.3.2" xref="S3.SS2.p3.7.m7.2.2.2.3.2.cmml">q</mi><mo id="S3.SS2.p3.7.m7.2.2.2.3.1" xref="S3.SS2.p3.7.m7.2.2.2.3.1.cmml">∈</mo><mi id="S3.SS2.p3.7.m7.2.2.2.3.3" xref="S3.SS2.p3.7.m7.2.2.2.3.3.cmml">T</mi></mrow></msub><mrow id="S3.SS2.p3.7.m7.2.2.1.1" xref="S3.SS2.p3.7.m7.2.2.1.2.cmml"><mo lspace="0em" stretchy="false" id="S3.SS2.p3.7.m7.2.2.1.1.2" xref="S3.SS2.p3.7.m7.2.2.1.2.1.cmml">|</mo><mrow id="S3.SS2.p3.7.m7.2.2.1.1.1" xref="S3.SS2.p3.7.m7.2.2.1.1.1.cmml"><mi id="S3.SS2.p3.7.m7.2.2.1.1.1.2" xref="S3.SS2.p3.7.m7.2.2.1.1.1.2.cmml">C</mi><mo id="S3.SS2.p3.7.m7.2.2.1.1.1.1" xref="S3.SS2.p3.7.m7.2.2.1.1.1.1.cmml">⁢</mo><mrow id="S3.SS2.p3.7.m7.2.2.1.1.1.3.2" xref="S3.SS2.p3.7.m7.2.2.1.1.1.cmml"><mo stretchy="false" id="S3.SS2.p3.7.m7.2.2.1.1.1.3.2.1" xref="S3.SS2.p3.7.m7.2.2.1.1.1.cmml">(</mo><mi id="S3.SS2.p3.7.m7.1.1" xref="S3.SS2.p3.7.m7.1.1.cmml">q</mi><mo stretchy="false" id="S3.SS2.p3.7.m7.2.2.1.1.1.3.2.2" xref="S3.SS2.p3.7.m7.2.2.1.1.1.cmml">)</mo></mrow></mrow><mo stretchy="false" id="S3.SS2.p3.7.m7.2.2.1.1.3" xref="S3.SS2.p3.7.m7.2.2.1.2.1.cmml">|</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S3.SS2.p3.7.m7.2b"><apply id="S3.SS2.p3.7.m7.2.2.cmml" xref="S3.SS2.p3.7.m7.2.2"><apply id="S3.SS2.p3.7.m7.2.2.2.cmml" xref="S3.SS2.p3.7.m7.2.2.2"><csymbol cd="ambiguous" id="S3.SS2.p3.7.m7.2.2.2.1.cmml" xref="S3.SS2.p3.7.m7.2.2.2">subscript</csymbol><sum id="S3.SS2.p3.7.m7.2.2.2.2.cmml" xref="S3.SS2.p3.7.m7.2.2.2.2"></sum><apply id="S3.SS2.p3.7.m7.2.2.2.3.cmml" xref="S3.SS2.p3.7.m7.2.2.2.3"><in id="S3.SS2.p3.7.m7.2.2.2.3.1.cmml" xref="S3.SS2.p3.7.m7.2.2.2.3.1"></in><ci id="S3.SS2.p3.7.m7.2.2.2.3.2.cmml" xref="S3.SS2.p3.7.m7.2.2.2.3.2">𝑞</ci><ci id="S3.SS2.p3.7.m7.2.2.2.3.3.cmml" xref="S3.SS2.p3.7.m7.2.2.2.3.3">𝑇</ci></apply></apply><apply id="S3.SS2.p3.7.m7.2.2.1.2.cmml" xref="S3.SS2.p3.7.m7.2.2.1.1"><abs id="S3.SS2.p3.7.m7.2.2.1.2.1.cmml" xref="S3.SS2.p3.7.m7.2.2.1.1.2"></abs><apply id="S3.SS2.p3.7.m7.2.2.1.1.1.cmml" xref="S3.SS2.p3.7.m7.2.2.1.1.1"><times id="S3.SS2.p3.7.m7.2.2.1.1.1.1.cmml" xref="S3.SS2.p3.7.m7.2.2.1.1.1.1"></times><ci id="S3.SS2.p3.7.m7.2.2.1.1.1.2.cmml" xref="S3.SS2.p3.7.m7.2.2.1.1.1.2">𝐶</ci><ci id="S3.SS2.p3.7.m7.1.1.cmml" xref="S3.SS2.p3.7.m7.1.1">𝑞</ci></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p3.7.m7.2c">\sum_{q\in T}|C(q)|</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p3.7.m7.2d">∑ start_POSTSUBSCRIPT italic_q ∈ italic_T end_POSTSUBSCRIPT | italic_C ( italic_q ) |</annotation></semantics></math>, is minimized. This is analogous to the packing constraint, but
applied only to the nearest neighbor balls of the training set. We do
not know how to solve this problem optimally, but we devised the
minimum-ambiguity splitting method as a greedy heuristic.</p>
</div>
<div id="S3.SS2.p4" class="ltx_para">
<p id="S3.SS2.p4.18" class="ltx_p">To motivate our method, we introduce a model for nearest neighbor
searching in terms of a pruning process on a bipartite graph. Given a
cell (i.e., a <math id="S3.SS2.p4.1.m1.1" class="ltx_Math" alttext="d" display="inline"><semantics id="S3.SS2.p4.1.m1.1a"><mi id="S3.SS2.p4.1.m1.1.1" xref="S3.SS2.p4.1.m1.1.1.cmml">d</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p4.1.m1.1b"><ci id="S3.SS2.p4.1.m1.1.1.cmml" xref="S3.SS2.p4.1.m1.1.1">𝑑</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p4.1.m1.1c">d</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p4.1.m1.1d">italic_d</annotation></semantics></math>-dimensional rectangle) <math id="S3.SS2.p4.2.m2.1" class="ltx_Math" alttext="C" display="inline"><semantics id="S3.SS2.p4.2.m2.1a"><mi id="S3.SS2.p4.2.m2.1.1" xref="S3.SS2.p4.2.m2.1.1.cmml">C</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p4.2.m2.1b"><ci id="S3.SS2.p4.2.m2.1.1.cmml" xref="S3.SS2.p4.2.m2.1.1">𝐶</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p4.2.m2.1c">C</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p4.2.m2.1d">italic_C</annotation></semantics></math>. Let <math id="S3.SS2.p4.3.m3.1" class="ltx_Math" alttext="S_{C}" display="inline"><semantics id="S3.SS2.p4.3.m3.1a"><msub id="S3.SS2.p4.3.m3.1.1" xref="S3.SS2.p4.3.m3.1.1.cmml"><mi id="S3.SS2.p4.3.m3.1.1.2" xref="S3.SS2.p4.3.m3.1.1.2.cmml">S</mi><mi id="S3.SS2.p4.3.m3.1.1.3" xref="S3.SS2.p4.3.m3.1.1.3.cmml">C</mi></msub><annotation-xml encoding="MathML-Content" id="S3.SS2.p4.3.m3.1b"><apply id="S3.SS2.p4.3.m3.1.1.cmml" xref="S3.SS2.p4.3.m3.1.1"><csymbol cd="ambiguous" id="S3.SS2.p4.3.m3.1.1.1.cmml" xref="S3.SS2.p4.3.m3.1.1">subscript</csymbol><ci id="S3.SS2.p4.3.m3.1.1.2.cmml" xref="S3.SS2.p4.3.m3.1.1.2">𝑆</ci><ci id="S3.SS2.p4.3.m3.1.1.3.cmml" xref="S3.SS2.p4.3.m3.1.1.3">𝐶</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p4.3.m3.1c">S_{C}</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p4.3.m3.1d">italic_S start_POSTSUBSCRIPT italic_C end_POSTSUBSCRIPT</annotation></semantics></math> denote the
subset of data points lying within this cell and let <math id="S3.SS2.p4.4.m4.1" class="ltx_Math" alttext="T_{C}" display="inline"><semantics id="S3.SS2.p4.4.m4.1a"><msub id="S3.SS2.p4.4.m4.1.1" xref="S3.SS2.p4.4.m4.1.1.cmml"><mi id="S3.SS2.p4.4.m4.1.1.2" xref="S3.SS2.p4.4.m4.1.1.2.cmml">T</mi><mi id="S3.SS2.p4.4.m4.1.1.3" xref="S3.SS2.p4.4.m4.1.1.3.cmml">C</mi></msub><annotation-xml encoding="MathML-Content" id="S3.SS2.p4.4.m4.1b"><apply id="S3.SS2.p4.4.m4.1.1.cmml" xref="S3.SS2.p4.4.m4.1.1"><csymbol cd="ambiguous" id="S3.SS2.p4.4.m4.1.1.1.cmml" xref="S3.SS2.p4.4.m4.1.1">subscript</csymbol><ci id="S3.SS2.p4.4.m4.1.1.2.cmml" xref="S3.SS2.p4.4.m4.1.1.2">𝑇</ci><ci id="S3.SS2.p4.4.m4.1.1.3.cmml" xref="S3.SS2.p4.4.m4.1.1.3">𝐶</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p4.4.m4.1c">T_{C}</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p4.4.m4.1d">italic_T start_POSTSUBSCRIPT italic_C end_POSTSUBSCRIPT</annotation></semantics></math> denote the
subset of training points whose such that the nearest neighbor balls
intersects <math id="S3.SS2.p4.5.m5.1" class="ltx_Math" alttext="C" display="inline"><semantics id="S3.SS2.p4.5.m5.1a"><mi id="S3.SS2.p4.5.m5.1.1" xref="S3.SS2.p4.5.m5.1.1.cmml">C</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p4.5.m5.1b"><ci id="S3.SS2.p4.5.m5.1.1.cmml" xref="S3.SS2.p4.5.m5.1.1">𝐶</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p4.5.m5.1c">C</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p4.5.m5.1d">italic_C</annotation></semantics></math>. Define the <span id="S3.SS2.p4.18.1" class="ltx_text ltx_font_italic">candidate graph</span> for <math id="S3.SS2.p4.6.m6.1" class="ltx_Math" alttext="C" display="inline"><semantics id="S3.SS2.p4.6.m6.1a"><mi id="S3.SS2.p4.6.m6.1.1" xref="S3.SS2.p4.6.m6.1.1.cmml">C</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p4.6.m6.1b"><ci id="S3.SS2.p4.6.m6.1.1.cmml" xref="S3.SS2.p4.6.m6.1.1">𝐶</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p4.6.m6.1c">C</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p4.6.m6.1d">italic_C</annotation></semantics></math> to be the
bipartite graph on the vertex set <math id="S3.SS2.p4.7.m7.1" class="ltx_Math" alttext="S\cup T" display="inline"><semantics id="S3.SS2.p4.7.m7.1a"><mrow id="S3.SS2.p4.7.m7.1.1" xref="S3.SS2.p4.7.m7.1.1.cmml"><mi id="S3.SS2.p4.7.m7.1.1.2" xref="S3.SS2.p4.7.m7.1.1.2.cmml">S</mi><mo id="S3.SS2.p4.7.m7.1.1.1" xref="S3.SS2.p4.7.m7.1.1.1.cmml">∪</mo><mi id="S3.SS2.p4.7.m7.1.1.3" xref="S3.SS2.p4.7.m7.1.1.3.cmml">T</mi></mrow><annotation-xml encoding="MathML-Content" id="S3.SS2.p4.7.m7.1b"><apply id="S3.SS2.p4.7.m7.1.1.cmml" xref="S3.SS2.p4.7.m7.1.1"><union id="S3.SS2.p4.7.m7.1.1.1.cmml" xref="S3.SS2.p4.7.m7.1.1.1"></union><ci id="S3.SS2.p4.7.m7.1.1.2.cmml" xref="S3.SS2.p4.7.m7.1.1.2">𝑆</ci><ci id="S3.SS2.p4.7.m7.1.1.3.cmml" xref="S3.SS2.p4.7.m7.1.1.3">𝑇</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p4.7.m7.1c">S\cup T</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p4.7.m7.1d">italic_S ∪ italic_T</annotation></semantics></math>, whose edge set is <math id="S3.SS2.p4.8.m8.1" class="ltx_Math" alttext="S_{C}\times T_{C}" display="inline"><semantics id="S3.SS2.p4.8.m8.1a"><mrow id="S3.SS2.p4.8.m8.1.1" xref="S3.SS2.p4.8.m8.1.1.cmml"><msub id="S3.SS2.p4.8.m8.1.1.2" xref="S3.SS2.p4.8.m8.1.1.2.cmml"><mi id="S3.SS2.p4.8.m8.1.1.2.2" xref="S3.SS2.p4.8.m8.1.1.2.2.cmml">S</mi><mi id="S3.SS2.p4.8.m8.1.1.2.3" xref="S3.SS2.p4.8.m8.1.1.2.3.cmml">C</mi></msub><mo lspace="0.222em" rspace="0.222em" id="S3.SS2.p4.8.m8.1.1.1" xref="S3.SS2.p4.8.m8.1.1.1.cmml">×</mo><msub id="S3.SS2.p4.8.m8.1.1.3" xref="S3.SS2.p4.8.m8.1.1.3.cmml"><mi id="S3.SS2.p4.8.m8.1.1.3.2" xref="S3.SS2.p4.8.m8.1.1.3.2.cmml">T</mi><mi id="S3.SS2.p4.8.m8.1.1.3.3" xref="S3.SS2.p4.8.m8.1.1.3.3.cmml">C</mi></msub></mrow><annotation-xml encoding="MathML-Content" id="S3.SS2.p4.8.m8.1b"><apply id="S3.SS2.p4.8.m8.1.1.cmml" xref="S3.SS2.p4.8.m8.1.1"><times id="S3.SS2.p4.8.m8.1.1.1.cmml" xref="S3.SS2.p4.8.m8.1.1.1"></times><apply id="S3.SS2.p4.8.m8.1.1.2.cmml" xref="S3.SS2.p4.8.m8.1.1.2"><csymbol cd="ambiguous" id="S3.SS2.p4.8.m8.1.1.2.1.cmml" xref="S3.SS2.p4.8.m8.1.1.2">subscript</csymbol><ci id="S3.SS2.p4.8.m8.1.1.2.2.cmml" xref="S3.SS2.p4.8.m8.1.1.2.2">𝑆</ci><ci id="S3.SS2.p4.8.m8.1.1.2.3.cmml" xref="S3.SS2.p4.8.m8.1.1.2.3">𝐶</ci></apply><apply id="S3.SS2.p4.8.m8.1.1.3.cmml" xref="S3.SS2.p4.8.m8.1.1.3"><csymbol cd="ambiguous" id="S3.SS2.p4.8.m8.1.1.3.1.cmml" xref="S3.SS2.p4.8.m8.1.1.3">subscript</csymbol><ci id="S3.SS2.p4.8.m8.1.1.3.2.cmml" xref="S3.SS2.p4.8.m8.1.1.3.2">𝑇</ci><ci id="S3.SS2.p4.8.m8.1.1.3.3.cmml" xref="S3.SS2.p4.8.m8.1.1.3.3">𝐶</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p4.8.m8.1c">S_{C}\times T_{C}</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p4.8.m8.1d">italic_S start_POSTSUBSCRIPT italic_C end_POSTSUBSCRIPT × italic_T start_POSTSUBSCRIPT italic_C end_POSTSUBSCRIPT</annotation></semantics></math>. Intuitively, each edge <math id="S3.SS2.p4.9.m9.2" class="ltx_Math" alttext="(p,q)" display="inline"><semantics id="S3.SS2.p4.9.m9.2a"><mrow id="S3.SS2.p4.9.m9.2.3.2" xref="S3.SS2.p4.9.m9.2.3.1.cmml"><mo stretchy="false" id="S3.SS2.p4.9.m9.2.3.2.1" xref="S3.SS2.p4.9.m9.2.3.1.cmml">(</mo><mi id="S3.SS2.p4.9.m9.1.1" xref="S3.SS2.p4.9.m9.1.1.cmml">p</mi><mo id="S3.SS2.p4.9.m9.2.3.2.2" xref="S3.SS2.p4.9.m9.2.3.1.cmml">,</mo><mi id="S3.SS2.p4.9.m9.2.2" xref="S3.SS2.p4.9.m9.2.2.cmml">q</mi><mo stretchy="false" id="S3.SS2.p4.9.m9.2.3.2.3" xref="S3.SS2.p4.9.m9.2.3.1.cmml">)</mo></mrow><annotation-xml encoding="MathML-Content" id="S3.SS2.p4.9.m9.2b"><interval closure="open" id="S3.SS2.p4.9.m9.2.3.1.cmml" xref="S3.SS2.p4.9.m9.2.3.2"><ci id="S3.SS2.p4.9.m9.1.1.cmml" xref="S3.SS2.p4.9.m9.1.1">𝑝</ci><ci id="S3.SS2.p4.9.m9.2.2.cmml" xref="S3.SS2.p4.9.m9.2.2">𝑞</ci></interval></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p4.9.m9.2c">(p,q)</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p4.9.m9.2d">( italic_p , italic_q )</annotation></semantics></math> in this graph reflects the
possibility that data point <math id="S3.SS2.p4.10.m10.1" class="ltx_Math" alttext="p" display="inline"><semantics id="S3.SS2.p4.10.m10.1a"><mi id="S3.SS2.p4.10.m10.1.1" xref="S3.SS2.p4.10.m10.1.1.cmml">p</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p4.10.m10.1b"><ci id="S3.SS2.p4.10.m10.1.1.cmml" xref="S3.SS2.p4.10.m10.1.1">𝑝</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p4.10.m10.1c">p</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p4.10.m10.1d">italic_p</annotation></semantics></math> is a candidate to be the nearest neighbor
of training point <math id="S3.SS2.p4.11.m11.1" class="ltx_Math" alttext="q" display="inline"><semantics id="S3.SS2.p4.11.m11.1a"><mi id="S3.SS2.p4.11.m11.1.1" xref="S3.SS2.p4.11.m11.1.1.cmml">q</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p4.11.m11.1b"><ci id="S3.SS2.p4.11.m11.1.1.cmml" xref="S3.SS2.p4.11.m11.1.1">𝑞</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p4.11.m11.1c">q</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p4.11.m11.1d">italic_q</annotation></semantics></math>. Observe that if a cell <math id="S3.SS2.p4.12.m12.1" class="ltx_Math" alttext="C" display="inline"><semantics id="S3.SS2.p4.12.m12.1a"><mi id="S3.SS2.p4.12.m12.1.1" xref="S3.SS2.p4.12.m12.1.1.cmml">C</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p4.12.m12.1b"><ci id="S3.SS2.p4.12.m12.1.1.cmml" xref="S3.SS2.p4.12.m12.1.1">𝐶</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p4.12.m12.1c">C</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p4.12.m12.1d">italic_C</annotation></semantics></math> intersects <math id="S3.SS2.p4.13.m13.1" class="ltx_Math" alttext="b(q)" display="inline"><semantics id="S3.SS2.p4.13.m13.1a"><mrow id="S3.SS2.p4.13.m13.1.2" xref="S3.SS2.p4.13.m13.1.2.cmml"><mi id="S3.SS2.p4.13.m13.1.2.2" xref="S3.SS2.p4.13.m13.1.2.2.cmml">b</mi><mo id="S3.SS2.p4.13.m13.1.2.1" xref="S3.SS2.p4.13.m13.1.2.1.cmml">⁢</mo><mrow id="S3.SS2.p4.13.m13.1.2.3.2" xref="S3.SS2.p4.13.m13.1.2.cmml"><mo stretchy="false" id="S3.SS2.p4.13.m13.1.2.3.2.1" xref="S3.SS2.p4.13.m13.1.2.cmml">(</mo><mi id="S3.SS2.p4.13.m13.1.1" xref="S3.SS2.p4.13.m13.1.1.cmml">q</mi><mo stretchy="false" id="S3.SS2.p4.13.m13.1.2.3.2.2" xref="S3.SS2.p4.13.m13.1.2.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S3.SS2.p4.13.m13.1b"><apply id="S3.SS2.p4.13.m13.1.2.cmml" xref="S3.SS2.p4.13.m13.1.2"><times id="S3.SS2.p4.13.m13.1.2.1.cmml" xref="S3.SS2.p4.13.m13.1.2.1"></times><ci id="S3.SS2.p4.13.m13.1.2.2.cmml" xref="S3.SS2.p4.13.m13.1.2.2">𝑏</ci><ci id="S3.SS2.p4.13.m13.1.1.cmml" xref="S3.SS2.p4.13.m13.1.1">𝑞</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p4.13.m13.1c">b(q)</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p4.13.m13.1d">italic_b ( italic_q )</annotation></semantics></math> and
contains <math id="S3.SS2.p4.14.m14.1" class="ltx_Math" alttext="k" display="inline"><semantics id="S3.SS2.p4.14.m14.1a"><mi id="S3.SS2.p4.14.m14.1.1" xref="S3.SS2.p4.14.m14.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p4.14.m14.1b"><ci id="S3.SS2.p4.14.m14.1.1.cmml" xref="S3.SS2.p4.14.m14.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p4.14.m14.1c">k</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p4.14.m14.1d">italic_k</annotation></semantics></math> data points, then <math id="S3.SS2.p4.15.m15.1" class="ltx_Math" alttext="q" display="inline"><semantics id="S3.SS2.p4.15.m15.1a"><mi id="S3.SS2.p4.15.m15.1.1" xref="S3.SS2.p4.15.m15.1.1.cmml">q</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p4.15.m15.1b"><ci id="S3.SS2.p4.15.m15.1.1.cmml" xref="S3.SS2.p4.15.m15.1.1">𝑞</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p4.15.m15.1c">q</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p4.15.m15.1d">italic_q</annotation></semantics></math> has degree <math id="S3.SS2.p4.16.m16.1" class="ltx_Math" alttext="k" display="inline"><semantics id="S3.SS2.p4.16.m16.1a"><mi id="S3.SS2.p4.16.m16.1.1" xref="S3.SS2.p4.16.m16.1.1.cmml">k</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p4.16.m16.1b"><ci id="S3.SS2.p4.16.m16.1.1.cmml" xref="S3.SS2.p4.16.m16.1.1">𝑘</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p4.16.m16.1c">k</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p4.16.m16.1d">italic_k</annotation></semantics></math> in the candidate graph
for <math id="S3.SS2.p4.17.m17.1" class="ltx_Math" alttext="C" display="inline"><semantics id="S3.SS2.p4.17.m17.1a"><mi id="S3.SS2.p4.17.m17.1.1" xref="S3.SS2.p4.17.m17.1.1.cmml">C</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p4.17.m17.1b"><ci id="S3.SS2.p4.17.m17.1.1.cmml" xref="S3.SS2.p4.17.m17.1.1">𝐶</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p4.17.m17.1c">C</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p4.17.m17.1d">italic_C</annotation></semantics></math>. Since it is our goal to minimize the number of leaf nodes that
overlap <math id="S3.SS2.p4.18.m18.1" class="ltx_Math" alttext="C" display="inline"><semantics id="S3.SS2.p4.18.m18.1a"><mi id="S3.SS2.p4.18.m18.1.1" xref="S3.SS2.p4.18.m18.1.1.cmml">C</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p4.18.m18.1b"><ci id="S3.SS2.p4.18.m18.1.1.cmml" xref="S3.SS2.p4.18.m18.1.1">𝐶</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p4.18.m18.1c">C</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p4.18.m18.1d">italic_C</annotation></semantics></math>, and assuming that each leaf node contains at least one
data point, then a reasonable heuristic for minimizing the number of
overlapping leaf cells is to minimize the average degree of vertices
in the candidate graph. This is equivalent to minimizing the total
number of edges in the graph. This method is similar to techniques
used in the design of linear classifiers based on impurity functions
<cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib9" title="" class="ltx_ref">9</a>]</cite>.</p>
</div>
<div id="S3.SS2.p5" class="ltx_para">
<p id="S3.SS2.p5.15" class="ltx_p">Here is how the minimum-ambiguity method selects the splitting
hyperplane. If <math id="S3.SS2.p5.1.m1.1" class="ltx_Math" alttext="|S_{C}|\leq 1" display="inline"><semantics id="S3.SS2.p5.1.m1.1a"><mrow id="S3.SS2.p5.1.m1.1.1" xref="S3.SS2.p5.1.m1.1.1.cmml"><mrow id="S3.SS2.p5.1.m1.1.1.1.1" xref="S3.SS2.p5.1.m1.1.1.1.2.cmml"><mo stretchy="false" id="S3.SS2.p5.1.m1.1.1.1.1.2" xref="S3.SS2.p5.1.m1.1.1.1.2.1.cmml">|</mo><msub id="S3.SS2.p5.1.m1.1.1.1.1.1" xref="S3.SS2.p5.1.m1.1.1.1.1.1.cmml"><mi id="S3.SS2.p5.1.m1.1.1.1.1.1.2" xref="S3.SS2.p5.1.m1.1.1.1.1.1.2.cmml">S</mi><mi id="S3.SS2.p5.1.m1.1.1.1.1.1.3" xref="S3.SS2.p5.1.m1.1.1.1.1.1.3.cmml">C</mi></msub><mo stretchy="false" id="S3.SS2.p5.1.m1.1.1.1.1.3" xref="S3.SS2.p5.1.m1.1.1.1.2.1.cmml">|</mo></mrow><mo id="S3.SS2.p5.1.m1.1.1.2" xref="S3.SS2.p5.1.m1.1.1.2.cmml">≤</mo><mn id="S3.SS2.p5.1.m1.1.1.3" xref="S3.SS2.p5.1.m1.1.1.3.cmml">1</mn></mrow><annotation-xml encoding="MathML-Content" id="S3.SS2.p5.1.m1.1b"><apply id="S3.SS2.p5.1.m1.1.1.cmml" xref="S3.SS2.p5.1.m1.1.1"><leq id="S3.SS2.p5.1.m1.1.1.2.cmml" xref="S3.SS2.p5.1.m1.1.1.2"></leq><apply id="S3.SS2.p5.1.m1.1.1.1.2.cmml" xref="S3.SS2.p5.1.m1.1.1.1.1"><abs id="S3.SS2.p5.1.m1.1.1.1.2.1.cmml" xref="S3.SS2.p5.1.m1.1.1.1.1.2"></abs><apply id="S3.SS2.p5.1.m1.1.1.1.1.1.cmml" xref="S3.SS2.p5.1.m1.1.1.1.1.1"><csymbol cd="ambiguous" id="S3.SS2.p5.1.m1.1.1.1.1.1.1.cmml" xref="S3.SS2.p5.1.m1.1.1.1.1.1">subscript</csymbol><ci id="S3.SS2.p5.1.m1.1.1.1.1.1.2.cmml" xref="S3.SS2.p5.1.m1.1.1.1.1.1.2">𝑆</ci><ci id="S3.SS2.p5.1.m1.1.1.1.1.1.3.cmml" xref="S3.SS2.p5.1.m1.1.1.1.1.1.3">𝐶</ci></apply></apply><cn type="integer" id="S3.SS2.p5.1.m1.1.1.3.cmml" xref="S3.SS2.p5.1.m1.1.1.3">1</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p5.1.m1.1c">|S_{C}|\leq 1</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p5.1.m1.1d">| italic_S start_POSTSUBSCRIPT italic_C end_POSTSUBSCRIPT | ≤ 1</annotation></semantics></math>, then from our desire to generate a tree
of size <math id="S3.SS2.p5.2.m2.1" class="ltx_Math" alttext="O(n)" display="inline"><semantics id="S3.SS2.p5.2.m2.1a"><mrow id="S3.SS2.p5.2.m2.1.2" xref="S3.SS2.p5.2.m2.1.2.cmml"><mi id="S3.SS2.p5.2.m2.1.2.2" xref="S3.SS2.p5.2.m2.1.2.2.cmml">O</mi><mo id="S3.SS2.p5.2.m2.1.2.1" xref="S3.SS2.p5.2.m2.1.2.1.cmml">⁢</mo><mrow id="S3.SS2.p5.2.m2.1.2.3.2" xref="S3.SS2.p5.2.m2.1.2.cmml"><mo stretchy="false" id="S3.SS2.p5.2.m2.1.2.3.2.1" xref="S3.SS2.p5.2.m2.1.2.cmml">(</mo><mi id="S3.SS2.p5.2.m2.1.1" xref="S3.SS2.p5.2.m2.1.1.cmml">n</mi><mo stretchy="false" id="S3.SS2.p5.2.m2.1.2.3.2.2" xref="S3.SS2.p5.2.m2.1.2.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S3.SS2.p5.2.m2.1b"><apply id="S3.SS2.p5.2.m2.1.2.cmml" xref="S3.SS2.p5.2.m2.1.2"><times id="S3.SS2.p5.2.m2.1.2.1.cmml" xref="S3.SS2.p5.2.m2.1.2.1"></times><ci id="S3.SS2.p5.2.m2.1.2.2.cmml" xref="S3.SS2.p5.2.m2.1.2.2">𝑂</ci><ci id="S3.SS2.p5.2.m2.1.1.cmml" xref="S3.SS2.p5.2.m2.1.1">𝑛</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p5.2.m2.1c">O(n)</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p5.2.m2.1d">italic_O ( italic_n )</annotation></semantics></math>, we will not subdivide this cell any further. Otherwise,
let <math id="S3.SS2.p5.3.m3.1" class="ltx_Math" alttext="H" display="inline"><semantics id="S3.SS2.p5.3.m3.1a"><mi id="S3.SS2.p5.3.m3.1.1" xref="S3.SS2.p5.3.m3.1.1.cmml">H</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p5.3.m3.1b"><ci id="S3.SS2.p5.3.m3.1.1.cmml" xref="S3.SS2.p5.3.m3.1.1">𝐻</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p5.3.m3.1c">H</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p5.3.m3.1d">italic_H</annotation></semantics></math> be some orthogonal hyperplane that cuts <math id="S3.SS2.p5.4.m4.1" class="ltx_Math" alttext="C" display="inline"><semantics id="S3.SS2.p5.4.m4.1a"><mi id="S3.SS2.p5.4.m4.1.1" xref="S3.SS2.p5.4.m4.1.1.cmml">C</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p5.4.m4.1b"><ci id="S3.SS2.p5.4.m4.1.1.cmml" xref="S3.SS2.p5.4.m4.1.1">𝐶</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p5.4.m4.1c">C</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p5.4.m4.1d">italic_C</annotation></semantics></math> into subcells <math id="S3.SS2.p5.5.m5.1" class="ltx_Math" alttext="C_{1}" display="inline"><semantics id="S3.SS2.p5.5.m5.1a"><msub id="S3.SS2.p5.5.m5.1.1" xref="S3.SS2.p5.5.m5.1.1.cmml"><mi id="S3.SS2.p5.5.m5.1.1.2" xref="S3.SS2.p5.5.m5.1.1.2.cmml">C</mi><mn id="S3.SS2.p5.5.m5.1.1.3" xref="S3.SS2.p5.5.m5.1.1.3.cmml">1</mn></msub><annotation-xml encoding="MathML-Content" id="S3.SS2.p5.5.m5.1b"><apply id="S3.SS2.p5.5.m5.1.1.cmml" xref="S3.SS2.p5.5.m5.1.1"><csymbol cd="ambiguous" id="S3.SS2.p5.5.m5.1.1.1.cmml" xref="S3.SS2.p5.5.m5.1.1">subscript</csymbol><ci id="S3.SS2.p5.5.m5.1.1.2.cmml" xref="S3.SS2.p5.5.m5.1.1.2">𝐶</ci><cn type="integer" id="S3.SS2.p5.5.m5.1.1.3.cmml" xref="S3.SS2.p5.5.m5.1.1.3">1</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p5.5.m5.1c">C_{1}</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p5.5.m5.1d">italic_C start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT</annotation></semantics></math>
and <math id="S3.SS2.p5.6.m6.1" class="ltx_Math" alttext="C_{2}" display="inline"><semantics id="S3.SS2.p5.6.m6.1a"><msub id="S3.SS2.p5.6.m6.1.1" xref="S3.SS2.p5.6.m6.1.1.cmml"><mi id="S3.SS2.p5.6.m6.1.1.2" xref="S3.SS2.p5.6.m6.1.1.2.cmml">C</mi><mn id="S3.SS2.p5.6.m6.1.1.3" xref="S3.SS2.p5.6.m6.1.1.3.cmml">2</mn></msub><annotation-xml encoding="MathML-Content" id="S3.SS2.p5.6.m6.1b"><apply id="S3.SS2.p5.6.m6.1.1.cmml" xref="S3.SS2.p5.6.m6.1.1"><csymbol cd="ambiguous" id="S3.SS2.p5.6.m6.1.1.1.cmml" xref="S3.SS2.p5.6.m6.1.1">subscript</csymbol><ci id="S3.SS2.p5.6.m6.1.1.2.cmml" xref="S3.SS2.p5.6.m6.1.1.2">𝐶</ci><cn type="integer" id="S3.SS2.p5.6.m6.1.1.3.cmml" xref="S3.SS2.p5.6.m6.1.1.3">2</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p5.6.m6.1c">C_{2}</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p5.6.m6.1d">italic_C start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT</annotation></semantics></math>. Let <math id="S3.SS2.p5.7.m7.1" class="ltx_Math" alttext="S_{1}" display="inline"><semantics id="S3.SS2.p5.7.m7.1a"><msub id="S3.SS2.p5.7.m7.1.1" xref="S3.SS2.p5.7.m7.1.1.cmml"><mi id="S3.SS2.p5.7.m7.1.1.2" xref="S3.SS2.p5.7.m7.1.1.2.cmml">S</mi><mn id="S3.SS2.p5.7.m7.1.1.3" xref="S3.SS2.p5.7.m7.1.1.3.cmml">1</mn></msub><annotation-xml encoding="MathML-Content" id="S3.SS2.p5.7.m7.1b"><apply id="S3.SS2.p5.7.m7.1.1.cmml" xref="S3.SS2.p5.7.m7.1.1"><csymbol cd="ambiguous" id="S3.SS2.p5.7.m7.1.1.1.cmml" xref="S3.SS2.p5.7.m7.1.1">subscript</csymbol><ci id="S3.SS2.p5.7.m7.1.1.2.cmml" xref="S3.SS2.p5.7.m7.1.1.2">𝑆</ci><cn type="integer" id="S3.SS2.p5.7.m7.1.1.3.cmml" xref="S3.SS2.p5.7.m7.1.1.3">1</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p5.7.m7.1c">S_{1}</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p5.7.m7.1d">italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT</annotation></semantics></math> and <math id="S3.SS2.p5.8.m8.1" class="ltx_Math" alttext="S_{2}" display="inline"><semantics id="S3.SS2.p5.8.m8.1a"><msub id="S3.SS2.p5.8.m8.1.1" xref="S3.SS2.p5.8.m8.1.1.cmml"><mi id="S3.SS2.p5.8.m8.1.1.2" xref="S3.SS2.p5.8.m8.1.1.2.cmml">S</mi><mn id="S3.SS2.p5.8.m8.1.1.3" xref="S3.SS2.p5.8.m8.1.1.3.cmml">2</mn></msub><annotation-xml encoding="MathML-Content" id="S3.SS2.p5.8.m8.1b"><apply id="S3.SS2.p5.8.m8.1.1.cmml" xref="S3.SS2.p5.8.m8.1.1"><csymbol cd="ambiguous" id="S3.SS2.p5.8.m8.1.1.1.cmml" xref="S3.SS2.p5.8.m8.1.1">subscript</csymbol><ci id="S3.SS2.p5.8.m8.1.1.2.cmml" xref="S3.SS2.p5.8.m8.1.1.2">𝑆</ci><cn type="integer" id="S3.SS2.p5.8.m8.1.1.3.cmml" xref="S3.SS2.p5.8.m8.1.1.3">2</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p5.8.m8.1c">S_{2}</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p5.8.m8.1d">italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT</annotation></semantics></math> be the resulting partition of data
points into these respective subcells, and let <math id="S3.SS2.p5.9.m9.1" class="ltx_Math" alttext="T_{1}" display="inline"><semantics id="S3.SS2.p5.9.m9.1a"><msub id="S3.SS2.p5.9.m9.1.1" xref="S3.SS2.p5.9.m9.1.1.cmml"><mi id="S3.SS2.p5.9.m9.1.1.2" xref="S3.SS2.p5.9.m9.1.1.2.cmml">T</mi><mn id="S3.SS2.p5.9.m9.1.1.3" xref="S3.SS2.p5.9.m9.1.1.3.cmml">1</mn></msub><annotation-xml encoding="MathML-Content" id="S3.SS2.p5.9.m9.1b"><apply id="S3.SS2.p5.9.m9.1.1.cmml" xref="S3.SS2.p5.9.m9.1.1"><csymbol cd="ambiguous" id="S3.SS2.p5.9.m9.1.1.1.cmml" xref="S3.SS2.p5.9.m9.1.1">subscript</csymbol><ci id="S3.SS2.p5.9.m9.1.1.2.cmml" xref="S3.SS2.p5.9.m9.1.1.2">𝑇</ci><cn type="integer" id="S3.SS2.p5.9.m9.1.1.3.cmml" xref="S3.SS2.p5.9.m9.1.1.3">1</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p5.9.m9.1c">T_{1}</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p5.9.m9.1d">italic_T start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT</annotation></semantics></math> and <math id="S3.SS2.p5.10.m10.1" class="ltx_Math" alttext="T_{2}" display="inline"><semantics id="S3.SS2.p5.10.m10.1a"><msub id="S3.SS2.p5.10.m10.1.1" xref="S3.SS2.p5.10.m10.1.1.cmml"><mi id="S3.SS2.p5.10.m10.1.1.2" xref="S3.SS2.p5.10.m10.1.1.2.cmml">T</mi><mn id="S3.SS2.p5.10.m10.1.1.3" xref="S3.SS2.p5.10.m10.1.1.3.cmml">2</mn></msub><annotation-xml encoding="MathML-Content" id="S3.SS2.p5.10.m10.1b"><apply id="S3.SS2.p5.10.m10.1.1.cmml" xref="S3.SS2.p5.10.m10.1.1"><csymbol cd="ambiguous" id="S3.SS2.p5.10.m10.1.1.1.cmml" xref="S3.SS2.p5.10.m10.1.1">subscript</csymbol><ci id="S3.SS2.p5.10.m10.1.1.2.cmml" xref="S3.SS2.p5.10.m10.1.1.2">𝑇</ci><cn type="integer" id="S3.SS2.p5.10.m10.1.1.3.cmml" xref="S3.SS2.p5.10.m10.1.1.3">2</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p5.10.m10.1c">T_{2}</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p5.10.m10.1d">italic_T start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT</annotation></semantics></math> denote
the subsets of training points whose nearest neighbor balls intersect
<math id="S3.SS2.p5.11.m11.1" class="ltx_Math" alttext="C_{1}" display="inline"><semantics id="S3.SS2.p5.11.m11.1a"><msub id="S3.SS2.p5.11.m11.1.1" xref="S3.SS2.p5.11.m11.1.1.cmml"><mi id="S3.SS2.p5.11.m11.1.1.2" xref="S3.SS2.p5.11.m11.1.1.2.cmml">C</mi><mn id="S3.SS2.p5.11.m11.1.1.3" xref="S3.SS2.p5.11.m11.1.1.3.cmml">1</mn></msub><annotation-xml encoding="MathML-Content" id="S3.SS2.p5.11.m11.1b"><apply id="S3.SS2.p5.11.m11.1.1.cmml" xref="S3.SS2.p5.11.m11.1.1"><csymbol cd="ambiguous" id="S3.SS2.p5.11.m11.1.1.1.cmml" xref="S3.SS2.p5.11.m11.1.1">subscript</csymbol><ci id="S3.SS2.p5.11.m11.1.1.2.cmml" xref="S3.SS2.p5.11.m11.1.1.2">𝐶</ci><cn type="integer" id="S3.SS2.p5.11.m11.1.1.3.cmml" xref="S3.SS2.p5.11.m11.1.1.3">1</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p5.11.m11.1c">C_{1}</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p5.11.m11.1d">italic_C start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT</annotation></semantics></math> and <math id="S3.SS2.p5.12.m12.1" class="ltx_Math" alttext="C_{2}" display="inline"><semantics id="S3.SS2.p5.12.m12.1a"><msub id="S3.SS2.p5.12.m12.1.1" xref="S3.SS2.p5.12.m12.1.1.cmml"><mi id="S3.SS2.p5.12.m12.1.1.2" xref="S3.SS2.p5.12.m12.1.1.2.cmml">C</mi><mn id="S3.SS2.p5.12.m12.1.1.3" xref="S3.SS2.p5.12.m12.1.1.3.cmml">2</mn></msub><annotation-xml encoding="MathML-Content" id="S3.SS2.p5.12.m12.1b"><apply id="S3.SS2.p5.12.m12.1.1.cmml" xref="S3.SS2.p5.12.m12.1.1"><csymbol cd="ambiguous" id="S3.SS2.p5.12.m12.1.1.1.cmml" xref="S3.SS2.p5.12.m12.1.1">subscript</csymbol><ci id="S3.SS2.p5.12.m12.1.1.2.cmml" xref="S3.SS2.p5.12.m12.1.1.2">𝐶</ci><cn type="integer" id="S3.SS2.p5.12.m12.1.1.3.cmml" xref="S3.SS2.p5.12.m12.1.1.3">2</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p5.12.m12.1c">C_{2}</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p5.12.m12.1d">italic_C start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT</annotation></semantics></math>, respectively. Notice that these subsets are not
necessarily disjoint. We assign a <span id="S3.SS2.p5.15.1" class="ltx_text ltx_font_italic">score</span> to each such hyperplane
<math id="S3.SS2.p5.13.m13.1" class="ltx_Math" alttext="H" display="inline"><semantics id="S3.SS2.p5.13.m13.1a"><mi id="S3.SS2.p5.13.m13.1.1" xref="S3.SS2.p5.13.m13.1.1.cmml">H</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p5.13.m13.1b"><ci id="S3.SS2.p5.13.m13.1.1.cmml" xref="S3.SS2.p5.13.m13.1.1">𝐻</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p5.13.m13.1c">H</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p5.13.m13.1d">italic_H</annotation></semantics></math>, which is equal to the sum of the number of edges in the ambiguity
graphs of <math id="S3.SS2.p5.14.m14.1" class="ltx_Math" alttext="C_{1}" display="inline"><semantics id="S3.SS2.p5.14.m14.1a"><msub id="S3.SS2.p5.14.m14.1.1" xref="S3.SS2.p5.14.m14.1.1.cmml"><mi id="S3.SS2.p5.14.m14.1.1.2" xref="S3.SS2.p5.14.m14.1.1.2.cmml">C</mi><mn id="S3.SS2.p5.14.m14.1.1.3" xref="S3.SS2.p5.14.m14.1.1.3.cmml">1</mn></msub><annotation-xml encoding="MathML-Content" id="S3.SS2.p5.14.m14.1b"><apply id="S3.SS2.p5.14.m14.1.1.cmml" xref="S3.SS2.p5.14.m14.1.1"><csymbol cd="ambiguous" id="S3.SS2.p5.14.m14.1.1.1.cmml" xref="S3.SS2.p5.14.m14.1.1">subscript</csymbol><ci id="S3.SS2.p5.14.m14.1.1.2.cmml" xref="S3.SS2.p5.14.m14.1.1.2">𝐶</ci><cn type="integer" id="S3.SS2.p5.14.m14.1.1.3.cmml" xref="S3.SS2.p5.14.m14.1.1.3">1</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p5.14.m14.1c">C_{1}</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p5.14.m14.1d">italic_C start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT</annotation></semantics></math> and <math id="S3.SS2.p5.15.m15.1" class="ltx_Math" alttext="C_{2}" display="inline"><semantics id="S3.SS2.p5.15.m15.1a"><msub id="S3.SS2.p5.15.m15.1.1" xref="S3.SS2.p5.15.m15.1.1.cmml"><mi id="S3.SS2.p5.15.m15.1.1.2" xref="S3.SS2.p5.15.m15.1.1.2.cmml">C</mi><mn id="S3.SS2.p5.15.m15.1.1.3" xref="S3.SS2.p5.15.m15.1.1.3.cmml">2</mn></msub><annotation-xml encoding="MathML-Content" id="S3.SS2.p5.15.m15.1b"><apply id="S3.SS2.p5.15.m15.1.1.cmml" xref="S3.SS2.p5.15.m15.1.1"><csymbol cd="ambiguous" id="S3.SS2.p5.15.m15.1.1.1.cmml" xref="S3.SS2.p5.15.m15.1.1">subscript</csymbol><ci id="S3.SS2.p5.15.m15.1.1.2.cmml" xref="S3.SS2.p5.15.m15.1.1.2">𝐶</ci><cn type="integer" id="S3.SS2.p5.15.m15.1.1.3.cmml" xref="S3.SS2.p5.15.m15.1.1.3">2</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p5.15.m15.1c">C_{2}</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p5.15.m15.1d">italic_C start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT</annotation></semantics></math>. In particular,</p>
<table id="S3.Ex2" class="ltx_equation ltx_eqn_table">

<tbody><tr class="ltx_equation ltx_eqn_row ltx_align_baseline">
<td class="ltx_eqn_cell ltx_eqn_center_padleft"></td>
<td class="ltx_eqn_cell ltx_align_center"><math id="S3.Ex2.m1.2" class="ltx_Math" alttext="\hbox{Score}(H)=|S_{1}|\cdot|T_{1}|+|S_{2}|\cdot|T_{2}|." display="block"><semantics id="S3.Ex2.m1.2a"><mrow id="S3.Ex2.m1.2.2.1" xref="S3.Ex2.m1.2.2.1.1.cmml"><mrow id="S3.Ex2.m1.2.2.1.1" xref="S3.Ex2.m1.2.2.1.1.cmml"><mrow id="S3.Ex2.m1.2.2.1.1.6" xref="S3.Ex2.m1.2.2.1.1.6.cmml"><mtext id="S3.Ex2.m1.2.2.1.1.6.2" xref="S3.Ex2.m1.2.2.1.1.6.2a.cmml">Score</mtext><mo id="S3.Ex2.m1.2.2.1.1.6.1" xref="S3.Ex2.m1.2.2.1.1.6.1.cmml">⁢</mo><mrow id="S3.Ex2.m1.2.2.1.1.6.3.2" xref="S3.Ex2.m1.2.2.1.1.6.cmml"><mo stretchy="false" id="S3.Ex2.m1.2.2.1.1.6.3.2.1" xref="S3.Ex2.m1.2.2.1.1.6.cmml">(</mo><mi id="S3.Ex2.m1.1.1" xref="S3.Ex2.m1.1.1.cmml">H</mi><mo stretchy="false" id="S3.Ex2.m1.2.2.1.1.6.3.2.2" xref="S3.Ex2.m1.2.2.1.1.6.cmml">)</mo></mrow></mrow><mo id="S3.Ex2.m1.2.2.1.1.5" xref="S3.Ex2.m1.2.2.1.1.5.cmml">=</mo><mrow id="S3.Ex2.m1.2.2.1.1.4" xref="S3.Ex2.m1.2.2.1.1.4.cmml"><mrow id="S3.Ex2.m1.2.2.1.1.2.2" xref="S3.Ex2.m1.2.2.1.1.2.2.cmml"><mrow id="S3.Ex2.m1.2.2.1.1.1.1.1.1" xref="S3.Ex2.m1.2.2.1.1.1.1.1.2.cmml"><mo stretchy="false" id="S3.Ex2.m1.2.2.1.1.1.1.1.1.2" xref="S3.Ex2.m1.2.2.1.1.1.1.1.2.1.cmml">|</mo><msub id="S3.Ex2.m1.2.2.1.1.1.1.1.1.1" xref="S3.Ex2.m1.2.2.1.1.1.1.1.1.1.cmml"><mi id="S3.Ex2.m1.2.2.1.1.1.1.1.1.1.2" xref="S3.Ex2.m1.2.2.1.1.1.1.1.1.1.2.cmml">S</mi><mn id="S3.Ex2.m1.2.2.1.1.1.1.1.1.1.3" xref="S3.Ex2.m1.2.2.1.1.1.1.1.1.1.3.cmml">1</mn></msub><mo rspace="0.055em" stretchy="false" id="S3.Ex2.m1.2.2.1.1.1.1.1.1.3" xref="S3.Ex2.m1.2.2.1.1.1.1.1.2.1.cmml">|</mo></mrow><mo rspace="0.222em" id="S3.Ex2.m1.2.2.1.1.2.2.3" xref="S3.Ex2.m1.2.2.1.1.2.2.3.cmml">⋅</mo><mrow id="S3.Ex2.m1.2.2.1.1.2.2.2.1" xref="S3.Ex2.m1.2.2.1.1.2.2.2.2.cmml"><mo stretchy="false" id="S3.Ex2.m1.2.2.1.1.2.2.2.1.2" xref="S3.Ex2.m1.2.2.1.1.2.2.2.2.1.cmml">|</mo><msub id="S3.Ex2.m1.2.2.1.1.2.2.2.1.1" xref="S3.Ex2.m1.2.2.1.1.2.2.2.1.1.cmml"><mi id="S3.Ex2.m1.2.2.1.1.2.2.2.1.1.2" xref="S3.Ex2.m1.2.2.1.1.2.2.2.1.1.2.cmml">T</mi><mn id="S3.Ex2.m1.2.2.1.1.2.2.2.1.1.3" xref="S3.Ex2.m1.2.2.1.1.2.2.2.1.1.3.cmml">1</mn></msub><mo stretchy="false" id="S3.Ex2.m1.2.2.1.1.2.2.2.1.3" xref="S3.Ex2.m1.2.2.1.1.2.2.2.2.1.cmml">|</mo></mrow></mrow><mo id="S3.Ex2.m1.2.2.1.1.4.5" xref="S3.Ex2.m1.2.2.1.1.4.5.cmml">+</mo><mrow id="S3.Ex2.m1.2.2.1.1.4.4" xref="S3.Ex2.m1.2.2.1.1.4.4.cmml"><mrow id="S3.Ex2.m1.2.2.1.1.3.3.1.1" xref="S3.Ex2.m1.2.2.1.1.3.3.1.2.cmml"><mo stretchy="false" id="S3.Ex2.m1.2.2.1.1.3.3.1.1.2" xref="S3.Ex2.m1.2.2.1.1.3.3.1.2.1.cmml">|</mo><msub id="S3.Ex2.m1.2.2.1.1.3.3.1.1.1" xref="S3.Ex2.m1.2.2.1.1.3.3.1.1.1.cmml"><mi id="S3.Ex2.m1.2.2.1.1.3.3.1.1.1.2" xref="S3.Ex2.m1.2.2.1.1.3.3.1.1.1.2.cmml">S</mi><mn id="S3.Ex2.m1.2.2.1.1.3.3.1.1.1.3" xref="S3.Ex2.m1.2.2.1.1.3.3.1.1.1.3.cmml">2</mn></msub><mo rspace="0.055em" stretchy="false" id="S3.Ex2.m1.2.2.1.1.3.3.1.1.3" xref="S3.Ex2.m1.2.2.1.1.3.3.1.2.1.cmml">|</mo></mrow><mo rspace="0.222em" id="S3.Ex2.m1.2.2.1.1.4.4.3" xref="S3.Ex2.m1.2.2.1.1.4.4.3.cmml">⋅</mo><mrow id="S3.Ex2.m1.2.2.1.1.4.4.2.1" xref="S3.Ex2.m1.2.2.1.1.4.4.2.2.cmml"><mo stretchy="false" id="S3.Ex2.m1.2.2.1.1.4.4.2.1.2" xref="S3.Ex2.m1.2.2.1.1.4.4.2.2.1.cmml">|</mo><msub id="S3.Ex2.m1.2.2.1.1.4.4.2.1.1" xref="S3.Ex2.m1.2.2.1.1.4.4.2.1.1.cmml"><mi id="S3.Ex2.m1.2.2.1.1.4.4.2.1.1.2" xref="S3.Ex2.m1.2.2.1.1.4.4.2.1.1.2.cmml">T</mi><mn id="S3.Ex2.m1.2.2.1.1.4.4.2.1.1.3" xref="S3.Ex2.m1.2.2.1.1.4.4.2.1.1.3.cmml">2</mn></msub><mo stretchy="false" id="S3.Ex2.m1.2.2.1.1.4.4.2.1.3" xref="S3.Ex2.m1.2.2.1.1.4.4.2.2.1.cmml">|</mo></mrow></mrow></mrow></mrow><mo lspace="0em" id="S3.Ex2.m1.2.2.1.2" xref="S3.Ex2.m1.2.2.1.1.cmml">.</mo></mrow><annotation-xml encoding="MathML-Content" id="S3.Ex2.m1.2b"><apply id="S3.Ex2.m1.2.2.1.1.cmml" xref="S3.Ex2.m1.2.2.1"><eq id="S3.Ex2.m1.2.2.1.1.5.cmml" xref="S3.Ex2.m1.2.2.1.1.5"></eq><apply id="S3.Ex2.m1.2.2.1.1.6.cmml" xref="S3.Ex2.m1.2.2.1.1.6"><times id="S3.Ex2.m1.2.2.1.1.6.1.cmml" xref="S3.Ex2.m1.2.2.1.1.6.1"></times><ci id="S3.Ex2.m1.2.2.1.1.6.2a.cmml" xref="S3.Ex2.m1.2.2.1.1.6.2"><mtext id="S3.Ex2.m1.2.2.1.1.6.2.cmml" xref="S3.Ex2.m1.2.2.1.1.6.2">Score</mtext></ci><ci id="S3.Ex2.m1.1.1.cmml" xref="S3.Ex2.m1.1.1">𝐻</ci></apply><apply id="S3.Ex2.m1.2.2.1.1.4.cmml" xref="S3.Ex2.m1.2.2.1.1.4"><plus id="S3.Ex2.m1.2.2.1.1.4.5.cmml" xref="S3.Ex2.m1.2.2.1.1.4.5"></plus><apply id="S3.Ex2.m1.2.2.1.1.2.2.cmml" xref="S3.Ex2.m1.2.2.1.1.2.2"><ci id="S3.Ex2.m1.2.2.1.1.2.2.3.cmml" xref="S3.Ex2.m1.2.2.1.1.2.2.3">⋅</ci><apply id="S3.Ex2.m1.2.2.1.1.1.1.1.2.cmml" xref="S3.Ex2.m1.2.2.1.1.1.1.1.1"><abs id="S3.Ex2.m1.2.2.1.1.1.1.1.2.1.cmml" xref="S3.Ex2.m1.2.2.1.1.1.1.1.1.2"></abs><apply id="S3.Ex2.m1.2.2.1.1.1.1.1.1.1.cmml" xref="S3.Ex2.m1.2.2.1.1.1.1.1.1.1"><csymbol cd="ambiguous" id="S3.Ex2.m1.2.2.1.1.1.1.1.1.1.1.cmml" xref="S3.Ex2.m1.2.2.1.1.1.1.1.1.1">subscript</csymbol><ci id="S3.Ex2.m1.2.2.1.1.1.1.1.1.1.2.cmml" xref="S3.Ex2.m1.2.2.1.1.1.1.1.1.1.2">𝑆</ci><cn type="integer" id="S3.Ex2.m1.2.2.1.1.1.1.1.1.1.3.cmml" xref="S3.Ex2.m1.2.2.1.1.1.1.1.1.1.3">1</cn></apply></apply><apply id="S3.Ex2.m1.2.2.1.1.2.2.2.2.cmml" xref="S3.Ex2.m1.2.2.1.1.2.2.2.1"><abs id="S3.Ex2.m1.2.2.1.1.2.2.2.2.1.cmml" xref="S3.Ex2.m1.2.2.1.1.2.2.2.1.2"></abs><apply id="S3.Ex2.m1.2.2.1.1.2.2.2.1.1.cmml" xref="S3.Ex2.m1.2.2.1.1.2.2.2.1.1"><csymbol cd="ambiguous" id="S3.Ex2.m1.2.2.1.1.2.2.2.1.1.1.cmml" xref="S3.Ex2.m1.2.2.1.1.2.2.2.1.1">subscript</csymbol><ci id="S3.Ex2.m1.2.2.1.1.2.2.2.1.1.2.cmml" xref="S3.Ex2.m1.2.2.1.1.2.2.2.1.1.2">𝑇</ci><cn type="integer" id="S3.Ex2.m1.2.2.1.1.2.2.2.1.1.3.cmml" xref="S3.Ex2.m1.2.2.1.1.2.2.2.1.1.3">1</cn></apply></apply></apply><apply id="S3.Ex2.m1.2.2.1.1.4.4.cmml" xref="S3.Ex2.m1.2.2.1.1.4.4"><ci id="S3.Ex2.m1.2.2.1.1.4.4.3.cmml" xref="S3.Ex2.m1.2.2.1.1.4.4.3">⋅</ci><apply id="S3.Ex2.m1.2.2.1.1.3.3.1.2.cmml" xref="S3.Ex2.m1.2.2.1.1.3.3.1.1"><abs id="S3.Ex2.m1.2.2.1.1.3.3.1.2.1.cmml" xref="S3.Ex2.m1.2.2.1.1.3.3.1.1.2"></abs><apply id="S3.Ex2.m1.2.2.1.1.3.3.1.1.1.cmml" xref="S3.Ex2.m1.2.2.1.1.3.3.1.1.1"><csymbol cd="ambiguous" id="S3.Ex2.m1.2.2.1.1.3.3.1.1.1.1.cmml" xref="S3.Ex2.m1.2.2.1.1.3.3.1.1.1">subscript</csymbol><ci id="S3.Ex2.m1.2.2.1.1.3.3.1.1.1.2.cmml" xref="S3.Ex2.m1.2.2.1.1.3.3.1.1.1.2">𝑆</ci><cn type="integer" id="S3.Ex2.m1.2.2.1.1.3.3.1.1.1.3.cmml" xref="S3.Ex2.m1.2.2.1.1.3.3.1.1.1.3">2</cn></apply></apply><apply id="S3.Ex2.m1.2.2.1.1.4.4.2.2.cmml" xref="S3.Ex2.m1.2.2.1.1.4.4.2.1"><abs id="S3.Ex2.m1.2.2.1.1.4.4.2.2.1.cmml" xref="S3.Ex2.m1.2.2.1.1.4.4.2.1.2"></abs><apply id="S3.Ex2.m1.2.2.1.1.4.4.2.1.1.cmml" xref="S3.Ex2.m1.2.2.1.1.4.4.2.1.1"><csymbol cd="ambiguous" id="S3.Ex2.m1.2.2.1.1.4.4.2.1.1.1.cmml" xref="S3.Ex2.m1.2.2.1.1.4.4.2.1.1">subscript</csymbol><ci id="S3.Ex2.m1.2.2.1.1.4.4.2.1.1.2.cmml" xref="S3.Ex2.m1.2.2.1.1.4.4.2.1.1.2">𝑇</ci><cn type="integer" id="S3.Ex2.m1.2.2.1.1.4.4.2.1.1.3.cmml" xref="S3.Ex2.m1.2.2.1.1.4.4.2.1.1.3">2</cn></apply></apply></apply></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.Ex2.m1.2c">\hbox{Score}(H)=|S_{1}|\cdot|T_{1}|+|S_{2}|\cdot|T_{2}|.</annotation><annotation encoding="application/x-llamapun" id="S3.Ex2.m1.2d">Score ( italic_H ) = | italic_S start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT | ⋅ | italic_T start_POSTSUBSCRIPT 1 end_POSTSUBSCRIPT | + | italic_S start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | ⋅ | italic_T start_POSTSUBSCRIPT 2 end_POSTSUBSCRIPT | .</annotation></semantics></math></td>
<td class="ltx_eqn_cell ltx_eqn_center_padright"></td>
</tr></tbody>
</table>
<p id="S3.SS2.p5.16" class="ltx_p">Intuitively a small score is good, because it means that the average
ambiguity in the choice of nearest neighbors is small. The
minimum-ambiguity splitting method selects the orthogonal hyperplane <math id="S3.SS2.p5.16.m1.1" class="ltx_Math" alttext="H" display="inline"><semantics id="S3.SS2.p5.16.m1.1a"><mi id="S3.SS2.p5.16.m1.1.1" xref="S3.SS2.p5.16.m1.1.1.cmml">H</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p5.16.m1.1b"><ci id="S3.SS2.p5.16.m1.1.1.cmml" xref="S3.SS2.p5.16.m1.1.1">𝐻</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p5.16.m1.1c">H</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p5.16.m1.1d">italic_H</annotation></semantics></math>
that produces a nontrivial partition of the data points and has the
smallest score. For example, in Fig. <a href="#S3.F2" title="Figure 2 ‣ 3.2 Minimum-Ambiguity ‣ 3 Splitting Methods ‣ Analysis of Approximate Nearest Neighbor Searching with Clustered Point SetsThe support of the National Science Foundation under grant CCR–9712379 is gratefully acknowledged." class="ltx_ref"><span class="ltx_text ltx_ref_tag">2</span></a> on the left, we
show the score of the standard kd-tree splitting method. However,
because of the higher concentration of training points on the right side
of the cell, the splitting plane shown on the right actually has a lower
score, and hence is preferred by the minimum-ambiguity method. In this
way the minimum-ambiguity method tailors the structure of the tree to
the distribution of the training points.</p>
</div>
<figure id="S3.F2" class="ltx_figure">
<p id="S3.F2.1" class="ltx_p ltx_align_center"><span id="S3.F2.1.1" class="ltx_text"><img src="/html/cs/9901013/assets/x2.png" id="S3.F2.1.1.g1" class="ltx_graphics ltx_img_landscape" width="525" height="207" alt="Refer to caption"></span></p>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 2: </span>Minimum ambiguity splitting method.</figcaption>
</figure>
<div id="S3.SS2.p6" class="ltx_para">
<p id="S3.SS2.p6.6" class="ltx_p">The minimum-ambiguity split is computed as follows. At each stage it is
given the current cell <math id="S3.SS2.p6.1.m1.1" class="ltx_Math" alttext="C" display="inline"><semantics id="S3.SS2.p6.1.m1.1a"><mi id="S3.SS2.p6.1.m1.1.1" xref="S3.SS2.p6.1.m1.1.1.cmml">C</mi><annotation-xml encoding="MathML-Content" id="S3.SS2.p6.1.m1.1b"><ci id="S3.SS2.p6.1.m1.1.1.cmml" xref="S3.SS2.p6.1.m1.1.1">𝐶</ci></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p6.1.m1.1c">C</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p6.1.m1.1d">italic_C</annotation></semantics></math>, and the subsets <math id="S3.SS2.p6.2.m2.1" class="ltx_Math" alttext="S_{C}" display="inline"><semantics id="S3.SS2.p6.2.m2.1a"><msub id="S3.SS2.p6.2.m2.1.1" xref="S3.SS2.p6.2.m2.1.1.cmml"><mi id="S3.SS2.p6.2.m2.1.1.2" xref="S3.SS2.p6.2.m2.1.1.2.cmml">S</mi><mi id="S3.SS2.p6.2.m2.1.1.3" xref="S3.SS2.p6.2.m2.1.1.3.cmml">C</mi></msub><annotation-xml encoding="MathML-Content" id="S3.SS2.p6.2.m2.1b"><apply id="S3.SS2.p6.2.m2.1.1.cmml" xref="S3.SS2.p6.2.m2.1.1"><csymbol cd="ambiguous" id="S3.SS2.p6.2.m2.1.1.1.cmml" xref="S3.SS2.p6.2.m2.1.1">subscript</csymbol><ci id="S3.SS2.p6.2.m2.1.1.2.cmml" xref="S3.SS2.p6.2.m2.1.1.2">𝑆</ci><ci id="S3.SS2.p6.2.m2.1.1.3.cmml" xref="S3.SS2.p6.2.m2.1.1.3">𝐶</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p6.2.m2.1c">S_{C}</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p6.2.m2.1d">italic_S start_POSTSUBSCRIPT italic_C end_POSTSUBSCRIPT</annotation></semantics></math> and <math id="S3.SS2.p6.3.m3.1" class="ltx_Math" alttext="T_{C}" display="inline"><semantics id="S3.SS2.p6.3.m3.1a"><msub id="S3.SS2.p6.3.m3.1.1" xref="S3.SS2.p6.3.m3.1.1.cmml"><mi id="S3.SS2.p6.3.m3.1.1.2" xref="S3.SS2.p6.3.m3.1.1.2.cmml">T</mi><mi id="S3.SS2.p6.3.m3.1.1.3" xref="S3.SS2.p6.3.m3.1.1.3.cmml">C</mi></msub><annotation-xml encoding="MathML-Content" id="S3.SS2.p6.3.m3.1b"><apply id="S3.SS2.p6.3.m3.1.1.cmml" xref="S3.SS2.p6.3.m3.1.1"><csymbol cd="ambiguous" id="S3.SS2.p6.3.m3.1.1.1.cmml" xref="S3.SS2.p6.3.m3.1.1">subscript</csymbol><ci id="S3.SS2.p6.3.m3.1.1.2.cmml" xref="S3.SS2.p6.3.m3.1.1.2">𝑇</ci><ci id="S3.SS2.p6.3.m3.1.1.3.cmml" xref="S3.SS2.p6.3.m3.1.1.3">𝐶</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p6.3.m3.1c">T_{C}</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p6.3.m3.1d">italic_T start_POSTSUBSCRIPT italic_C end_POSTSUBSCRIPT</annotation></semantics></math>. For each
coordinate axis, it projects the points of <math id="S3.SS2.p6.4.m4.1" class="ltx_Math" alttext="S_{C}" display="inline"><semantics id="S3.SS2.p6.4.m4.1a"><msub id="S3.SS2.p6.4.m4.1.1" xref="S3.SS2.p6.4.m4.1.1.cmml"><mi id="S3.SS2.p6.4.m4.1.1.2" xref="S3.SS2.p6.4.m4.1.1.2.cmml">S</mi><mi id="S3.SS2.p6.4.m4.1.1.3" xref="S3.SS2.p6.4.m4.1.1.3.cmml">C</mi></msub><annotation-xml encoding="MathML-Content" id="S3.SS2.p6.4.m4.1b"><apply id="S3.SS2.p6.4.m4.1.1.cmml" xref="S3.SS2.p6.4.m4.1.1"><csymbol cd="ambiguous" id="S3.SS2.p6.4.m4.1.1.1.cmml" xref="S3.SS2.p6.4.m4.1.1">subscript</csymbol><ci id="S3.SS2.p6.4.m4.1.1.2.cmml" xref="S3.SS2.p6.4.m4.1.1.2">𝑆</ci><ci id="S3.SS2.p6.4.m4.1.1.3.cmml" xref="S3.SS2.p6.4.m4.1.1.3">𝐶</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p6.4.m4.1c">S_{C}</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p6.4.m4.1d">italic_S start_POSTSUBSCRIPT italic_C end_POSTSUBSCRIPT</annotation></semantics></math> and the extreme
coordinates of the balls <math id="S3.SS2.p6.5.m5.1" class="ltx_Math" alttext="b(q)" display="inline"><semantics id="S3.SS2.p6.5.m5.1a"><mrow id="S3.SS2.p6.5.m5.1.2" xref="S3.SS2.p6.5.m5.1.2.cmml"><mi id="S3.SS2.p6.5.m5.1.2.2" xref="S3.SS2.p6.5.m5.1.2.2.cmml">b</mi><mo id="S3.SS2.p6.5.m5.1.2.1" xref="S3.SS2.p6.5.m5.1.2.1.cmml">⁢</mo><mrow id="S3.SS2.p6.5.m5.1.2.3.2" xref="S3.SS2.p6.5.m5.1.2.cmml"><mo stretchy="false" id="S3.SS2.p6.5.m5.1.2.3.2.1" xref="S3.SS2.p6.5.m5.1.2.cmml">(</mo><mi id="S3.SS2.p6.5.m5.1.1" xref="S3.SS2.p6.5.m5.1.1.cmml">q</mi><mo stretchy="false" id="S3.SS2.p6.5.m5.1.2.3.2.2" xref="S3.SS2.p6.5.m5.1.2.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S3.SS2.p6.5.m5.1b"><apply id="S3.SS2.p6.5.m5.1.2.cmml" xref="S3.SS2.p6.5.m5.1.2"><times id="S3.SS2.p6.5.m5.1.2.1.cmml" xref="S3.SS2.p6.5.m5.1.2.1"></times><ci id="S3.SS2.p6.5.m5.1.2.2.cmml" xref="S3.SS2.p6.5.m5.1.2.2">𝑏</ci><ci id="S3.SS2.p6.5.m5.1.1.cmml" xref="S3.SS2.p6.5.m5.1.1">𝑞</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p6.5.m5.1c">b(q)</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p6.5.m5.1d">italic_b ( italic_q )</annotation></semantics></math> for each <math id="S3.SS2.p6.6.m6.1" class="ltx_Math" alttext="q\in T_{C}" display="inline"><semantics id="S3.SS2.p6.6.m6.1a"><mrow id="S3.SS2.p6.6.m6.1.1" xref="S3.SS2.p6.6.m6.1.1.cmml"><mi id="S3.SS2.p6.6.m6.1.1.2" xref="S3.SS2.p6.6.m6.1.1.2.cmml">q</mi><mo id="S3.SS2.p6.6.m6.1.1.1" xref="S3.SS2.p6.6.m6.1.1.1.cmml">∈</mo><msub id="S3.SS2.p6.6.m6.1.1.3" xref="S3.SS2.p6.6.m6.1.1.3.cmml"><mi id="S3.SS2.p6.6.m6.1.1.3.2" xref="S3.SS2.p6.6.m6.1.1.3.2.cmml">T</mi><mi id="S3.SS2.p6.6.m6.1.1.3.3" xref="S3.SS2.p6.6.m6.1.1.3.3.cmml">C</mi></msub></mrow><annotation-xml encoding="MathML-Content" id="S3.SS2.p6.6.m6.1b"><apply id="S3.SS2.p6.6.m6.1.1.cmml" xref="S3.SS2.p6.6.m6.1.1"><in id="S3.SS2.p6.6.m6.1.1.1.cmml" xref="S3.SS2.p6.6.m6.1.1.1"></in><ci id="S3.SS2.p6.6.m6.1.1.2.cmml" xref="S3.SS2.p6.6.m6.1.1.2">𝑞</ci><apply id="S3.SS2.p6.6.m6.1.1.3.cmml" xref="S3.SS2.p6.6.m6.1.1.3"><csymbol cd="ambiguous" id="S3.SS2.p6.6.m6.1.1.3.1.cmml" xref="S3.SS2.p6.6.m6.1.1.3">subscript</csymbol><ci id="S3.SS2.p6.6.m6.1.1.3.2.cmml" xref="S3.SS2.p6.6.m6.1.1.3.2">𝑇</ci><ci id="S3.SS2.p6.6.m6.1.1.3.3.cmml" xref="S3.SS2.p6.6.m6.1.1.3.3">𝐶</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S3.SS2.p6.6.m6.1c">q\in T_{C}</annotation><annotation encoding="application/x-llamapun" id="S3.SS2.p6.6.m6.1d">italic_q ∈ italic_T start_POSTSUBSCRIPT italic_C end_POSTSUBSCRIPT</annotation></semantics></math> orthogonally onto
this axis. It then sweeps through this set of projections, from the
leftmost to the rightmost data point projection, updating the score as
it goes. It selects the hyperplane with the minimum score. If there
are ties for the smallest score, then it selects the hyperplane that
most evenly partitions the data points.</p>
</div>
</section>
</section>
<section id="S4" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">4 </span>Empirical Results</h2>

<div id="S4.p1" class="ltx_para">
<p id="S4.p1.1" class="ltx_p">We implemented a kd-tree in C++ using the three splitting methods: the
standard method, sliding-midpoint, and minimum-ambiguity. For each
splitting method we generated a number data point sets, query point
sets, and (for minimum-ambiguity) training point sets. The tree
structure was based on the same basic tree structure used in ANN
<cite class="ltx_cite ltx_citemacro_cite">[<a href="#bib.bib30" title="" class="ltx_ref">30</a>]</cite>. The experiments were run on a Sparc Ultra,
running Solaris 5.5, and the program was compiled by the g++ compiler.
We measured a number of statistics for the tree, including its size,
depth, and the average aspect ratio of its cells.</p>
</div>
<div id="S4.p2" class="ltx_para">
<p id="S4.p2.1" class="ltx_p">Queries were answered using priority search. For each group of queries
we computed a number of statistics including CPU time, number of nodes
visited in the tree, number of floating-point operations, number of
distance calculations, and number of coordinate accesses. In our plots we
show only the number of nodes in the tree visited during the search. We
chose this parameter because it is a machine-independent quantity, and
was closely correlated with CPU time. In most of our experiments,
nearest neighbors were computed approximately.</p>
</div>
<div id="S4.p3" class="ltx_para">
<p id="S4.p3.5" class="ltx_p">For each experiment we fixed the number of data points, the
dimension, the data-point distribution, and the error bound
<math id="S4.p3.1.m1.1" class="ltx_Math" alttext="\epsilon" display="inline"><semantics id="S4.p3.1.m1.1a"><mi id="S4.p3.1.m1.1.1" xref="S4.p3.1.m1.1.1.cmml">ϵ</mi><annotation-xml encoding="MathML-Content" id="S4.p3.1.m1.1b"><ci id="S4.p3.1.m1.1.1.cmml" xref="S4.p3.1.m1.1.1">italic-ϵ</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.p3.1.m1.1c">\epsilon</annotation><annotation encoding="application/x-llamapun" id="S4.p3.1.m1.1d">italic_ϵ</annotation></semantics></math>. In the case of the minimum-ambiguity method, the query
distribution is also fixed, and some number of training points were
generated. Then a kd-tree was generated by applying the appropriate
splitting method. For the standard and sliding-midpoint methods the
tree construction does not depend on <math id="S4.p3.2.m2.1" class="ltx_Math" alttext="\epsilon" display="inline"><semantics id="S4.p3.2.m2.1a"><mi id="S4.p3.2.m2.1.1" xref="S4.p3.2.m2.1.1.cmml">ϵ</mi><annotation-xml encoding="MathML-Content" id="S4.p3.2.m2.1b"><ci id="S4.p3.2.m2.1.1.cmml" xref="S4.p3.2.m2.1.1">italic-ϵ</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.p3.2.m2.1c">\epsilon</annotation><annotation encoding="application/x-llamapun" id="S4.p3.2.m2.1d">italic_ϵ</annotation></semantics></math>, implying that the same
tree may be used for different error bounds. For the minimum-ambiguity
tree, the error bound was used in computing the tree. In particular,
the nearest neighbors of each of the training points was computed only
approximately. Furthermore, the nearest neighbor balls <math id="S4.p3.3.m3.1" class="ltx_Math" alttext="b(q)" display="inline"><semantics id="S4.p3.3.m3.1a"><mrow id="S4.p3.3.m3.1.2" xref="S4.p3.3.m3.1.2.cmml"><mi id="S4.p3.3.m3.1.2.2" xref="S4.p3.3.m3.1.2.2.cmml">b</mi><mo id="S4.p3.3.m3.1.2.1" xref="S4.p3.3.m3.1.2.1.cmml">⁢</mo><mrow id="S4.p3.3.m3.1.2.3.2" xref="S4.p3.3.m3.1.2.cmml"><mo stretchy="false" id="S4.p3.3.m3.1.2.3.2.1" xref="S4.p3.3.m3.1.2.cmml">(</mo><mi id="S4.p3.3.m3.1.1" xref="S4.p3.3.m3.1.1.cmml">q</mi><mo stretchy="false" id="S4.p3.3.m3.1.2.3.2.2" xref="S4.p3.3.m3.1.2.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S4.p3.3.m3.1b"><apply id="S4.p3.3.m3.1.2.cmml" xref="S4.p3.3.m3.1.2"><times id="S4.p3.3.m3.1.2.1.cmml" xref="S4.p3.3.m3.1.2.1"></times><ci id="S4.p3.3.m3.1.2.2.cmml" xref="S4.p3.3.m3.1.2.2">𝑏</ci><ci id="S4.p3.3.m3.1.1.cmml" xref="S4.p3.3.m3.1.1">𝑞</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.p3.3.m3.1c">b(q)</annotation><annotation encoding="application/x-llamapun" id="S4.p3.3.m3.1d">italic_b ( italic_q )</annotation></semantics></math> for each
training point <math id="S4.p3.4.m4.1" class="ltx_Math" alttext="q" display="inline"><semantics id="S4.p3.4.m4.1a"><mi id="S4.p3.4.m4.1.1" xref="S4.p3.4.m4.1.1.cmml">q</mi><annotation-xml encoding="MathML-Content" id="S4.p3.4.m4.1b"><ci id="S4.p3.4.m4.1.1.cmml" xref="S4.p3.4.m4.1.1">𝑞</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.p3.4.m4.1c">q</annotation><annotation encoding="application/x-llamapun" id="S4.p3.4.m4.1d">italic_q</annotation></semantics></math> were shrunken in size by dividing their radius by the
factor <math id="S4.p3.5.m5.1" class="ltx_Math" alttext="1+\epsilon" display="inline"><semantics id="S4.p3.5.m5.1a"><mrow id="S4.p3.5.m5.1.1" xref="S4.p3.5.m5.1.1.cmml"><mn id="S4.p3.5.m5.1.1.2" xref="S4.p3.5.m5.1.1.2.cmml">1</mn><mo id="S4.p3.5.m5.1.1.1" xref="S4.p3.5.m5.1.1.1.cmml">+</mo><mi id="S4.p3.5.m5.1.1.3" xref="S4.p3.5.m5.1.1.3.cmml">ϵ</mi></mrow><annotation-xml encoding="MathML-Content" id="S4.p3.5.m5.1b"><apply id="S4.p3.5.m5.1.1.cmml" xref="S4.p3.5.m5.1.1"><plus id="S4.p3.5.m5.1.1.1.cmml" xref="S4.p3.5.m5.1.1.1"></plus><cn type="integer" id="S4.p3.5.m5.1.1.2.cmml" xref="S4.p3.5.m5.1.1.2">1</cn><ci id="S4.p3.5.m5.1.1.3.cmml" xref="S4.p3.5.m5.1.1.3">italic-ϵ</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.p3.5.m5.1c">1+\epsilon</annotation><annotation encoding="application/x-llamapun" id="S4.p3.5.m5.1d">1 + italic_ϵ</annotation></semantics></math>. This is because this is the size of the ball that
is used in the search algorithm.</p>
</div>
<div id="S4.p4" class="ltx_para">
<p id="S4.p4.1" class="ltx_p">For each tree generated, we generated some number of query points.
The query-point distribution was not always the same as the data
distribution, but it is always the same as the training point
distribution. Then the nearest neighbor search was performed on these
query points, and the results were averaged over all queries.
Although we ran a wide variety of experiments, for the sake of
conciseness we show only a few representative cases. For all of the
experiments described here, we used 4000 data points in dimension 20 for
each data set, and there were 12,000 queries run for each data set. For
the minimum-ambiguity method, the number of training points was 36,000.</p>
</div>
<div id="S4.p5" class="ltx_para">
<p id="S4.p5.3" class="ltx_p">The value of <math id="S4.p5.1.m1.1" class="ltx_Math" alttext="\epsilon" display="inline"><semantics id="S4.p5.1.m1.1a"><mi id="S4.p5.1.m1.1.1" xref="S4.p5.1.m1.1.1.cmml">ϵ</mi><annotation-xml encoding="MathML-Content" id="S4.p5.1.m1.1b"><ci id="S4.p5.1.m1.1.1.cmml" xref="S4.p5.1.m1.1.1">italic-ϵ</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.p5.1.m1.1c">\epsilon</annotation><annotation encoding="application/x-llamapun" id="S4.p5.1.m1.1d">italic_ϵ</annotation></semantics></math> was either 1, 2, or 3 (allowing the reported
point to be a factor of 2, 3, or 4 further away than the true nearest
neighbor, respectively). We computed the exact nearest neighbors
off-line to guage the algorithm’s actual performance. The reason for
allowing approximation errors is that in moderate to high dimensions,
the search times are typically smaller by orders of magnitude. Also the
errors that were observed are typically quite a bit smaller on average
than these bounds (see Fig. <a href="#S4.F3" title="Figure 3 ‣ 4 Empirical Results ‣ Analysis of Approximate Nearest Neighbor Searching with Clustered Point SetsThe support of the National Science Foundation under grant CCR–9712379 is gratefully acknowledged." class="ltx_ref"><span class="ltx_text ltx_ref_tag">3</span></a>). Note that average error
committed was typically only about <math id="S4.p5.2.m2.1" class="ltx_Math" alttext="1/30" display="inline"><semantics id="S4.p5.2.m2.1a"><mrow id="S4.p5.2.m2.1.1" xref="S4.p5.2.m2.1.1.cmml"><mn id="S4.p5.2.m2.1.1.2" xref="S4.p5.2.m2.1.1.2.cmml">1</mn><mo id="S4.p5.2.m2.1.1.1" xref="S4.p5.2.m2.1.1.1.cmml">/</mo><mn id="S4.p5.2.m2.1.1.3" xref="S4.p5.2.m2.1.1.3.cmml">30</mn></mrow><annotation-xml encoding="MathML-Content" id="S4.p5.2.m2.1b"><apply id="S4.p5.2.m2.1.1.cmml" xref="S4.p5.2.m2.1.1"><divide id="S4.p5.2.m2.1.1.1.cmml" xref="S4.p5.2.m2.1.1.1"></divide><cn type="integer" id="S4.p5.2.m2.1.1.2.cmml" xref="S4.p5.2.m2.1.1.2">1</cn><cn type="integer" id="S4.p5.2.m2.1.1.3.cmml" xref="S4.p5.2.m2.1.1.3">30</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.p5.2.m2.1c">1/30</annotation><annotation encoding="application/x-llamapun" id="S4.p5.2.m2.1d">1 / 30</annotation></semantics></math> of the allowable error. The
maximum error was computed for each run of 12,000 query points, and then
averaged over all runs. Even this maximum error was only around <math id="S4.p5.3.m3.1" class="ltx_Math" alttext="1/4" display="inline"><semantics id="S4.p5.3.m3.1a"><mrow id="S4.p5.3.m3.1.1" xref="S4.p5.3.m3.1.1.cmml"><mn id="S4.p5.3.m3.1.1.2" xref="S4.p5.3.m3.1.1.2.cmml">1</mn><mo id="S4.p5.3.m3.1.1.1" xref="S4.p5.3.m3.1.1.1.cmml">/</mo><mn id="S4.p5.3.m3.1.1.3" xref="S4.p5.3.m3.1.1.3.cmml">4</mn></mrow><annotation-xml encoding="MathML-Content" id="S4.p5.3.m3.1b"><apply id="S4.p5.3.m3.1.1.cmml" xref="S4.p5.3.m3.1.1"><divide id="S4.p5.3.m3.1.1.1.cmml" xref="S4.p5.3.m3.1.1.1"></divide><cn type="integer" id="S4.p5.3.m3.1.1.2.cmml" xref="S4.p5.3.m3.1.1.2">1</cn><cn type="integer" id="S4.p5.3.m3.1.1.3.cmml" xref="S4.p5.3.m3.1.1.3">4</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.p5.3.m3.1c">1/4</annotation><annotation encoding="application/x-llamapun" id="S4.p5.3.m3.1d">1 / 4</annotation></semantics></math>
of the allowed error. Some variation (on the order of a factor of 2)
was observed depending on the choice of search tree and point
distributions.</p>
</div>
<figure id="S4.F3" class="ltx_figure">
<table id="S4.F3.1" class="ltx_tabular ltx_centering ltx_guessed_headers ltx_align_middle">
<thead class="ltx_thead">
<tr id="S4.F3.1.1" class="ltx_tr">
<th id="S4.F3.1.1.1" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_th_row ltx_border_ll ltx_border_r ltx_border_tt"><math id="S4.F3.1.1.1.m1.1" class="ltx_Math" alttext="\epsilon" display="inline"><semantics id="S4.F3.1.1.1.m1.1a"><mi id="S4.F3.1.1.1.m1.1.1" xref="S4.F3.1.1.1.m1.1.1.cmml">ϵ</mi><annotation-xml encoding="MathML-Content" id="S4.F3.1.1.1.m1.1b"><ci id="S4.F3.1.1.1.m1.1.1.cmml" xref="S4.F3.1.1.1.m1.1.1">italic-ϵ</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.F3.1.1.1.m1.1c">\epsilon</annotation><annotation encoding="application/x-llamapun" id="S4.F3.1.1.1.m1.1d">italic_ϵ</annotation></semantics></math></th>
<th id="S4.F3.1.1.2" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_tt">Avg. error</th>
<th id="S4.F3.1.1.3" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_r ltx_border_tt">Std. dev.</th>
<th id="S4.F3.1.1.4" class="ltx_td ltx_align_center ltx_th ltx_th_column ltx_border_rr ltx_border_tt">Max. Error</th>
</tr>
</thead>
<tbody class="ltx_tbody">
<tr id="S4.F3.1.2.1" class="ltx_tr">
<th id="S4.F3.1.2.1.1" class="ltx_td ltx_align_center ltx_th ltx_th_row ltx_border_ll ltx_border_r ltx_border_t">1.0</th>
<td id="S4.F3.1.2.1.2" class="ltx_td ltx_align_center ltx_border_r ltx_border_t">0.03643</td>
<td id="S4.F3.1.2.1.3" class="ltx_td ltx_align_center ltx_border_r ltx_border_t">0.0340</td>
<td id="S4.F3.1.2.1.4" class="ltx_td ltx_align_center ltx_border_rr ltx_border_t">0.248</td>
</tr>
<tr id="S4.F3.1.3.2" class="ltx_tr">
<th id="S4.F3.1.3.2.1" class="ltx_td ltx_align_center ltx_th ltx_th_row ltx_border_ll ltx_border_r">2.0</th>
<td id="S4.F3.1.3.2.2" class="ltx_td ltx_align_center ltx_border_r">0.06070</td>
<td id="S4.F3.1.3.2.3" class="ltx_td ltx_align_center ltx_border_r">0.0541</td>
<td id="S4.F3.1.3.2.4" class="ltx_td ltx_align_center ltx_border_rr">0.500</td>
</tr>
<tr id="S4.F3.1.4.3" class="ltx_tr">
<th id="S4.F3.1.4.3.1" class="ltx_td ltx_align_center ltx_th ltx_th_row ltx_border_bb ltx_border_ll ltx_border_r">3.0</th>
<td id="S4.F3.1.4.3.2" class="ltx_td ltx_align_center ltx_border_bb ltx_border_r">0.08422</td>
<td id="S4.F3.1.4.3.3" class="ltx_td ltx_align_center ltx_border_bb ltx_border_r">0.0712</td>
<td id="S4.F3.1.4.3.4" class="ltx_td ltx_align_center ltx_border_bb ltx_border_rr">0.687</td>
</tr>
</tbody>
</table>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 3: </span>Average error commited, the standard deviation of the error,
and the maximum error versus the allowed error, <math id="S4.F3.3.m1.1" class="ltx_Math" alttext="\epsilon" display="inline"><semantics id="S4.F3.3.m1.1b"><mi id="S4.F3.3.m1.1.1" xref="S4.F3.3.m1.1.1.cmml">ϵ</mi><annotation-xml encoding="MathML-Content" id="S4.F3.3.m1.1c"><ci id="S4.F3.3.m1.1.1.cmml" xref="S4.F3.3.m1.1.1">italic-ϵ</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.F3.3.m1.1d">\epsilon</annotation><annotation encoding="application/x-llamapun" id="S4.F3.3.m1.1e">italic_ϵ</annotation></semantics></math>. Values
were averaged over all runs.</figcaption>
</figure>
<section id="S4.SS1" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">4.1 </span>Distributions Tested</h3>

<div id="S4.SS1.p1" class="ltx_para">
<p id="S4.SS1.p1.1" class="ltx_p">The distributions that were used in our experiments are listed below.
The clustered-gaussian distribution is designed to model point sets that
are clustered, but in which each cluster is full-dimensional. The
clustered-orthogonal-ellipsoid and clustered-ellipsoid distributions are
both explicitly designed to model point distributions which are
clustered, and the clusters themselves are flat in the sense that the
points lie close to a lower dimensional subspace. In the first case the
ellipsoids are aligned with the axes, and in the other case they are
more arbitrarily oriented.</p>
</div>
<div id="S4.SS1.p2" class="ltx_para">
<dl id="S4.I1" class="ltx_description">
<dt id="S4.I1.ix1" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S4.I1.ix1.1.1.1" class="ltx_text ltx_font_bold">Uniform:</span></span></dt>
<dd class="ltx_item">
<div id="S4.I1.ix1.p1" class="ltx_para">
<p id="S4.I1.ix1.p1.1" class="ltx_p">Each coordinate was chosen uniformly from the interval <math id="S4.I1.ix1.p1.1.m1.2" class="ltx_Math" alttext="[-1,1]" display="inline"><semantics id="S4.I1.ix1.p1.1.m1.2a"><mrow id="S4.I1.ix1.p1.1.m1.2.2.1" xref="S4.I1.ix1.p1.1.m1.2.2.2.cmml"><mo stretchy="false" id="S4.I1.ix1.p1.1.m1.2.2.1.2" xref="S4.I1.ix1.p1.1.m1.2.2.2.cmml">[</mo><mrow id="S4.I1.ix1.p1.1.m1.2.2.1.1" xref="S4.I1.ix1.p1.1.m1.2.2.1.1.cmml"><mo id="S4.I1.ix1.p1.1.m1.2.2.1.1a" xref="S4.I1.ix1.p1.1.m1.2.2.1.1.cmml">−</mo><mn id="S4.I1.ix1.p1.1.m1.2.2.1.1.2" xref="S4.I1.ix1.p1.1.m1.2.2.1.1.2.cmml">1</mn></mrow><mo id="S4.I1.ix1.p1.1.m1.2.2.1.3" xref="S4.I1.ix1.p1.1.m1.2.2.2.cmml">,</mo><mn id="S4.I1.ix1.p1.1.m1.1.1" xref="S4.I1.ix1.p1.1.m1.1.1.cmml">1</mn><mo stretchy="false" id="S4.I1.ix1.p1.1.m1.2.2.1.4" xref="S4.I1.ix1.p1.1.m1.2.2.2.cmml">]</mo></mrow><annotation-xml encoding="MathML-Content" id="S4.I1.ix1.p1.1.m1.2b"><interval closure="closed" id="S4.I1.ix1.p1.1.m1.2.2.2.cmml" xref="S4.I1.ix1.p1.1.m1.2.2.1"><apply id="S4.I1.ix1.p1.1.m1.2.2.1.1.cmml" xref="S4.I1.ix1.p1.1.m1.2.2.1.1"><minus id="S4.I1.ix1.p1.1.m1.2.2.1.1.1.cmml" xref="S4.I1.ix1.p1.1.m1.2.2.1.1"></minus><cn type="integer" id="S4.I1.ix1.p1.1.m1.2.2.1.1.2.cmml" xref="S4.I1.ix1.p1.1.m1.2.2.1.1.2">1</cn></apply><cn type="integer" id="S4.I1.ix1.p1.1.m1.1.1.cmml" xref="S4.I1.ix1.p1.1.m1.1.1">1</cn></interval></annotation-xml><annotation encoding="application/x-tex" id="S4.I1.ix1.p1.1.m1.2c">[-1,1]</annotation><annotation encoding="application/x-llamapun" id="S4.I1.ix1.p1.1.m1.2d">[ - 1 , 1 ]</annotation></semantics></math>.</p>
</div>
</dd>
<dt id="S4.I1.ix2" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S4.I1.ix2.1.1.1" class="ltx_text ltx_font_bold">Clustered-gaussian:</span></span></dt>
<dd class="ltx_item">
<div id="S4.I1.ix2.p1" class="ltx_para">
<p id="S4.I1.ix2.p1.4" class="ltx_p">The distribution is given a number of color classes <math id="S4.I1.ix2.p1.1.m1.1" class="ltx_Math" alttext="c" display="inline"><semantics id="S4.I1.ix2.p1.1.m1.1a"><mi id="S4.I1.ix2.p1.1.m1.1.1" xref="S4.I1.ix2.p1.1.m1.1.1.cmml">c</mi><annotation-xml encoding="MathML-Content" id="S4.I1.ix2.p1.1.m1.1b"><ci id="S4.I1.ix2.p1.1.m1.1.1.cmml" xref="S4.I1.ix2.p1.1.m1.1.1">𝑐</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.I1.ix2.p1.1.m1.1c">c</annotation><annotation encoding="application/x-llamapun" id="S4.I1.ix2.p1.1.m1.1d">italic_c</annotation></semantics></math>, and
a standard deviation <math id="S4.I1.ix2.p1.2.m2.1" class="ltx_Math" alttext="\sigma" display="inline"><semantics id="S4.I1.ix2.p1.2.m2.1a"><mi id="S4.I1.ix2.p1.2.m2.1.1" xref="S4.I1.ix2.p1.2.m2.1.1.cmml">σ</mi><annotation-xml encoding="MathML-Content" id="S4.I1.ix2.p1.2.m2.1b"><ci id="S4.I1.ix2.p1.2.m2.1.1.cmml" xref="S4.I1.ix2.p1.2.m2.1.1">𝜎</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.I1.ix2.p1.2.m2.1c">\sigma</annotation><annotation encoding="application/x-llamapun" id="S4.I1.ix2.p1.2.m2.1d">italic_σ</annotation></semantics></math>. We generated <math id="S4.I1.ix2.p1.3.m3.1" class="ltx_Math" alttext="c" display="inline"><semantics id="S4.I1.ix2.p1.3.m3.1a"><mi id="S4.I1.ix2.p1.3.m3.1.1" xref="S4.I1.ix2.p1.3.m3.1.1.cmml">c</mi><annotation-xml encoding="MathML-Content" id="S4.I1.ix2.p1.3.m3.1b"><ci id="S4.I1.ix2.p1.3.m3.1.1.cmml" xref="S4.I1.ix2.p1.3.m3.1.1">𝑐</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.I1.ix2.p1.3.m3.1c">c</annotation><annotation encoding="application/x-llamapun" id="S4.I1.ix2.p1.3.m3.1d">italic_c</annotation></semantics></math> points from
the uniform distribution, which form cluster centers. Each point
is generated from a gaussian distribution centered at a randomly
chosen cluster center with standard deviation <math id="S4.I1.ix2.p1.4.m4.1" class="ltx_Math" alttext="\sigma" display="inline"><semantics id="S4.I1.ix2.p1.4.m4.1a"><mi id="S4.I1.ix2.p1.4.m4.1.1" xref="S4.I1.ix2.p1.4.m4.1.1.cmml">σ</mi><annotation-xml encoding="MathML-Content" id="S4.I1.ix2.p1.4.m4.1b"><ci id="S4.I1.ix2.p1.4.m4.1.1.cmml" xref="S4.I1.ix2.p1.4.m4.1.1">𝜎</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.I1.ix2.p1.4.m4.1c">\sigma</annotation><annotation encoding="application/x-llamapun" id="S4.I1.ix2.p1.4.m4.1d">italic_σ</annotation></semantics></math>.</p>
</div>
</dd>
<dt id="S4.I1.ix3" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S4.I1.ix3.1.1.1" class="ltx_text ltx_font_bold">Clustered-orthogonal-ellipsoids:</span></span></dt>
<dd class="ltx_item">
<div id="S4.I1.ix3.p1" class="ltx_para">
<p id="S4.I1.ix3.p1.1" class="ltx_p">The distribution can be viewed as a degenerate clustered-gaussian
distribution where the standard deviation of each coordinate is
chosen from one of two classes of distributions, one with a large
standard deviation and the other with a small standard deviation.
The distribution is specified by the number of color classes <math id="S4.I1.ix3.p1.1.m1.1" class="ltx_Math" alttext="c" display="inline"><semantics id="S4.I1.ix3.p1.1.m1.1a"><mi id="S4.I1.ix3.p1.1.m1.1.1" xref="S4.I1.ix3.p1.1.m1.1.1.cmml">c</mi><annotation-xml encoding="MathML-Content" id="S4.I1.ix3.p1.1.m1.1b"><ci id="S4.I1.ix3.p1.1.m1.1.1.cmml" xref="S4.I1.ix3.p1.1.m1.1.1">𝑐</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.I1.ix3.p1.1.m1.1c">c</annotation><annotation encoding="application/x-llamapun" id="S4.I1.ix3.p1.1.m1.1d">italic_c</annotation></semantics></math>
and four additional parameters:</p>
<ul id="S4.I1.ix3.I1" class="ltx_itemize">
<li id="S4.I1.ix3.I1.i1" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item"><span id="S4.I1.ix3.I1.i1.1.1.1" class="ltx_text ltx_font_bold">•</span></span> 
<div id="S4.I1.ix3.I1.i1.p1" class="ltx_para">
<p id="S4.I1.ix3.I1.i1.p1.1" class="ltx_p"><math id="S4.I1.ix3.I1.i1.p1.1.m1.1" class="ltx_Math" alttext="d_{\rm max}" display="inline"><semantics id="S4.I1.ix3.I1.i1.p1.1.m1.1a"><msub id="S4.I1.ix3.I1.i1.p1.1.m1.1.1" xref="S4.I1.ix3.I1.i1.p1.1.m1.1.1.cmml"><mi id="S4.I1.ix3.I1.i1.p1.1.m1.1.1.2" xref="S4.I1.ix3.I1.i1.p1.1.m1.1.1.2.cmml">d</mi><mi id="S4.I1.ix3.I1.i1.p1.1.m1.1.1.3" xref="S4.I1.ix3.I1.i1.p1.1.m1.1.1.3.cmml">max</mi></msub><annotation-xml encoding="MathML-Content" id="S4.I1.ix3.I1.i1.p1.1.m1.1b"><apply id="S4.I1.ix3.I1.i1.p1.1.m1.1.1.cmml" xref="S4.I1.ix3.I1.i1.p1.1.m1.1.1"><csymbol cd="ambiguous" id="S4.I1.ix3.I1.i1.p1.1.m1.1.1.1.cmml" xref="S4.I1.ix3.I1.i1.p1.1.m1.1.1">subscript</csymbol><ci id="S4.I1.ix3.I1.i1.p1.1.m1.1.1.2.cmml" xref="S4.I1.ix3.I1.i1.p1.1.m1.1.1.2">𝑑</ci><ci id="S4.I1.ix3.I1.i1.p1.1.m1.1.1.3.cmml" xref="S4.I1.ix3.I1.i1.p1.1.m1.1.1.3">max</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.I1.ix3.I1.i1.p1.1.m1.1c">d_{\rm max}</annotation><annotation encoding="application/x-llamapun" id="S4.I1.ix3.I1.i1.p1.1.m1.1d">italic_d start_POSTSUBSCRIPT roman_max end_POSTSUBSCRIPT</annotation></semantics></math> is the maximum number of fat dimensions.</p>
</div>
</li>
<li id="S4.I1.ix3.I1.i2" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item"><span id="S4.I1.ix3.I1.i2.1.1.1" class="ltx_text ltx_font_bold">•</span></span> 
<div id="S4.I1.ix3.I1.i2.p1" class="ltx_para">
<p id="S4.I1.ix3.I1.i2.p1.2" class="ltx_p"><math id="S4.I1.ix3.I1.i2.p1.1.m1.1" class="ltx_Math" alttext="\sigma_{\rm lo}" display="inline"><semantics id="S4.I1.ix3.I1.i2.p1.1.m1.1a"><msub id="S4.I1.ix3.I1.i2.p1.1.m1.1.1" xref="S4.I1.ix3.I1.i2.p1.1.m1.1.1.cmml"><mi id="S4.I1.ix3.I1.i2.p1.1.m1.1.1.2" xref="S4.I1.ix3.I1.i2.p1.1.m1.1.1.2.cmml">σ</mi><mi id="S4.I1.ix3.I1.i2.p1.1.m1.1.1.3" xref="S4.I1.ix3.I1.i2.p1.1.m1.1.1.3.cmml">lo</mi></msub><annotation-xml encoding="MathML-Content" id="S4.I1.ix3.I1.i2.p1.1.m1.1b"><apply id="S4.I1.ix3.I1.i2.p1.1.m1.1.1.cmml" xref="S4.I1.ix3.I1.i2.p1.1.m1.1.1"><csymbol cd="ambiguous" id="S4.I1.ix3.I1.i2.p1.1.m1.1.1.1.cmml" xref="S4.I1.ix3.I1.i2.p1.1.m1.1.1">subscript</csymbol><ci id="S4.I1.ix3.I1.i2.p1.1.m1.1.1.2.cmml" xref="S4.I1.ix3.I1.i2.p1.1.m1.1.1.2">𝜎</ci><ci id="S4.I1.ix3.I1.i2.p1.1.m1.1.1.3.cmml" xref="S4.I1.ix3.I1.i2.p1.1.m1.1.1.3">lo</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.I1.ix3.I1.i2.p1.1.m1.1c">\sigma_{\rm lo}</annotation><annotation encoding="application/x-llamapun" id="S4.I1.ix3.I1.i2.p1.1.m1.1d">italic_σ start_POSTSUBSCRIPT roman_lo end_POSTSUBSCRIPT</annotation></semantics></math> and <math id="S4.I1.ix3.I1.i2.p1.2.m2.1" class="ltx_Math" alttext="\sigma_{\rm hi}" display="inline"><semantics id="S4.I1.ix3.I1.i2.p1.2.m2.1a"><msub id="S4.I1.ix3.I1.i2.p1.2.m2.1.1" xref="S4.I1.ix3.I1.i2.p1.2.m2.1.1.cmml"><mi id="S4.I1.ix3.I1.i2.p1.2.m2.1.1.2" xref="S4.I1.ix3.I1.i2.p1.2.m2.1.1.2.cmml">σ</mi><mi id="S4.I1.ix3.I1.i2.p1.2.m2.1.1.3" xref="S4.I1.ix3.I1.i2.p1.2.m2.1.1.3.cmml">hi</mi></msub><annotation-xml encoding="MathML-Content" id="S4.I1.ix3.I1.i2.p1.2.m2.1b"><apply id="S4.I1.ix3.I1.i2.p1.2.m2.1.1.cmml" xref="S4.I1.ix3.I1.i2.p1.2.m2.1.1"><csymbol cd="ambiguous" id="S4.I1.ix3.I1.i2.p1.2.m2.1.1.1.cmml" xref="S4.I1.ix3.I1.i2.p1.2.m2.1.1">subscript</csymbol><ci id="S4.I1.ix3.I1.i2.p1.2.m2.1.1.2.cmml" xref="S4.I1.ix3.I1.i2.p1.2.m2.1.1.2">𝜎</ci><ci id="S4.I1.ix3.I1.i2.p1.2.m2.1.1.3.cmml" xref="S4.I1.ix3.I1.i2.p1.2.m2.1.1.3">hi</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.I1.ix3.I1.i2.p1.2.m2.1c">\sigma_{\rm hi}</annotation><annotation encoding="application/x-llamapun" id="S4.I1.ix3.I1.i2.p1.2.m2.1d">italic_σ start_POSTSUBSCRIPT roman_hi end_POSTSUBSCRIPT</annotation></semantics></math> are the minimum and maximum bounds
on the large standard deviations, respectively (for the
fat sides of the ellipsoid).</p>
</div>
</li>
<li id="S4.I1.ix3.I1.i3" class="ltx_item" style="list-style-type:none;">
<span class="ltx_tag ltx_tag_item"><span id="S4.I1.ix3.I1.i3.1.1.1" class="ltx_text ltx_font_bold">•</span></span> 
<div id="S4.I1.ix3.I1.i3.p1" class="ltx_para">
<p id="S4.I1.ix3.I1.i3.p1.1" class="ltx_p"><math id="S4.I1.ix3.I1.i3.p1.1.m1.1" class="ltx_Math" alttext="\sigma_{\rm thin}" display="inline"><semantics id="S4.I1.ix3.I1.i3.p1.1.m1.1a"><msub id="S4.I1.ix3.I1.i3.p1.1.m1.1.1" xref="S4.I1.ix3.I1.i3.p1.1.m1.1.1.cmml"><mi id="S4.I1.ix3.I1.i3.p1.1.m1.1.1.2" xref="S4.I1.ix3.I1.i3.p1.1.m1.1.1.2.cmml">σ</mi><mi id="S4.I1.ix3.I1.i3.p1.1.m1.1.1.3" xref="S4.I1.ix3.I1.i3.p1.1.m1.1.1.3.cmml">thin</mi></msub><annotation-xml encoding="MathML-Content" id="S4.I1.ix3.I1.i3.p1.1.m1.1b"><apply id="S4.I1.ix3.I1.i3.p1.1.m1.1.1.cmml" xref="S4.I1.ix3.I1.i3.p1.1.m1.1.1"><csymbol cd="ambiguous" id="S4.I1.ix3.I1.i3.p1.1.m1.1.1.1.cmml" xref="S4.I1.ix3.I1.i3.p1.1.m1.1.1">subscript</csymbol><ci id="S4.I1.ix3.I1.i3.p1.1.m1.1.1.2.cmml" xref="S4.I1.ix3.I1.i3.p1.1.m1.1.1.2">𝜎</ci><ci id="S4.I1.ix3.I1.i3.p1.1.m1.1.1.3.cmml" xref="S4.I1.ix3.I1.i3.p1.1.m1.1.1.3">thin</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.I1.ix3.I1.i3.p1.1.m1.1c">\sigma_{\rm thin}</annotation><annotation encoding="application/x-llamapun" id="S4.I1.ix3.I1.i3.p1.1.m1.1d">italic_σ start_POSTSUBSCRIPT roman_thin end_POSTSUBSCRIPT</annotation></semantics></math> is the small standard deviation (for the thin
sides of the ellipsoid).</p>
</div>
</li>
</ul>
<p id="S4.I1.ix3.p1.7" class="ltx_p">Cluster centers are chosen as in the clustered-gaussian
distribution. For each color class, a random number <math id="S4.I1.ix3.p1.2.m1.1" class="ltx_Math" alttext="d^{\prime}" display="inline"><semantics id="S4.I1.ix3.p1.2.m1.1a"><msup id="S4.I1.ix3.p1.2.m1.1.1" xref="S4.I1.ix3.p1.2.m1.1.1.cmml"><mi id="S4.I1.ix3.p1.2.m1.1.1.2" xref="S4.I1.ix3.p1.2.m1.1.1.2.cmml">d</mi><mo id="S4.I1.ix3.p1.2.m1.1.1.3" xref="S4.I1.ix3.p1.2.m1.1.1.3.cmml">′</mo></msup><annotation-xml encoding="MathML-Content" id="S4.I1.ix3.p1.2.m1.1b"><apply id="S4.I1.ix3.p1.2.m1.1.1.cmml" xref="S4.I1.ix3.p1.2.m1.1.1"><csymbol cd="ambiguous" id="S4.I1.ix3.p1.2.m1.1.1.1.cmml" xref="S4.I1.ix3.p1.2.m1.1.1">superscript</csymbol><ci id="S4.I1.ix3.p1.2.m1.1.1.2.cmml" xref="S4.I1.ix3.p1.2.m1.1.1.2">𝑑</ci><ci id="S4.I1.ix3.p1.2.m1.1.1.3.cmml" xref="S4.I1.ix3.p1.2.m1.1.1.3">′</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.I1.ix3.p1.2.m1.1c">d^{\prime}</annotation><annotation encoding="application/x-llamapun" id="S4.I1.ix3.p1.2.m1.1d">italic_d start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT</annotation></semantics></math>
between <math id="S4.I1.ix3.p1.3.m2.1" class="ltx_Math" alttext="1" display="inline"><semantics id="S4.I1.ix3.p1.3.m2.1a"><mn id="S4.I1.ix3.p1.3.m2.1.1" xref="S4.I1.ix3.p1.3.m2.1.1.cmml">1</mn><annotation-xml encoding="MathML-Content" id="S4.I1.ix3.p1.3.m2.1b"><cn type="integer" id="S4.I1.ix3.p1.3.m2.1.1.cmml" xref="S4.I1.ix3.p1.3.m2.1.1">1</cn></annotation-xml><annotation encoding="application/x-tex" id="S4.I1.ix3.p1.3.m2.1c">1</annotation><annotation encoding="application/x-llamapun" id="S4.I1.ix3.p1.3.m2.1d">1</annotation></semantics></math> and <math id="S4.I1.ix3.p1.4.m3.1" class="ltx_Math" alttext="d_{\rm max}" display="inline"><semantics id="S4.I1.ix3.p1.4.m3.1a"><msub id="S4.I1.ix3.p1.4.m3.1.1" xref="S4.I1.ix3.p1.4.m3.1.1.cmml"><mi id="S4.I1.ix3.p1.4.m3.1.1.2" xref="S4.I1.ix3.p1.4.m3.1.1.2.cmml">d</mi><mi id="S4.I1.ix3.p1.4.m3.1.1.3" xref="S4.I1.ix3.p1.4.m3.1.1.3.cmml">max</mi></msub><annotation-xml encoding="MathML-Content" id="S4.I1.ix3.p1.4.m3.1b"><apply id="S4.I1.ix3.p1.4.m3.1.1.cmml" xref="S4.I1.ix3.p1.4.m3.1.1"><csymbol cd="ambiguous" id="S4.I1.ix3.p1.4.m3.1.1.1.cmml" xref="S4.I1.ix3.p1.4.m3.1.1">subscript</csymbol><ci id="S4.I1.ix3.p1.4.m3.1.1.2.cmml" xref="S4.I1.ix3.p1.4.m3.1.1.2">𝑑</ci><ci id="S4.I1.ix3.p1.4.m3.1.1.3.cmml" xref="S4.I1.ix3.p1.4.m3.1.1.3">max</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.I1.ix3.p1.4.m3.1c">d_{\rm max}</annotation><annotation encoding="application/x-llamapun" id="S4.I1.ix3.p1.4.m3.1d">italic_d start_POSTSUBSCRIPT roman_max end_POSTSUBSCRIPT</annotation></semantics></math> is generated, indicating the number of
fat dimensions. Then <math id="S4.I1.ix3.p1.5.m4.1" class="ltx_Math" alttext="d^{\prime}" display="inline"><semantics id="S4.I1.ix3.p1.5.m4.1a"><msup id="S4.I1.ix3.p1.5.m4.1.1" xref="S4.I1.ix3.p1.5.m4.1.1.cmml"><mi id="S4.I1.ix3.p1.5.m4.1.1.2" xref="S4.I1.ix3.p1.5.m4.1.1.2.cmml">d</mi><mo id="S4.I1.ix3.p1.5.m4.1.1.3" xref="S4.I1.ix3.p1.5.m4.1.1.3.cmml">′</mo></msup><annotation-xml encoding="MathML-Content" id="S4.I1.ix3.p1.5.m4.1b"><apply id="S4.I1.ix3.p1.5.m4.1.1.cmml" xref="S4.I1.ix3.p1.5.m4.1.1"><csymbol cd="ambiguous" id="S4.I1.ix3.p1.5.m4.1.1.1.cmml" xref="S4.I1.ix3.p1.5.m4.1.1">superscript</csymbol><ci id="S4.I1.ix3.p1.5.m4.1.1.2.cmml" xref="S4.I1.ix3.p1.5.m4.1.1.2">𝑑</ci><ci id="S4.I1.ix3.p1.5.m4.1.1.3.cmml" xref="S4.I1.ix3.p1.5.m4.1.1.3">′</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.I1.ix3.p1.5.m4.1c">d^{\prime}</annotation><annotation encoding="application/x-llamapun" id="S4.I1.ix3.p1.5.m4.1d">italic_d start_POSTSUPERSCRIPT ′ end_POSTSUPERSCRIPT</annotation></semantics></math> dimensions are chosen at random to be
fat dimensions of the ellipse. For each fat dimension the
standard deviation for this coordinate is chosen uniformly from
<math id="S4.I1.ix3.p1.6.m5.2" class="ltx_Math" alttext="[\sigma_{\rm lo},\sigma_{\rm hi}]" display="inline"><semantics id="S4.I1.ix3.p1.6.m5.2a"><mrow id="S4.I1.ix3.p1.6.m5.2.2.2" xref="S4.I1.ix3.p1.6.m5.2.2.3.cmml"><mo stretchy="false" id="S4.I1.ix3.p1.6.m5.2.2.2.3" xref="S4.I1.ix3.p1.6.m5.2.2.3.cmml">[</mo><msub id="S4.I1.ix3.p1.6.m5.1.1.1.1" xref="S4.I1.ix3.p1.6.m5.1.1.1.1.cmml"><mi id="S4.I1.ix3.p1.6.m5.1.1.1.1.2" xref="S4.I1.ix3.p1.6.m5.1.1.1.1.2.cmml">σ</mi><mi id="S4.I1.ix3.p1.6.m5.1.1.1.1.3" xref="S4.I1.ix3.p1.6.m5.1.1.1.1.3.cmml">lo</mi></msub><mo id="S4.I1.ix3.p1.6.m5.2.2.2.4" xref="S4.I1.ix3.p1.6.m5.2.2.3.cmml">,</mo><msub id="S4.I1.ix3.p1.6.m5.2.2.2.2" xref="S4.I1.ix3.p1.6.m5.2.2.2.2.cmml"><mi id="S4.I1.ix3.p1.6.m5.2.2.2.2.2" xref="S4.I1.ix3.p1.6.m5.2.2.2.2.2.cmml">σ</mi><mi id="S4.I1.ix3.p1.6.m5.2.2.2.2.3" xref="S4.I1.ix3.p1.6.m5.2.2.2.2.3.cmml">hi</mi></msub><mo stretchy="false" id="S4.I1.ix3.p1.6.m5.2.2.2.5" xref="S4.I1.ix3.p1.6.m5.2.2.3.cmml">]</mo></mrow><annotation-xml encoding="MathML-Content" id="S4.I1.ix3.p1.6.m5.2b"><interval closure="closed" id="S4.I1.ix3.p1.6.m5.2.2.3.cmml" xref="S4.I1.ix3.p1.6.m5.2.2.2"><apply id="S4.I1.ix3.p1.6.m5.1.1.1.1.cmml" xref="S4.I1.ix3.p1.6.m5.1.1.1.1"><csymbol cd="ambiguous" id="S4.I1.ix3.p1.6.m5.1.1.1.1.1.cmml" xref="S4.I1.ix3.p1.6.m5.1.1.1.1">subscript</csymbol><ci id="S4.I1.ix3.p1.6.m5.1.1.1.1.2.cmml" xref="S4.I1.ix3.p1.6.m5.1.1.1.1.2">𝜎</ci><ci id="S4.I1.ix3.p1.6.m5.1.1.1.1.3.cmml" xref="S4.I1.ix3.p1.6.m5.1.1.1.1.3">lo</ci></apply><apply id="S4.I1.ix3.p1.6.m5.2.2.2.2.cmml" xref="S4.I1.ix3.p1.6.m5.2.2.2.2"><csymbol cd="ambiguous" id="S4.I1.ix3.p1.6.m5.2.2.2.2.1.cmml" xref="S4.I1.ix3.p1.6.m5.2.2.2.2">subscript</csymbol><ci id="S4.I1.ix3.p1.6.m5.2.2.2.2.2.cmml" xref="S4.I1.ix3.p1.6.m5.2.2.2.2.2">𝜎</ci><ci id="S4.I1.ix3.p1.6.m5.2.2.2.2.3.cmml" xref="S4.I1.ix3.p1.6.m5.2.2.2.2.3">hi</ci></apply></interval></annotation-xml><annotation encoding="application/x-tex" id="S4.I1.ix3.p1.6.m5.2c">[\sigma_{\rm lo},\sigma_{\rm hi}]</annotation><annotation encoding="application/x-llamapun" id="S4.I1.ix3.p1.6.m5.2d">[ italic_σ start_POSTSUBSCRIPT roman_lo end_POSTSUBSCRIPT , italic_σ start_POSTSUBSCRIPT roman_hi end_POSTSUBSCRIPT ]</annotation></semantics></math>, and for each thin dimension the standard
deviation is set to <math id="S4.I1.ix3.p1.7.m6.1" class="ltx_Math" alttext="\sigma_{\rm thin}" display="inline"><semantics id="S4.I1.ix3.p1.7.m6.1a"><msub id="S4.I1.ix3.p1.7.m6.1.1" xref="S4.I1.ix3.p1.7.m6.1.1.cmml"><mi id="S4.I1.ix3.p1.7.m6.1.1.2" xref="S4.I1.ix3.p1.7.m6.1.1.2.cmml">σ</mi><mi id="S4.I1.ix3.p1.7.m6.1.1.3" xref="S4.I1.ix3.p1.7.m6.1.1.3.cmml">thin</mi></msub><annotation-xml encoding="MathML-Content" id="S4.I1.ix3.p1.7.m6.1b"><apply id="S4.I1.ix3.p1.7.m6.1.1.cmml" xref="S4.I1.ix3.p1.7.m6.1.1"><csymbol cd="ambiguous" id="S4.I1.ix3.p1.7.m6.1.1.1.cmml" xref="S4.I1.ix3.p1.7.m6.1.1">subscript</csymbol><ci id="S4.I1.ix3.p1.7.m6.1.1.2.cmml" xref="S4.I1.ix3.p1.7.m6.1.1.2">𝜎</ci><ci id="S4.I1.ix3.p1.7.m6.1.1.3.cmml" xref="S4.I1.ix3.p1.7.m6.1.1.3">thin</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.I1.ix3.p1.7.m6.1c">\sigma_{\rm thin}</annotation><annotation encoding="application/x-llamapun" id="S4.I1.ix3.p1.7.m6.1d">italic_σ start_POSTSUBSCRIPT roman_thin end_POSTSUBSCRIPT</annotation></semantics></math>. The points are then generated
by the same process as clustered-gaussian, but using these
various standard deviations.</p>
</div>
</dd>
<dt id="S4.I1.ix4" class="ltx_item"><span class="ltx_tag ltx_tag_item"><span id="S4.I1.ix4.1.1.1" class="ltx_text ltx_font_bold">Clustered-ellipsoids:</span></span></dt>
<dd class="ltx_item">
<div id="S4.I1.ix4.p1" class="ltx_para">
<p id="S4.I1.ix4.p1.2" class="ltx_p">This distribution is the result of applying <math id="S4.I1.ix4.p1.1.m1.1" class="ltx_Math" alttext="d" display="inline"><semantics id="S4.I1.ix4.p1.1.m1.1a"><mi id="S4.I1.ix4.p1.1.m1.1.1" xref="S4.I1.ix4.p1.1.m1.1.1.cmml">d</mi><annotation-xml encoding="MathML-Content" id="S4.I1.ix4.p1.1.m1.1b"><ci id="S4.I1.ix4.p1.1.m1.1.1.cmml" xref="S4.I1.ix4.p1.1.m1.1.1">𝑑</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.I1.ix4.p1.1.m1.1c">d</annotation><annotation encoding="application/x-llamapun" id="S4.I1.ix4.p1.1.m1.1d">italic_d</annotation></semantics></math> random rotation
transformations to the points of each cluster about its center.
Each cluster is rotated by a different set of rotations. Each
rotation is through a uniformly distributed angle in the range
<math id="S4.I1.ix4.p1.2.m2.2" class="ltx_Math" alttext="[0,\pi/2]" display="inline"><semantics id="S4.I1.ix4.p1.2.m2.2a"><mrow id="S4.I1.ix4.p1.2.m2.2.2.1" xref="S4.I1.ix4.p1.2.m2.2.2.2.cmml"><mo stretchy="false" id="S4.I1.ix4.p1.2.m2.2.2.1.2" xref="S4.I1.ix4.p1.2.m2.2.2.2.cmml">[</mo><mn id="S4.I1.ix4.p1.2.m2.1.1" xref="S4.I1.ix4.p1.2.m2.1.1.cmml">0</mn><mo id="S4.I1.ix4.p1.2.m2.2.2.1.3" xref="S4.I1.ix4.p1.2.m2.2.2.2.cmml">,</mo><mrow id="S4.I1.ix4.p1.2.m2.2.2.1.1" xref="S4.I1.ix4.p1.2.m2.2.2.1.1.cmml"><mi id="S4.I1.ix4.p1.2.m2.2.2.1.1.2" xref="S4.I1.ix4.p1.2.m2.2.2.1.1.2.cmml">π</mi><mo id="S4.I1.ix4.p1.2.m2.2.2.1.1.1" xref="S4.I1.ix4.p1.2.m2.2.2.1.1.1.cmml">/</mo><mn id="S4.I1.ix4.p1.2.m2.2.2.1.1.3" xref="S4.I1.ix4.p1.2.m2.2.2.1.1.3.cmml">2</mn></mrow><mo stretchy="false" id="S4.I1.ix4.p1.2.m2.2.2.1.4" xref="S4.I1.ix4.p1.2.m2.2.2.2.cmml">]</mo></mrow><annotation-xml encoding="MathML-Content" id="S4.I1.ix4.p1.2.m2.2b"><interval closure="closed" id="S4.I1.ix4.p1.2.m2.2.2.2.cmml" xref="S4.I1.ix4.p1.2.m2.2.2.1"><cn type="integer" id="S4.I1.ix4.p1.2.m2.1.1.cmml" xref="S4.I1.ix4.p1.2.m2.1.1">0</cn><apply id="S4.I1.ix4.p1.2.m2.2.2.1.1.cmml" xref="S4.I1.ix4.p1.2.m2.2.2.1.1"><divide id="S4.I1.ix4.p1.2.m2.2.2.1.1.1.cmml" xref="S4.I1.ix4.p1.2.m2.2.2.1.1.1"></divide><ci id="S4.I1.ix4.p1.2.m2.2.2.1.1.2.cmml" xref="S4.I1.ix4.p1.2.m2.2.2.1.1.2">𝜋</ci><cn type="integer" id="S4.I1.ix4.p1.2.m2.2.2.1.1.3.cmml" xref="S4.I1.ix4.p1.2.m2.2.2.1.1.3">2</cn></apply></interval></annotation-xml><annotation encoding="application/x-tex" id="S4.I1.ix4.p1.2.m2.2c">[0,\pi/2]</annotation><annotation encoding="application/x-llamapun" id="S4.I1.ix4.p1.2.m2.2d">[ 0 , italic_π / 2 ]</annotation></semantics></math> with respect to two randomly chosen dimensions.</p>
</div>
</dd>
</dl>
</div>
<div id="S4.SS1.p3" class="ltx_para">
<p id="S4.SS1.p3.6" class="ltx_p">In our experiments involving both clustered-orthogonal-ellipsoids and
clustered-ellipsoids, we set the number of clusters to 5, <math id="S4.SS1.p3.1.m1.1" class="ltx_Math" alttext="d_{\rm max}=10" display="inline"><semantics id="S4.SS1.p3.1.m1.1a"><mrow id="S4.SS1.p3.1.m1.1.1" xref="S4.SS1.p3.1.m1.1.1.cmml"><msub id="S4.SS1.p3.1.m1.1.1.2" xref="S4.SS1.p3.1.m1.1.1.2.cmml"><mi id="S4.SS1.p3.1.m1.1.1.2.2" xref="S4.SS1.p3.1.m1.1.1.2.2.cmml">d</mi><mi id="S4.SS1.p3.1.m1.1.1.2.3" xref="S4.SS1.p3.1.m1.1.1.2.3.cmml">max</mi></msub><mo id="S4.SS1.p3.1.m1.1.1.1" xref="S4.SS1.p3.1.m1.1.1.1.cmml">=</mo><mn id="S4.SS1.p3.1.m1.1.1.3" xref="S4.SS1.p3.1.m1.1.1.3.cmml">10</mn></mrow><annotation-xml encoding="MathML-Content" id="S4.SS1.p3.1.m1.1b"><apply id="S4.SS1.p3.1.m1.1.1.cmml" xref="S4.SS1.p3.1.m1.1.1"><eq id="S4.SS1.p3.1.m1.1.1.1.cmml" xref="S4.SS1.p3.1.m1.1.1.1"></eq><apply id="S4.SS1.p3.1.m1.1.1.2.cmml" xref="S4.SS1.p3.1.m1.1.1.2"><csymbol cd="ambiguous" id="S4.SS1.p3.1.m1.1.1.2.1.cmml" xref="S4.SS1.p3.1.m1.1.1.2">subscript</csymbol><ci id="S4.SS1.p3.1.m1.1.1.2.2.cmml" xref="S4.SS1.p3.1.m1.1.1.2.2">𝑑</ci><ci id="S4.SS1.p3.1.m1.1.1.2.3.cmml" xref="S4.SS1.p3.1.m1.1.1.2.3">max</ci></apply><cn type="integer" id="S4.SS1.p3.1.m1.1.1.3.cmml" xref="S4.SS1.p3.1.m1.1.1.3">10</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS1.p3.1.m1.1c">d_{\rm max}=10</annotation><annotation encoding="application/x-llamapun" id="S4.SS1.p3.1.m1.1d">italic_d start_POSTSUBSCRIPT roman_max end_POSTSUBSCRIPT = 10</annotation></semantics></math>,
<math id="S4.SS1.p3.2.m2.1" class="ltx_Math" alttext="\sigma_{\rm lo}=\sigma_{\rm hi}=0.3" display="inline"><semantics id="S4.SS1.p3.2.m2.1a"><mrow id="S4.SS1.p3.2.m2.1.1" xref="S4.SS1.p3.2.m2.1.1.cmml"><msub id="S4.SS1.p3.2.m2.1.1.2" xref="S4.SS1.p3.2.m2.1.1.2.cmml"><mi id="S4.SS1.p3.2.m2.1.1.2.2" xref="S4.SS1.p3.2.m2.1.1.2.2.cmml">σ</mi><mi id="S4.SS1.p3.2.m2.1.1.2.3" xref="S4.SS1.p3.2.m2.1.1.2.3.cmml">lo</mi></msub><mo id="S4.SS1.p3.2.m2.1.1.3" xref="S4.SS1.p3.2.m2.1.1.3.cmml">=</mo><msub id="S4.SS1.p3.2.m2.1.1.4" xref="S4.SS1.p3.2.m2.1.1.4.cmml"><mi id="S4.SS1.p3.2.m2.1.1.4.2" xref="S4.SS1.p3.2.m2.1.1.4.2.cmml">σ</mi><mi id="S4.SS1.p3.2.m2.1.1.4.3" xref="S4.SS1.p3.2.m2.1.1.4.3.cmml">hi</mi></msub><mo id="S4.SS1.p3.2.m2.1.1.5" xref="S4.SS1.p3.2.m2.1.1.5.cmml">=</mo><mn id="S4.SS1.p3.2.m2.1.1.6" xref="S4.SS1.p3.2.m2.1.1.6.cmml">0.3</mn></mrow><annotation-xml encoding="MathML-Content" id="S4.SS1.p3.2.m2.1b"><apply id="S4.SS1.p3.2.m2.1.1.cmml" xref="S4.SS1.p3.2.m2.1.1"><and id="S4.SS1.p3.2.m2.1.1a.cmml" xref="S4.SS1.p3.2.m2.1.1"></and><apply id="S4.SS1.p3.2.m2.1.1b.cmml" xref="S4.SS1.p3.2.m2.1.1"><eq id="S4.SS1.p3.2.m2.1.1.3.cmml" xref="S4.SS1.p3.2.m2.1.1.3"></eq><apply id="S4.SS1.p3.2.m2.1.1.2.cmml" xref="S4.SS1.p3.2.m2.1.1.2"><csymbol cd="ambiguous" id="S4.SS1.p3.2.m2.1.1.2.1.cmml" xref="S4.SS1.p3.2.m2.1.1.2">subscript</csymbol><ci id="S4.SS1.p3.2.m2.1.1.2.2.cmml" xref="S4.SS1.p3.2.m2.1.1.2.2">𝜎</ci><ci id="S4.SS1.p3.2.m2.1.1.2.3.cmml" xref="S4.SS1.p3.2.m2.1.1.2.3">lo</ci></apply><apply id="S4.SS1.p3.2.m2.1.1.4.cmml" xref="S4.SS1.p3.2.m2.1.1.4"><csymbol cd="ambiguous" id="S4.SS1.p3.2.m2.1.1.4.1.cmml" xref="S4.SS1.p3.2.m2.1.1.4">subscript</csymbol><ci id="S4.SS1.p3.2.m2.1.1.4.2.cmml" xref="S4.SS1.p3.2.m2.1.1.4.2">𝜎</ci><ci id="S4.SS1.p3.2.m2.1.1.4.3.cmml" xref="S4.SS1.p3.2.m2.1.1.4.3">hi</ci></apply></apply><apply id="S4.SS1.p3.2.m2.1.1c.cmml" xref="S4.SS1.p3.2.m2.1.1"><eq id="S4.SS1.p3.2.m2.1.1.5.cmml" xref="S4.SS1.p3.2.m2.1.1.5"></eq><share href="#S4.SS1.p3.2.m2.1.1.4.cmml" id="S4.SS1.p3.2.m2.1.1d.cmml" xref="S4.SS1.p3.2.m2.1.1"></share><cn type="float" id="S4.SS1.p3.2.m2.1.1.6.cmml" xref="S4.SS1.p3.2.m2.1.1.6">0.3</cn></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS1.p3.2.m2.1c">\sigma_{\rm lo}=\sigma_{\rm hi}=0.3</annotation><annotation encoding="application/x-llamapun" id="S4.SS1.p3.2.m2.1d">italic_σ start_POSTSUBSCRIPT roman_lo end_POSTSUBSCRIPT = italic_σ start_POSTSUBSCRIPT roman_hi end_POSTSUBSCRIPT = 0.3</annotation></semantics></math>, and <math id="S4.SS1.p3.3.m3.1" class="ltx_Math" alttext="\sigma_{\rm thin}" display="inline"><semantics id="S4.SS1.p3.3.m3.1a"><msub id="S4.SS1.p3.3.m3.1.1" xref="S4.SS1.p3.3.m3.1.1.cmml"><mi id="S4.SS1.p3.3.m3.1.1.2" xref="S4.SS1.p3.3.m3.1.1.2.cmml">σ</mi><mi id="S4.SS1.p3.3.m3.1.1.3" xref="S4.SS1.p3.3.m3.1.1.3.cmml">thin</mi></msub><annotation-xml encoding="MathML-Content" id="S4.SS1.p3.3.m3.1b"><apply id="S4.SS1.p3.3.m3.1.1.cmml" xref="S4.SS1.p3.3.m3.1.1"><csymbol cd="ambiguous" id="S4.SS1.p3.3.m3.1.1.1.cmml" xref="S4.SS1.p3.3.m3.1.1">subscript</csymbol><ci id="S4.SS1.p3.3.m3.1.1.2.cmml" xref="S4.SS1.p3.3.m3.1.1.2">𝜎</ci><ci id="S4.SS1.p3.3.m3.1.1.3.cmml" xref="S4.SS1.p3.3.m3.1.1.3">thin</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS1.p3.3.m3.1c">\sigma_{\rm thin}</annotation><annotation encoding="application/x-llamapun" id="S4.SS1.p3.3.m3.1d">italic_σ start_POSTSUBSCRIPT roman_thin end_POSTSUBSCRIPT</annotation></semantics></math> varied from <math id="S4.SS1.p3.4.m4.1" class="ltx_Math" alttext="0.03" display="inline"><semantics id="S4.SS1.p3.4.m4.1a"><mn id="S4.SS1.p3.4.m4.1.1" xref="S4.SS1.p3.4.m4.1.1.cmml">0.03</mn><annotation-xml encoding="MathML-Content" id="S4.SS1.p3.4.m4.1b"><cn type="float" id="S4.SS1.p3.4.m4.1.1.cmml" xref="S4.SS1.p3.4.m4.1.1">0.03</cn></annotation-xml><annotation encoding="application/x-tex" id="S4.SS1.p3.4.m4.1c">0.03</annotation><annotation encoding="application/x-llamapun" id="S4.SS1.p3.4.m4.1d">0.03</annotation></semantics></math> to <math id="S4.SS1.p3.5.m5.1" class="ltx_Math" alttext="0.3" display="inline"><semantics id="S4.SS1.p3.5.m5.1a"><mn id="S4.SS1.p3.5.m5.1.1" xref="S4.SS1.p3.5.m5.1.1.cmml">0.3</mn><annotation-xml encoding="MathML-Content" id="S4.SS1.p3.5.m5.1b"><cn type="float" id="S4.SS1.p3.5.m5.1.1.cmml" xref="S4.SS1.p3.5.m5.1.1">0.3</cn></annotation-xml><annotation encoding="application/x-tex" id="S4.SS1.p3.5.m5.1c">0.3</annotation><annotation encoding="application/x-llamapun" id="S4.SS1.p3.5.m5.1d">0.3</annotation></semantics></math>.
Thus, for low values of <math id="S4.SS1.p3.6.m6.1" class="ltx_Math" alttext="\sigma_{\rm thin}" display="inline"><semantics id="S4.SS1.p3.6.m6.1a"><msub id="S4.SS1.p3.6.m6.1.1" xref="S4.SS1.p3.6.m6.1.1.cmml"><mi id="S4.SS1.p3.6.m6.1.1.2" xref="S4.SS1.p3.6.m6.1.1.2.cmml">σ</mi><mi id="S4.SS1.p3.6.m6.1.1.3" xref="S4.SS1.p3.6.m6.1.1.3.cmml">thin</mi></msub><annotation-xml encoding="MathML-Content" id="S4.SS1.p3.6.m6.1b"><apply id="S4.SS1.p3.6.m6.1.1.cmml" xref="S4.SS1.p3.6.m6.1.1"><csymbol cd="ambiguous" id="S4.SS1.p3.6.m6.1.1.1.cmml" xref="S4.SS1.p3.6.m6.1.1">subscript</csymbol><ci id="S4.SS1.p3.6.m6.1.1.2.cmml" xref="S4.SS1.p3.6.m6.1.1.2">𝜎</ci><ci id="S4.SS1.p3.6.m6.1.1.3.cmml" xref="S4.SS1.p3.6.m6.1.1.3">thin</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS1.p3.6.m6.1c">\sigma_{\rm thin}</annotation><annotation encoding="application/x-llamapun" id="S4.SS1.p3.6.m6.1d">italic_σ start_POSTSUBSCRIPT roman_thin end_POSTSUBSCRIPT</annotation></semantics></math> the ellipsoids are relatively flat,
and for high values this becomes equivalent to a clustered-gaussian
distribution with standard deviation of 0.3.</p>
</div>
</section>
<section id="S4.SS2" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">4.2 </span>Data and Query Points from the Same Distribution</h3>

<div id="S4.SS2.p1" class="ltx_para">
<p id="S4.SS2.p1.5" class="ltx_p">For our first set of experiments, we considered data and query points
from the same clustered distributions. We considered both
clustered-orthogonal-ellipsoids and clustered-ellipsoid distributions in
Figs. <a href="#S6.F4" title="Figure 4 ‣ Analysis of Approximate Nearest Neighbor Searching with Clustered Point SetsThe support of the National Science Foundation under grant CCR–9712379 is gratefully acknowledged." class="ltx_ref"><span class="ltx_text ltx_ref_tag">4</span></a> and <a href="#S6.F5" title="Figure 5 ‣ Analysis of Approximate Nearest Neighbor Searching with Clustered Point SetsThe support of the National Science Foundation under grant CCR–9712379 is gratefully acknowledged." class="ltx_ref"><span class="ltx_text ltx_ref_tag">5</span></a>, respectively. The three
different graphs are for (a) <math id="S4.SS2.p1.1.m1.1" class="ltx_Math" alttext="\epsilon=1" display="inline"><semantics id="S4.SS2.p1.1.m1.1a"><mrow id="S4.SS2.p1.1.m1.1.1" xref="S4.SS2.p1.1.m1.1.1.cmml"><mi id="S4.SS2.p1.1.m1.1.1.2" xref="S4.SS2.p1.1.m1.1.1.2.cmml">ϵ</mi><mo id="S4.SS2.p1.1.m1.1.1.1" xref="S4.SS2.p1.1.m1.1.1.1.cmml">=</mo><mn id="S4.SS2.p1.1.m1.1.1.3" xref="S4.SS2.p1.1.m1.1.1.3.cmml">1</mn></mrow><annotation-xml encoding="MathML-Content" id="S4.SS2.p1.1.m1.1b"><apply id="S4.SS2.p1.1.m1.1.1.cmml" xref="S4.SS2.p1.1.m1.1.1"><eq id="S4.SS2.p1.1.m1.1.1.1.cmml" xref="S4.SS2.p1.1.m1.1.1.1"></eq><ci id="S4.SS2.p1.1.m1.1.1.2.cmml" xref="S4.SS2.p1.1.m1.1.1.2">italic-ϵ</ci><cn type="integer" id="S4.SS2.p1.1.m1.1.1.3.cmml" xref="S4.SS2.p1.1.m1.1.1.3">1</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.p1.1.m1.1c">\epsilon=1</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.p1.1.m1.1d">italic_ϵ = 1</annotation></semantics></math>, (b) <math id="S4.SS2.p1.2.m2.1" class="ltx_Math" alttext="\epsilon=2" display="inline"><semantics id="S4.SS2.p1.2.m2.1a"><mrow id="S4.SS2.p1.2.m2.1.1" xref="S4.SS2.p1.2.m2.1.1.cmml"><mi id="S4.SS2.p1.2.m2.1.1.2" xref="S4.SS2.p1.2.m2.1.1.2.cmml">ϵ</mi><mo id="S4.SS2.p1.2.m2.1.1.1" xref="S4.SS2.p1.2.m2.1.1.1.cmml">=</mo><mn id="S4.SS2.p1.2.m2.1.1.3" xref="S4.SS2.p1.2.m2.1.1.3.cmml">2</mn></mrow><annotation-xml encoding="MathML-Content" id="S4.SS2.p1.2.m2.1b"><apply id="S4.SS2.p1.2.m2.1.1.cmml" xref="S4.SS2.p1.2.m2.1.1"><eq id="S4.SS2.p1.2.m2.1.1.1.cmml" xref="S4.SS2.p1.2.m2.1.1.1"></eq><ci id="S4.SS2.p1.2.m2.1.1.2.cmml" xref="S4.SS2.p1.2.m2.1.1.2">italic-ϵ</ci><cn type="integer" id="S4.SS2.p1.2.m2.1.1.3.cmml" xref="S4.SS2.p1.2.m2.1.1.3">2</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.p1.2.m2.1c">\epsilon=2</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.p1.2.m2.1d">italic_ϵ = 2</annotation></semantics></math>, and (c)
<math id="S4.SS2.p1.3.m3.1" class="ltx_Math" alttext="\epsilon=3" display="inline"><semantics id="S4.SS2.p1.3.m3.1a"><mrow id="S4.SS2.p1.3.m3.1.1" xref="S4.SS2.p1.3.m3.1.1.cmml"><mi id="S4.SS2.p1.3.m3.1.1.2" xref="S4.SS2.p1.3.m3.1.1.2.cmml">ϵ</mi><mo id="S4.SS2.p1.3.m3.1.1.1" xref="S4.SS2.p1.3.m3.1.1.1.cmml">=</mo><mn id="S4.SS2.p1.3.m3.1.1.3" xref="S4.SS2.p1.3.m3.1.1.3.cmml">3</mn></mrow><annotation-xml encoding="MathML-Content" id="S4.SS2.p1.3.m3.1b"><apply id="S4.SS2.p1.3.m3.1.1.cmml" xref="S4.SS2.p1.3.m3.1.1"><eq id="S4.SS2.p1.3.m3.1.1.1.cmml" xref="S4.SS2.p1.3.m3.1.1.1"></eq><ci id="S4.SS2.p1.3.m3.1.1.2.cmml" xref="S4.SS2.p1.3.m3.1.1.2">italic-ϵ</ci><cn type="integer" id="S4.SS2.p1.3.m3.1.1.3.cmml" xref="S4.SS2.p1.3.m3.1.1.3">3</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.p1.3.m3.1c">\epsilon=3</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.p1.3.m3.1d">italic_ϵ = 3</annotation></semantics></math>. In all three cases the same clusters centers were
used. Note that the graphs do not share the same <math id="S4.SS2.p1.4.m4.1" class="ltx_Math" alttext="y" display="inline"><semantics id="S4.SS2.p1.4.m4.1a"><mi id="S4.SS2.p1.4.m4.1.1" xref="S4.SS2.p1.4.m4.1.1.cmml">y</mi><annotation-xml encoding="MathML-Content" id="S4.SS2.p1.4.m4.1b"><ci id="S4.SS2.p1.4.m4.1.1.cmml" xref="S4.SS2.p1.4.m4.1.1">𝑦</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.p1.4.m4.1c">y</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.p1.4.m4.1d">italic_y</annotation></semantics></math>-range,
and in particular the search algorithm performs significantly faster
as <math id="S4.SS2.p1.5.m5.1" class="ltx_Math" alttext="\epsilon" display="inline"><semantics id="S4.SS2.p1.5.m5.1a"><mi id="S4.SS2.p1.5.m5.1.1" xref="S4.SS2.p1.5.m5.1.1.cmml">ϵ</mi><annotation-xml encoding="MathML-Content" id="S4.SS2.p1.5.m5.1b"><ci id="S4.SS2.p1.5.m5.1.1.cmml" xref="S4.SS2.p1.5.m5.1.1">italic-ϵ</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.p1.5.m5.1c">\epsilon</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.p1.5.m5.1d">italic_ϵ</annotation></semantics></math> increases.</p>
</div>
<div id="S4.SS2.p2" class="ltx_para">
<p id="S4.SS2.p2.2" class="ltx_p">Observe that all of the splitting methods perform better when <math id="S4.SS2.p2.1.m1.1" class="ltx_Math" alttext="\sigma_{\rm thin}" display="inline"><semantics id="S4.SS2.p2.1.m1.1a"><msub id="S4.SS2.p2.1.m1.1.1" xref="S4.SS2.p2.1.m1.1.1.cmml"><mi id="S4.SS2.p2.1.m1.1.1.2" xref="S4.SS2.p2.1.m1.1.1.2.cmml">σ</mi><mi id="S4.SS2.p2.1.m1.1.1.3" xref="S4.SS2.p2.1.m1.1.1.3.cmml">thin</mi></msub><annotation-xml encoding="MathML-Content" id="S4.SS2.p2.1.m1.1b"><apply id="S4.SS2.p2.1.m1.1.1.cmml" xref="S4.SS2.p2.1.m1.1.1"><csymbol cd="ambiguous" id="S4.SS2.p2.1.m1.1.1.1.cmml" xref="S4.SS2.p2.1.m1.1.1">subscript</csymbol><ci id="S4.SS2.p2.1.m1.1.1.2.cmml" xref="S4.SS2.p2.1.m1.1.1.2">𝜎</ci><ci id="S4.SS2.p2.1.m1.1.1.3.cmml" xref="S4.SS2.p2.1.m1.1.1.3">thin</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.p2.1.m1.1c">\sigma_{\rm thin}</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.p2.1.m1.1d">italic_σ start_POSTSUBSCRIPT roman_thin end_POSTSUBSCRIPT</annotation></semantics></math>
is small, indicating that to some extent they exploit the fact that the
data points are clustered in lower dimensional subspaces. The relative
differences in running time were most noticeable for small values of
<math id="S4.SS2.p2.2.m2.1" class="ltx_Math" alttext="\sigma_{\rm thin}" display="inline"><semantics id="S4.SS2.p2.2.m2.1a"><msub id="S4.SS2.p2.2.m2.1.1" xref="S4.SS2.p2.2.m2.1.1.cmml"><mi id="S4.SS2.p2.2.m2.1.1.2" xref="S4.SS2.p2.2.m2.1.1.2.cmml">σ</mi><mi id="S4.SS2.p2.2.m2.1.1.3" xref="S4.SS2.p2.2.m2.1.1.3.cmml">thin</mi></msub><annotation-xml encoding="MathML-Content" id="S4.SS2.p2.2.m2.1b"><apply id="S4.SS2.p2.2.m2.1.1.cmml" xref="S4.SS2.p2.2.m2.1.1"><csymbol cd="ambiguous" id="S4.SS2.p2.2.m2.1.1.1.cmml" xref="S4.SS2.p2.2.m2.1.1">subscript</csymbol><ci id="S4.SS2.p2.2.m2.1.1.2.cmml" xref="S4.SS2.p2.2.m2.1.1.2">𝜎</ci><ci id="S4.SS2.p2.2.m2.1.1.3.cmml" xref="S4.SS2.p2.2.m2.1.1.3">thin</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.p2.2.m2.1c">\sigma_{\rm thin}</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.p2.2.m2.1d">italic_σ start_POSTSUBSCRIPT roman_thin end_POSTSUBSCRIPT</annotation></semantics></math>, and tended to diminish for larger values.</p>
</div>
<div id="S4.SS2.p3" class="ltx_para">
<p id="S4.SS2.p3.2" class="ltx_p">Although the minimum-ambiguity splitting method was designed for dealing
with data and query points from different distributions, we were
somewhat surprised that it actually performed the best of the three
methods in these cases. For small values of <math id="S4.SS2.p3.1.m1.1" class="ltx_Math" alttext="\sigma_{\rm thin}" display="inline"><semantics id="S4.SS2.p3.1.m1.1a"><msub id="S4.SS2.p3.1.m1.1.1" xref="S4.SS2.p3.1.m1.1.1.cmml"><mi id="S4.SS2.p3.1.m1.1.1.2" xref="S4.SS2.p3.1.m1.1.1.2.cmml">σ</mi><mi id="S4.SS2.p3.1.m1.1.1.3" xref="S4.SS2.p3.1.m1.1.1.3.cmml">thin</mi></msub><annotation-xml encoding="MathML-Content" id="S4.SS2.p3.1.m1.1b"><apply id="S4.SS2.p3.1.m1.1.1.cmml" xref="S4.SS2.p3.1.m1.1.1"><csymbol cd="ambiguous" id="S4.SS2.p3.1.m1.1.1.1.cmml" xref="S4.SS2.p3.1.m1.1.1">subscript</csymbol><ci id="S4.SS2.p3.1.m1.1.1.2.cmml" xref="S4.SS2.p3.1.m1.1.1.2">𝜎</ci><ci id="S4.SS2.p3.1.m1.1.1.3.cmml" xref="S4.SS2.p3.1.m1.1.1.3">thin</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.p3.1.m1.1c">\sigma_{\rm thin}</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.p3.1.m1.1d">italic_σ start_POSTSUBSCRIPT roman_thin end_POSTSUBSCRIPT</annotation></semantics></math> (when
low-dimensional clustering is strongest) its average running time
(measured as the number of noded visited in the tree) was typically from
30-50% lower than the standard splitting method, and over 50% lower than
the sliding-midpoint method. The standard splitting method typically
performed better than the sliding-midpoint method, but the difference
decreased to being insignificant (and sometimes a bit worse) as
<math id="S4.SS2.p3.2.m2.1" class="ltx_Math" alttext="\sigma_{\rm thin}" display="inline"><semantics id="S4.SS2.p3.2.m2.1a"><msub id="S4.SS2.p3.2.m2.1.1" xref="S4.SS2.p3.2.m2.1.1.cmml"><mi id="S4.SS2.p3.2.m2.1.1.2" xref="S4.SS2.p3.2.m2.1.1.2.cmml">σ</mi><mi id="S4.SS2.p3.2.m2.1.1.3" xref="S4.SS2.p3.2.m2.1.1.3.cmml">thin</mi></msub><annotation-xml encoding="MathML-Content" id="S4.SS2.p3.2.m2.1b"><apply id="S4.SS2.p3.2.m2.1.1.cmml" xref="S4.SS2.p3.2.m2.1.1"><csymbol cd="ambiguous" id="S4.SS2.p3.2.m2.1.1.1.cmml" xref="S4.SS2.p3.2.m2.1.1">subscript</csymbol><ci id="S4.SS2.p3.2.m2.1.1.2.cmml" xref="S4.SS2.p3.2.m2.1.1.2">𝜎</ci><ci id="S4.SS2.p3.2.m2.1.1.3.cmml" xref="S4.SS2.p3.2.m2.1.1.3">thin</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS2.p3.2.m2.1c">\sigma_{\rm thin}</annotation><annotation encoding="application/x-llamapun" id="S4.SS2.p3.2.m2.1d">italic_σ start_POSTSUBSCRIPT roman_thin end_POSTSUBSCRIPT</annotation></semantics></math> increased.</p>
</div>
</section>
<section id="S4.SS3" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">4.3 </span>Data and Query Points from Different Distributions</h3>

<div id="S4.SS3.p1" class="ltx_para">
<p id="S4.SS3.p1.4" class="ltx_p">For our second set of experiments, we considered data points from a
clustered distribution and query points from a uniform distribution.
This particular choice was motivated by the situation shown in
Fig. <a href="#S3.F1" title="Figure 1 ‣ 3.1 Sliding-Midpoint ‣ 3 Splitting Methods ‣ Analysis of Approximate Nearest Neighbor Searching with Clustered Point SetsThe support of the National Science Foundation under grant CCR–9712379 is gratefully acknowledged." class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a>, where the standard splitting method can produce
cells with high aspect ratios. For the data points we considered both
the clustered-orthogonal-ellipsoids and clustered-ellipsoid
distributions in Figs. <a href="#S6.F6" title="Figure 6 ‣ Analysis of Approximate Nearest Neighbor Searching with Clustered Point SetsThe support of the National Science Foundation under grant CCR–9712379 is gratefully acknowledged." class="ltx_ref"><span class="ltx_text ltx_ref_tag">6</span></a> and <a href="#S6.F7" title="Figure 7 ‣ Analysis of Approximate Nearest Neighbor Searching with Clustered Point SetsThe support of the National Science Foundation under grant CCR–9712379 is gratefully acknowledged." class="ltx_ref"><span class="ltx_text ltx_ref_tag">7</span></a>,
respectively. As before, the three different graphs are for (a)
<math id="S4.SS3.p1.1.m1.1" class="ltx_Math" alttext="\epsilon=1" display="inline"><semantics id="S4.SS3.p1.1.m1.1a"><mrow id="S4.SS3.p1.1.m1.1.1" xref="S4.SS3.p1.1.m1.1.1.cmml"><mi id="S4.SS3.p1.1.m1.1.1.2" xref="S4.SS3.p1.1.m1.1.1.2.cmml">ϵ</mi><mo id="S4.SS3.p1.1.m1.1.1.1" xref="S4.SS3.p1.1.m1.1.1.1.cmml">=</mo><mn id="S4.SS3.p1.1.m1.1.1.3" xref="S4.SS3.p1.1.m1.1.1.3.cmml">1</mn></mrow><annotation-xml encoding="MathML-Content" id="S4.SS3.p1.1.m1.1b"><apply id="S4.SS3.p1.1.m1.1.1.cmml" xref="S4.SS3.p1.1.m1.1.1"><eq id="S4.SS3.p1.1.m1.1.1.1.cmml" xref="S4.SS3.p1.1.m1.1.1.1"></eq><ci id="S4.SS3.p1.1.m1.1.1.2.cmml" xref="S4.SS3.p1.1.m1.1.1.2">italic-ϵ</ci><cn type="integer" id="S4.SS3.p1.1.m1.1.1.3.cmml" xref="S4.SS3.p1.1.m1.1.1.3">1</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS3.p1.1.m1.1c">\epsilon=1</annotation><annotation encoding="application/x-llamapun" id="S4.SS3.p1.1.m1.1d">italic_ϵ = 1</annotation></semantics></math>, (b) <math id="S4.SS3.p1.2.m2.1" class="ltx_Math" alttext="\epsilon=2" display="inline"><semantics id="S4.SS3.p1.2.m2.1a"><mrow id="S4.SS3.p1.2.m2.1.1" xref="S4.SS3.p1.2.m2.1.1.cmml"><mi id="S4.SS3.p1.2.m2.1.1.2" xref="S4.SS3.p1.2.m2.1.1.2.cmml">ϵ</mi><mo id="S4.SS3.p1.2.m2.1.1.1" xref="S4.SS3.p1.2.m2.1.1.1.cmml">=</mo><mn id="S4.SS3.p1.2.m2.1.1.3" xref="S4.SS3.p1.2.m2.1.1.3.cmml">2</mn></mrow><annotation-xml encoding="MathML-Content" id="S4.SS3.p1.2.m2.1b"><apply id="S4.SS3.p1.2.m2.1.1.cmml" xref="S4.SS3.p1.2.m2.1.1"><eq id="S4.SS3.p1.2.m2.1.1.1.cmml" xref="S4.SS3.p1.2.m2.1.1.1"></eq><ci id="S4.SS3.p1.2.m2.1.1.2.cmml" xref="S4.SS3.p1.2.m2.1.1.2">italic-ϵ</ci><cn type="integer" id="S4.SS3.p1.2.m2.1.1.3.cmml" xref="S4.SS3.p1.2.m2.1.1.3">2</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS3.p1.2.m2.1c">\epsilon=2</annotation><annotation encoding="application/x-llamapun" id="S4.SS3.p1.2.m2.1d">italic_ϵ = 2</annotation></semantics></math>, and (c) <math id="S4.SS3.p1.3.m3.1" class="ltx_Math" alttext="\epsilon=3" display="inline"><semantics id="S4.SS3.p1.3.m3.1a"><mrow id="S4.SS3.p1.3.m3.1.1" xref="S4.SS3.p1.3.m3.1.1.cmml"><mi id="S4.SS3.p1.3.m3.1.1.2" xref="S4.SS3.p1.3.m3.1.1.2.cmml">ϵ</mi><mo id="S4.SS3.p1.3.m3.1.1.1" xref="S4.SS3.p1.3.m3.1.1.1.cmml">=</mo><mn id="S4.SS3.p1.3.m3.1.1.3" xref="S4.SS3.p1.3.m3.1.1.3.cmml">3</mn></mrow><annotation-xml encoding="MathML-Content" id="S4.SS3.p1.3.m3.1b"><apply id="S4.SS3.p1.3.m3.1.1.cmml" xref="S4.SS3.p1.3.m3.1.1"><eq id="S4.SS3.p1.3.m3.1.1.1.cmml" xref="S4.SS3.p1.3.m3.1.1.1"></eq><ci id="S4.SS3.p1.3.m3.1.1.2.cmml" xref="S4.SS3.p1.3.m3.1.1.2">italic-ϵ</ci><cn type="integer" id="S4.SS3.p1.3.m3.1.1.3.cmml" xref="S4.SS3.p1.3.m3.1.1.3">3</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS3.p1.3.m3.1c">\epsilon=3</annotation><annotation encoding="application/x-llamapun" id="S4.SS3.p1.3.m3.1d">italic_ϵ = 3</annotation></semantics></math>. Again,
note that the graphs do not share the same <math id="S4.SS3.p1.4.m4.1" class="ltx_Math" alttext="y" display="inline"><semantics id="S4.SS3.p1.4.m4.1a"><mi id="S4.SS3.p1.4.m4.1.1" xref="S4.SS3.p1.4.m4.1.1.cmml">y</mi><annotation-xml encoding="MathML-Content" id="S4.SS3.p1.4.m4.1b"><ci id="S4.SS3.p1.4.m4.1.1.cmml" xref="S4.SS3.p1.4.m4.1.1">𝑦</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS3.p1.4.m4.1c">y</annotation><annotation encoding="application/x-llamapun" id="S4.SS3.p1.4.m4.1d">italic_y</annotation></semantics></math>-range.</p>
</div>
<div id="S4.SS3.p2" class="ltx_para">
<p id="S4.SS3.p2.3" class="ltx_p">Unlike the previous experiment, overall running times did not vary
greatly with <math id="S4.SS3.p2.1.m1.1" class="ltx_Math" alttext="\sigma_{\rm thin}" display="inline"><semantics id="S4.SS3.p2.1.m1.1a"><msub id="S4.SS3.p2.1.m1.1.1" xref="S4.SS3.p2.1.m1.1.1.cmml"><mi id="S4.SS3.p2.1.m1.1.1.2" xref="S4.SS3.p2.1.m1.1.1.2.cmml">σ</mi><mi id="S4.SS3.p2.1.m1.1.1.3" xref="S4.SS3.p2.1.m1.1.1.3.cmml">thin</mi></msub><annotation-xml encoding="MathML-Content" id="S4.SS3.p2.1.m1.1b"><apply id="S4.SS3.p2.1.m1.1.1.cmml" xref="S4.SS3.p2.1.m1.1.1"><csymbol cd="ambiguous" id="S4.SS3.p2.1.m1.1.1.1.cmml" xref="S4.SS3.p2.1.m1.1.1">subscript</csymbol><ci id="S4.SS3.p2.1.m1.1.1.2.cmml" xref="S4.SS3.p2.1.m1.1.1.2">𝜎</ci><ci id="S4.SS3.p2.1.m1.1.1.3.cmml" xref="S4.SS3.p2.1.m1.1.1.3">thin</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS3.p2.1.m1.1c">\sigma_{\rm thin}</annotation><annotation encoding="application/x-llamapun" id="S4.SS3.p2.1.m1.1d">italic_σ start_POSTSUBSCRIPT roman_thin end_POSTSUBSCRIPT</annotation></semantics></math>. Sometimes running times increased moderately
and other times they decreased moderately as a function of <math id="S4.SS3.p2.2.m2.1" class="ltx_Math" alttext="\sigma_{\rm thin}" display="inline"><semantics id="S4.SS3.p2.2.m2.1a"><msub id="S4.SS3.p2.2.m2.1.1" xref="S4.SS3.p2.2.m2.1.1.cmml"><mi id="S4.SS3.p2.2.m2.1.1.2" xref="S4.SS3.p2.2.m2.1.1.2.cmml">σ</mi><mi id="S4.SS3.p2.2.m2.1.1.3" xref="S4.SS3.p2.2.m2.1.1.3.cmml">thin</mi></msub><annotation-xml encoding="MathML-Content" id="S4.SS3.p2.2.m2.1b"><apply id="S4.SS3.p2.2.m2.1.1.cmml" xref="S4.SS3.p2.2.m2.1.1"><csymbol cd="ambiguous" id="S4.SS3.p2.2.m2.1.1.1.cmml" xref="S4.SS3.p2.2.m2.1.1">subscript</csymbol><ci id="S4.SS3.p2.2.m2.1.1.2.cmml" xref="S4.SS3.p2.2.m2.1.1.2">𝜎</ci><ci id="S4.SS3.p2.2.m2.1.1.3.cmml" xref="S4.SS3.p2.2.m2.1.1.3">thin</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS3.p2.2.m2.1c">\sigma_{\rm thin}</annotation><annotation encoding="application/x-llamapun" id="S4.SS3.p2.2.m2.1d">italic_σ start_POSTSUBSCRIPT roman_thin end_POSTSUBSCRIPT</annotation></semantics></math>.
However, there were significant differences between the standard
splitting method, which consistently performed much worse than the other
two methods. For the smallest values of <math id="S4.SS3.p2.3.m3.1" class="ltx_Math" alttext="\sigma_{\rm thin}" display="inline"><semantics id="S4.SS3.p2.3.m3.1a"><msub id="S4.SS3.p2.3.m3.1.1" xref="S4.SS3.p2.3.m3.1.1.cmml"><mi id="S4.SS3.p2.3.m3.1.1.2" xref="S4.SS3.p2.3.m3.1.1.2.cmml">σ</mi><mi id="S4.SS3.p2.3.m3.1.1.3" xref="S4.SS3.p2.3.m3.1.1.3.cmml">thin</mi></msub><annotation-xml encoding="MathML-Content" id="S4.SS3.p2.3.m3.1b"><apply id="S4.SS3.p2.3.m3.1.1.cmml" xref="S4.SS3.p2.3.m3.1.1"><csymbol cd="ambiguous" id="S4.SS3.p2.3.m3.1.1.1.cmml" xref="S4.SS3.p2.3.m3.1.1">subscript</csymbol><ci id="S4.SS3.p2.3.m3.1.1.2.cmml" xref="S4.SS3.p2.3.m3.1.1.2">𝜎</ci><ci id="S4.SS3.p2.3.m3.1.1.3.cmml" xref="S4.SS3.p2.3.m3.1.1.3">thin</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS3.p2.3.m3.1c">\sigma_{\rm thin}</annotation><annotation encoding="application/x-llamapun" id="S4.SS3.p2.3.m3.1d">italic_σ start_POSTSUBSCRIPT roman_thin end_POSTSUBSCRIPT</annotation></semantics></math>, there was around a
5-to-1 difference in running time between then standard method and
sliding-midpoint.</p>
</div>
<div id="S4.SS3.p3" class="ltx_para">
<p id="S4.SS3.p3.1" class="ltx_p">For larger values of <math id="S4.SS3.p3.1.m1.1" class="ltx_Math" alttext="\epsilon" display="inline"><semantics id="S4.SS3.p3.1.m1.1a"><mi id="S4.SS3.p3.1.m1.1.1" xref="S4.SS3.p3.1.m1.1.1.cmml">ϵ</mi><annotation-xml encoding="MathML-Content" id="S4.SS3.p3.1.m1.1b"><ci id="S4.SS3.p3.1.m1.1.1.cmml" xref="S4.SS3.p3.1.m1.1.1">italic-ϵ</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS3.p3.1.m1.1c">\epsilon</annotation><annotation encoding="application/x-llamapun" id="S4.SS3.p3.1.m1.1d">italic_ϵ</annotation></semantics></math> (2 and 3) the performance of
sliding-midpoint and minimum-ambiguity were very similar, with
sliding-midpoint having the slight edge. It may seem somewhat
surprising that minimum-ambiguity performed significantly worse (a
factor of 2 to 3 times worse) than sliding-midpoint, since
minimum-ambiguity was designed exactly for this the situation where
there is a difference between data and query distributions. This may be
due to limitations on the heuristic itself, or the limited size of the
training set. However, it should be kept in mind that sliding-midpoint
was specially designed to produce large empty cells in the uncluttered
regions outside the clusters (recall Fig. <a href="#S3.F1" title="Figure 1 ‣ 3.1 Sliding-Midpoint ‣ 3 Splitting Methods ‣ Analysis of Approximate Nearest Neighbor Searching with Clustered Point SetsThe support of the National Science Foundation under grant CCR–9712379 is gratefully acknowledged." class="ltx_ref"><span class="ltx_text ltx_ref_tag">1</span></a>).</p>
</div>
</section>
<section id="S4.SS4" class="ltx_subsection">
<h3 class="ltx_title ltx_title_subsection">
<span class="ltx_tag ltx_tag_subsection">4.4 </span>Construction Times</h3>

<div id="S4.SS4.p1" class="ltx_para">
<p id="S4.SS4.p1.5" class="ltx_p">The results of the previous sections suggest that the minimum ambiguity
splitting produces trees that can answer queries efficiently for a
variety of point and data distributions. Its main drawback is the
amount of time that it takes to build the tree. Both the standard and
sliding-midpoint methods can be built quite efficiently in time <math id="S4.SS4.p1.1.m1.1" class="ltx_Math" alttext="O(nh)" display="inline"><semantics id="S4.SS4.p1.1.m1.1a"><mrow id="S4.SS4.p1.1.m1.1.1" xref="S4.SS4.p1.1.m1.1.1.cmml"><mi id="S4.SS4.p1.1.m1.1.1.3" xref="S4.SS4.p1.1.m1.1.1.3.cmml">O</mi><mo id="S4.SS4.p1.1.m1.1.1.2" xref="S4.SS4.p1.1.m1.1.1.2.cmml">⁢</mo><mrow id="S4.SS4.p1.1.m1.1.1.1.1" xref="S4.SS4.p1.1.m1.1.1.1.1.1.cmml"><mo stretchy="false" id="S4.SS4.p1.1.m1.1.1.1.1.2" xref="S4.SS4.p1.1.m1.1.1.1.1.1.cmml">(</mo><mrow id="S4.SS4.p1.1.m1.1.1.1.1.1" xref="S4.SS4.p1.1.m1.1.1.1.1.1.cmml"><mi id="S4.SS4.p1.1.m1.1.1.1.1.1.2" xref="S4.SS4.p1.1.m1.1.1.1.1.1.2.cmml">n</mi><mo id="S4.SS4.p1.1.m1.1.1.1.1.1.1" xref="S4.SS4.p1.1.m1.1.1.1.1.1.1.cmml">⁢</mo><mi id="S4.SS4.p1.1.m1.1.1.1.1.1.3" xref="S4.SS4.p1.1.m1.1.1.1.1.1.3.cmml">h</mi></mrow><mo stretchy="false" id="S4.SS4.p1.1.m1.1.1.1.1.3" xref="S4.SS4.p1.1.m1.1.1.1.1.1.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S4.SS4.p1.1.m1.1b"><apply id="S4.SS4.p1.1.m1.1.1.cmml" xref="S4.SS4.p1.1.m1.1.1"><times id="S4.SS4.p1.1.m1.1.1.2.cmml" xref="S4.SS4.p1.1.m1.1.1.2"></times><ci id="S4.SS4.p1.1.m1.1.1.3.cmml" xref="S4.SS4.p1.1.m1.1.1.3">𝑂</ci><apply id="S4.SS4.p1.1.m1.1.1.1.1.1.cmml" xref="S4.SS4.p1.1.m1.1.1.1.1"><times id="S4.SS4.p1.1.m1.1.1.1.1.1.1.cmml" xref="S4.SS4.p1.1.m1.1.1.1.1.1.1"></times><ci id="S4.SS4.p1.1.m1.1.1.1.1.1.2.cmml" xref="S4.SS4.p1.1.m1.1.1.1.1.1.2">𝑛</ci><ci id="S4.SS4.p1.1.m1.1.1.1.1.1.3.cmml" xref="S4.SS4.p1.1.m1.1.1.1.1.1.3">ℎ</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS4.p1.1.m1.1c">O(nh)</annotation><annotation encoding="application/x-llamapun" id="S4.SS4.p1.1.m1.1d">italic_O ( italic_n italic_h )</annotation></semantics></math>,
where <math id="S4.SS4.p1.2.m2.1" class="ltx_Math" alttext="n" display="inline"><semantics id="S4.SS4.p1.2.m2.1a"><mi id="S4.SS4.p1.2.m2.1.1" xref="S4.SS4.p1.2.m2.1.1.cmml">n</mi><annotation-xml encoding="MathML-Content" id="S4.SS4.p1.2.m2.1b"><ci id="S4.SS4.p1.2.m2.1.1.cmml" xref="S4.SS4.p1.2.m2.1.1">𝑛</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS4.p1.2.m2.1c">n</annotation><annotation encoding="application/x-llamapun" id="S4.SS4.p1.2.m2.1d">italic_n</annotation></semantics></math> is the number of data points, and <math id="S4.SS4.p1.3.m3.1" class="ltx_Math" alttext="h" display="inline"><semantics id="S4.SS4.p1.3.m3.1a"><mi id="S4.SS4.p1.3.m3.1.1" xref="S4.SS4.p1.3.m3.1.1.cmml">h</mi><annotation-xml encoding="MathML-Content" id="S4.SS4.p1.3.m3.1b"><ci id="S4.SS4.p1.3.m3.1.1.cmml" xref="S4.SS4.p1.3.m3.1.1">ℎ</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS4.p1.3.m3.1c">h</annotation><annotation encoding="application/x-llamapun" id="S4.SS4.p1.3.m3.1d">italic_h</annotation></semantics></math> is the height of the
tree. The standard kd-tree has <math id="S4.SS4.p1.4.m4.1" class="ltx_Math" alttext="O(\log n)" display="inline"><semantics id="S4.SS4.p1.4.m4.1a"><mrow id="S4.SS4.p1.4.m4.1.1" xref="S4.SS4.p1.4.m4.1.1.cmml"><mi id="S4.SS4.p1.4.m4.1.1.3" xref="S4.SS4.p1.4.m4.1.1.3.cmml">O</mi><mo id="S4.SS4.p1.4.m4.1.1.2" xref="S4.SS4.p1.4.m4.1.1.2.cmml">⁢</mo><mrow id="S4.SS4.p1.4.m4.1.1.1.1" xref="S4.SS4.p1.4.m4.1.1.1.1.1.cmml"><mo stretchy="false" id="S4.SS4.p1.4.m4.1.1.1.1.2" xref="S4.SS4.p1.4.m4.1.1.1.1.1.cmml">(</mo><mrow id="S4.SS4.p1.4.m4.1.1.1.1.1" xref="S4.SS4.p1.4.m4.1.1.1.1.1.cmml"><mi id="S4.SS4.p1.4.m4.1.1.1.1.1.1" xref="S4.SS4.p1.4.m4.1.1.1.1.1.1.cmml">log</mi><mo lspace="0.167em" id="S4.SS4.p1.4.m4.1.1.1.1.1a" xref="S4.SS4.p1.4.m4.1.1.1.1.1.cmml">⁡</mo><mi id="S4.SS4.p1.4.m4.1.1.1.1.1.2" xref="S4.SS4.p1.4.m4.1.1.1.1.1.2.cmml">n</mi></mrow><mo stretchy="false" id="S4.SS4.p1.4.m4.1.1.1.1.3" xref="S4.SS4.p1.4.m4.1.1.1.1.1.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S4.SS4.p1.4.m4.1b"><apply id="S4.SS4.p1.4.m4.1.1.cmml" xref="S4.SS4.p1.4.m4.1.1"><times id="S4.SS4.p1.4.m4.1.1.2.cmml" xref="S4.SS4.p1.4.m4.1.1.2"></times><ci id="S4.SS4.p1.4.m4.1.1.3.cmml" xref="S4.SS4.p1.4.m4.1.1.3">𝑂</ci><apply id="S4.SS4.p1.4.m4.1.1.1.1.1.cmml" xref="S4.SS4.p1.4.m4.1.1.1.1"><log id="S4.SS4.p1.4.m4.1.1.1.1.1.1.cmml" xref="S4.SS4.p1.4.m4.1.1.1.1.1.1"></log><ci id="S4.SS4.p1.4.m4.1.1.1.1.1.2.cmml" xref="S4.SS4.p1.4.m4.1.1.1.1.1.2">𝑛</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS4.p1.4.m4.1c">O(\log n)</annotation><annotation encoding="application/x-llamapun" id="S4.SS4.p1.4.m4.1d">italic_O ( roman_log italic_n )</annotation></semantics></math> height, and while the
sliding-midpoint tree need not have <math id="S4.SS4.p1.5.m5.1" class="ltx_Math" alttext="O(\log n)" display="inline"><semantics id="S4.SS4.p1.5.m5.1a"><mrow id="S4.SS4.p1.5.m5.1.1" xref="S4.SS4.p1.5.m5.1.1.cmml"><mi id="S4.SS4.p1.5.m5.1.1.3" xref="S4.SS4.p1.5.m5.1.1.3.cmml">O</mi><mo id="S4.SS4.p1.5.m5.1.1.2" xref="S4.SS4.p1.5.m5.1.1.2.cmml">⁢</mo><mrow id="S4.SS4.p1.5.m5.1.1.1.1" xref="S4.SS4.p1.5.m5.1.1.1.1.1.cmml"><mo stretchy="false" id="S4.SS4.p1.5.m5.1.1.1.1.2" xref="S4.SS4.p1.5.m5.1.1.1.1.1.cmml">(</mo><mrow id="S4.SS4.p1.5.m5.1.1.1.1.1" xref="S4.SS4.p1.5.m5.1.1.1.1.1.cmml"><mi id="S4.SS4.p1.5.m5.1.1.1.1.1.1" xref="S4.SS4.p1.5.m5.1.1.1.1.1.1.cmml">log</mi><mo lspace="0.167em" id="S4.SS4.p1.5.m5.1.1.1.1.1a" xref="S4.SS4.p1.5.m5.1.1.1.1.1.cmml">⁡</mo><mi id="S4.SS4.p1.5.m5.1.1.1.1.1.2" xref="S4.SS4.p1.5.m5.1.1.1.1.1.2.cmml">n</mi></mrow><mo stretchy="false" id="S4.SS4.p1.5.m5.1.1.1.1.3" xref="S4.SS4.p1.5.m5.1.1.1.1.1.cmml">)</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S4.SS4.p1.5.m5.1b"><apply id="S4.SS4.p1.5.m5.1.1.cmml" xref="S4.SS4.p1.5.m5.1.1"><times id="S4.SS4.p1.5.m5.1.1.2.cmml" xref="S4.SS4.p1.5.m5.1.1.2"></times><ci id="S4.SS4.p1.5.m5.1.1.3.cmml" xref="S4.SS4.p1.5.m5.1.1.3">𝑂</ci><apply id="S4.SS4.p1.5.m5.1.1.1.1.1.cmml" xref="S4.SS4.p1.5.m5.1.1.1.1"><log id="S4.SS4.p1.5.m5.1.1.1.1.1.1.cmml" xref="S4.SS4.p1.5.m5.1.1.1.1.1.1"></log><ci id="S4.SS4.p1.5.m5.1.1.1.1.1.2.cmml" xref="S4.SS4.p1.5.m5.1.1.1.1.1.2">𝑛</ci></apply></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS4.p1.5.m5.1c">O(\log n)</annotation><annotation encoding="application/x-llamapun" id="S4.SS4.p1.5.m5.1d">italic_O ( roman_log italic_n )</annotation></semantics></math> height, this seems to be
true for many point distributions. For the 4000 point data sets in
dimension 20, both of these trees could be constructed in under 10 CPU
seconds.</p>
</div>
<div id="S4.SS4.p2" class="ltx_para">
<p id="S4.SS4.p2.1" class="ltx_p">However, the construction time for the minimum-ambiguity tree is quite a
bit higher. It can be argued that the time to construct the tree is
roughly (within logarithmic factors) proportional to the time to compute
the (approximate) nearest neighbors for all the training points. In
order to construct the tree, first the nearest neighbors for each of the
training points must be computed. This is done in an auxiliary nearest
neighbor tree, e.g., one built using the standard or sliding-midpoint
method. Then to determine the splitting hyperplane for each cell of the
minimum-ambiguity tree, requires consideration of all the nearest
neighbor balls that overlap the current cell. However, in order to
compute the nearest neighbors of the training points, each point whose
nearest neighbor ball overlaps the cell would have to visit the cell in
any case.</p>
</div>
<div id="S4.SS4.p3" class="ltx_para">
<p id="S4.SS4.p3.2" class="ltx_p">Since we used 9 times the number of data points as training points, it
is easy to see that the minimum-ambiguity tree will take much longer
to compute than the other two trees. Notice that when <math id="S4.SS4.p3.1.m1.1" class="ltx_Math" alttext="\epsilon&gt;0" display="inline"><semantics id="S4.SS4.p3.1.m1.1a"><mrow id="S4.SS4.p3.1.m1.1.1" xref="S4.SS4.p3.1.m1.1.1.cmml"><mi id="S4.SS4.p3.1.m1.1.1.2" xref="S4.SS4.p3.1.m1.1.1.2.cmml">ϵ</mi><mo id="S4.SS4.p3.1.m1.1.1.1" xref="S4.SS4.p3.1.m1.1.1.1.cmml">&gt;</mo><mn id="S4.SS4.p3.1.m1.1.1.3" xref="S4.SS4.p3.1.m1.1.1.3.cmml">0</mn></mrow><annotation-xml encoding="MathML-Content" id="S4.SS4.p3.1.m1.1b"><apply id="S4.SS4.p3.1.m1.1.1.cmml" xref="S4.SS4.p3.1.m1.1.1"><gt id="S4.SS4.p3.1.m1.1.1.1.cmml" xref="S4.SS4.p3.1.m1.1.1.1"></gt><ci id="S4.SS4.p3.1.m1.1.1.2.cmml" xref="S4.SS4.p3.1.m1.1.1.2">italic-ϵ</ci><cn type="integer" id="S4.SS4.p3.1.m1.1.1.3.cmml" xref="S4.SS4.p3.1.m1.1.1.3">0</cn></apply></annotation-xml><annotation encoding="application/x-tex" id="S4.SS4.p3.1.m1.1c">\epsilon&gt;0</annotation><annotation encoding="application/x-llamapun" id="S4.SS4.p3.1.m1.1d">italic_ϵ &gt; 0</annotation></semantics></math>,
we compute nearest neighbors approximately, and so this can offer an
improvement in construction time. In Fig. <a href="#S6.F8" title="Figure 8 ‣ Analysis of Approximate Nearest Neighbor Searching with Clustered Point SetsThe support of the National Science Foundation under grant CCR–9712379 is gratefully acknowledged." class="ltx_ref"><span class="ltx_text ltx_ref_tag">8</span></a> we
present the construction time for the minimum-ambiguity tree for
various combinations of data and training distributions. Observe
that the construction times are considerably greater than those for
the other two methods (which were under 10 CPU seconds), and that
the construction time is significantly faster for higher values
of <math id="S4.SS4.p3.2.m2.1" class="ltx_Math" alttext="\epsilon" display="inline"><semantics id="S4.SS4.p3.2.m2.1a"><mi id="S4.SS4.p3.2.m2.1.1" xref="S4.SS4.p3.2.m2.1.1.cmml">ϵ</mi><annotation-xml encoding="MathML-Content" id="S4.SS4.p3.2.m2.1b"><ci id="S4.SS4.p3.2.m2.1.1.cmml" xref="S4.SS4.p3.2.m2.1.1">italic-ϵ</ci></annotation-xml><annotation encoding="application/x-tex" id="S4.SS4.p3.2.m2.1c">\epsilon</annotation><annotation encoding="application/x-llamapun" id="S4.SS4.p3.2.m2.1d">italic_ϵ</annotation></semantics></math>.</p>
</div>
</section>
</section>
<section id="S5" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">5 </span>Conclusions</h2>

<div id="S5.p1" class="ltx_para">
<p id="S5.p1.1" class="ltx_p">In this paper we have presented an empirical analysis of two new
splitting methods for kd-trees: sliding-midpoint and minimum-ambiguity.
Both of these methods were designed to remedy some of the deficiencies
of the standard kd-tree splitting method, with respect to data
distributions that are highly clustered in low-dimensional subspaces.
Both methods were shown to be considerably faster than the standard
splitting method in answering queries when data points were drawn from a
clustered distribution and query points were drawn from a uniform
distribution. The minimum-ambiguity method performed better when both
data and query points were drawn from a clustered distribution. But this
method has a considerably higher construction time. The
sliding-midpoint method, while easy to build, seems to perform sometimes
better and sometimes worse than the standard kd-tree splitting method.</p>
</div>
<div id="S5.p2" class="ltx_para">
<p id="S5.p2.1" class="ltx_p">The enhanced performance of the minimum-ambiguity method suggests that
even within the realm of kd-trees, there may be significant improvements
to be made by fine-tuning the structure of the tree to the data and
query distributions. However, because of its high construction cost, it
would be nice to determine whether there are other heuristics that would
lead to faster construction times. This suggest the intriguing
possibility of search trees whose structure adapts dynamically to the
structure of queries over time. The sliding-midpoint method raises hope
that it may be possible to devise a simple and efficiently computable
splitting method, that performs well across a wider variety of
distributions than the standard splitting method.</p>
</div>
</section>
<section id="S6" class="ltx_section">
<h2 class="ltx_title ltx_title_section">
<span class="ltx_tag ltx_tag_section">6 </span>Acknowledgements</h2>

<div id="S6.p1" class="ltx_para">
<p id="S6.p1.1" class="ltx_p">We would like to thank Sunil Arya for helpful discussions on the
performance of the sliding-midpoint method.</p>
</div>
</section>
<section id="bib" class="ltx_bibliography">
<h2 class="ltx_title ltx_title_bibliography">References</h2>

<ul class="ltx_biblist">
<li id="bib.bib1" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[1]</span>
<span class="ltx_bibblock">
S. Arya and D. M. Mount.

</span>
<span class="ltx_bibblock">Algorithms for fast vector quantization.

</span>
<span class="ltx_bibblock">In <span id="bib.bib1.1.1" class="ltx_text ltx_font_italic">Proc. Data Compression Conference</span>, pages 381–390. IEEE
Press, 1993.

</span>
</li>
<li id="bib.bib2" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[2]</span>
<span class="ltx_bibblock">
S. Arya and D. M. Mount.

</span>
<span class="ltx_bibblock">Approximate nearest neighbor queries in fixed dimensions.

</span>
<span class="ltx_bibblock">In <span id="bib.bib2.1.1" class="ltx_text ltx_font_italic">Proc. 4th ACM-SIAM Sympos. Discrete Algorithms</span>, pages
271–280, 1993.

</span>
</li>
<li id="bib.bib3" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[3]</span>
<span class="ltx_bibblock">
S. Arya, D. M. Mount, N. S. Netanyahu, R. Silverman, and A. Wu.

</span>
<span class="ltx_bibblock">An optimal algorithm for approximate nearest neighbor searching.

</span>
<span class="ltx_bibblock">In <span id="bib.bib3.1.1" class="ltx_text ltx_font_italic">Proc. 5th ACM-SIAM Sympos. Discrete Algorithms</span>, pages
573–582, 1994.

</span>
</li>
<li id="bib.bib4" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[4]</span>
<span class="ltx_bibblock">
N. Beckmann, H.-P. Kriegel, R. Schneider, and B. Seeger.

</span>
<span class="ltx_bibblock">The R<math id="bib.bib4.1.m1.1" class="ltx_Math" alttext="{}^{*}" display="inline"><semantics id="bib.bib4.1.m1.1a"><msup id="bib.bib4.1.m1.1.1" xref="bib.bib4.1.m1.1.1.cmml"><mi id="bib.bib4.1.m1.1.1a" xref="bib.bib4.1.m1.1.1.cmml"></mi><mo id="bib.bib4.1.m1.1.1.1" xref="bib.bib4.1.m1.1.1.1.cmml">*</mo></msup><annotation-xml encoding="MathML-Content" id="bib.bib4.1.m1.1b"><apply id="bib.bib4.1.m1.1.1.cmml" xref="bib.bib4.1.m1.1.1"><times id="bib.bib4.1.m1.1.1.1.cmml" xref="bib.bib4.1.m1.1.1.1"></times></apply></annotation-xml><annotation encoding="application/x-tex" id="bib.bib4.1.m1.1c">{}^{*}</annotation><annotation encoding="application/x-llamapun" id="bib.bib4.1.m1.1d">start_FLOATSUPERSCRIPT * end_FLOATSUPERSCRIPT</annotation></semantics></math>-tree: An efficient and robust access method for points
and rectangles.

</span>
<span class="ltx_bibblock">In <span id="bib.bib4.2.1" class="ltx_text ltx_font_italic">Proc. ACM SIGMOD Conf. on Management of Data</span>, pages
322–331, 1990.

</span>
</li>
<li id="bib.bib5" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[5]</span>
<span class="ltx_bibblock">
C.-D. Bei and R. M. Gray.

</span>
<span class="ltx_bibblock">An improvement of the minimum distortion encoding algorithm for
vector quantization.

</span>
<span class="ltx_bibblock"><span id="bib.bib5.1.1" class="ltx_text ltx_font_italic">IEEE Transactions on Communications</span>, 33(10):1132–1133, 1985.

</span>
</li>
<li id="bib.bib6" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[6]</span>
<span class="ltx_bibblock">
J. L. Bentley.

</span>
<span class="ltx_bibblock">Multidimensional binary search trees used for associative searching.

</span>
<span class="ltx_bibblock"><span id="bib.bib6.1.1" class="ltx_text ltx_font_italic">Communications of the ACM</span>, 18(9):509–517, 1975.

</span>
</li>
<li id="bib.bib7" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[7]</span>
<span class="ltx_bibblock">
S. Berchtold, D. A. Keim, and H.-P. Kriegel.

</span>
<span class="ltx_bibblock">The X-tree: An index structure for high-dimensional data.

</span>
<span class="ltx_bibblock">In <span id="bib.bib7.1.1" class="ltx_text ltx_font_italic">Proc. 22nd VLDB Conference</span>, pages 28–39, 1996.

</span>
</li>
<li id="bib.bib8" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[8]</span>
<span class="ltx_bibblock">
M. Bern.

</span>
<span class="ltx_bibblock">Approximate closest-point queries in high dimensions.

</span>
<span class="ltx_bibblock"><span id="bib.bib8.1.1" class="ltx_text ltx_font_italic">Inform. Process. Lett.</span>, 45:95–99, 1993.

</span>
</li>
<li id="bib.bib9" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[9]</span>
<span class="ltx_bibblock">
L. Breiman, J. H. Friedman, R. A. Olshen, and C. J. Stone.

</span>
<span class="ltx_bibblock"><span id="bib.bib9.1.1" class="ltx_text ltx_font_italic">Classification and Regression Trees</span>.

</span>
<span class="ltx_bibblock">Wadsworth, Belmont, California, 1984.

</span>
</li>
<li id="bib.bib10" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[10]</span>
<span class="ltx_bibblock">
T. Chan.

</span>
<span class="ltx_bibblock">Approximate nearest neighbor queries revisited.

</span>
<span class="ltx_bibblock">In <span id="bib.bib10.1.1" class="ltx_text ltx_font_italic">Proc. 13th Annu. ACM Sympos. Comput. Geom.</span>, pages 352–358,
1997.

</span>
</li>
<li id="bib.bib11" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[11]</span>
<span class="ltx_bibblock">
K. L. Clarkson.

</span>
<span class="ltx_bibblock">An algorithm for approximate closest-point queries.

</span>
<span class="ltx_bibblock">In <span id="bib.bib11.1.1" class="ltx_text ltx_font_italic">Proc. 10th Annu. ACM Sympos. Comput. Geom.</span>, pages 160–164,
1994.

</span>
</li>
<li id="bib.bib12" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[12]</span>
<span class="ltx_bibblock">
K. L. Clarkson.

</span>
<span class="ltx_bibblock">Nearest neighbor queries in metric spaces.

</span>
<span class="ltx_bibblock">In <span id="bib.bib12.1.1" class="ltx_text ltx_font_italic">Proc. 29th Annu. ACM Sympos. Theory Comput.</span>, pages 609–617,
1997.

</span>
</li>
<li id="bib.bib13" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[13]</span>
<span class="ltx_bibblock">
S. Cost and S. Salzberg.

</span>
<span class="ltx_bibblock">A weighted nearest neighbor algorithm for learning with symbolic
features.

</span>
<span class="ltx_bibblock"><span id="bib.bib13.1.1" class="ltx_text ltx_font_italic">Machine Learning</span>, 10:57–78, 1993.

</span>
</li>
<li id="bib.bib14" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[14]</span>
<span class="ltx_bibblock">
T. M. Cover and P. E. Hart.

</span>
<span class="ltx_bibblock">Nearest neighbor pattern classification.

</span>
<span class="ltx_bibblock"><span id="bib.bib14.1.1" class="ltx_text ltx_font_italic">IEEE Trans. Inform. Theory</span>, 13:57–67, 1967.

</span>
</li>
<li id="bib.bib15" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[15]</span>
<span class="ltx_bibblock">
S. Deerwester, S. T. Dumals, G. W. Furnas, T. K. Landauer, and R. Harshman.

</span>
<span class="ltx_bibblock">Indexing by latend semantic analysis.

</span>
<span class="ltx_bibblock"><span id="bib.bib15.1.1" class="ltx_text ltx_font_italic">J. Amer. Soc. Inform. Sci.</span>, 41(6):391–407, 1990.

</span>
</li>
<li id="bib.bib16" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[16]</span>
<span class="ltx_bibblock">
L. Devroye and T. J. Wagner.

</span>
<span class="ltx_bibblock">Nearest neighbor methods in discrimination.

</span>
<span class="ltx_bibblock">In P. R. Krishnaiah and L. N. Kanal, editors, <span id="bib.bib16.1.1" class="ltx_text ltx_font_italic">Handbook of
Statistics</span>, volume 2. North-Holland, 1982.

</span>
</li>
<li id="bib.bib17" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[17]</span>
<span class="ltx_bibblock">
R. O. Duda and P. E. Hart.

</span>
<span class="ltx_bibblock"><span id="bib.bib17.1.1" class="ltx_text ltx_font_italic">Pattern Classification and Scene Analysis</span>.

</span>
<span class="ltx_bibblock">John Wiley &amp; Sons, NY, 1973.

</span>
</li>
<li id="bib.bib18" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[18]</span>
<span class="ltx_bibblock">
U. M. Fayyad, G. Piatetsky-Shapiro, P. Smyth, and R. Uthurusamy.

</span>
<span class="ltx_bibblock"><span id="bib.bib18.1.1" class="ltx_text ltx_font_italic">Advances in Knowledge Discovery and Data Mining</span>.

</span>
<span class="ltx_bibblock">AAAI Press/Mit Press, 1996.

</span>
</li>
<li id="bib.bib19" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[19]</span>
<span class="ltx_bibblock">
M. Flickner, H. Sawhney, W. Niblack, J. Ashley, Q. Huang, B. Dom, M. Gorkani,
J. Hafner, D. Lee, D. Petkovic, D. Steele, and P. Yanker.

</span>
<span class="ltx_bibblock">Query by image and video content: The QBIC system.

</span>
<span class="ltx_bibblock"><span id="bib.bib19.1.1" class="ltx_text ltx_font_italic">IEEE Computer</span>, 28:23–32, 1995.

</span>
</li>
<li id="bib.bib20" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[20]</span>
<span class="ltx_bibblock">
E. Forgey.

</span>
<span class="ltx_bibblock">Cluster analysis of multivariate data: Efficiency vs.
interpretability of classification.

</span>
<span class="ltx_bibblock"><span id="bib.bib20.1.1" class="ltx_text ltx_font_italic">Biometrics</span>, 21:768, 1965.

</span>
</li>
<li id="bib.bib21" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[21]</span>
<span class="ltx_bibblock">
J. H. Friedman, J. L. Bentley, and R. A. Finkel.

</span>
<span class="ltx_bibblock">An algorithm for finding best matches in logarithmic expected time.

</span>
<span class="ltx_bibblock"><span id="bib.bib21.1.1" class="ltx_text ltx_font_italic">ACM Trans. Math. Software</span>, 3(3):209–226, 1977.

</span>
</li>
<li id="bib.bib22" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[22]</span>
<span class="ltx_bibblock">
A. Gersho and R. M. Gray.

</span>
<span class="ltx_bibblock"><span id="bib.bib22.1.1" class="ltx_text ltx_font_italic">Vector Quantization and Signal Compression</span>.

</span>
<span class="ltx_bibblock">Kluwer Academic, Boston, 1992.

</span>
</li>
<li id="bib.bib23" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[23]</span>
<span class="ltx_bibblock">
P. Indyk and R. Motwani.

</span>
<span class="ltx_bibblock">Approximate nearest neighbors: Towards removing the curse of
dimensionality.

</span>
<span class="ltx_bibblock">In <span id="bib.bib23.1.1" class="ltx_text ltx_font_italic">Proc. 30th Annu. ACM Sympos. Theory Comput.</span>, 1998.

</span>
</li>
<li id="bib.bib24" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[24]</span>
<span class="ltx_bibblock">
A. K. Jain and R. C. Dubes.

</span>
<span class="ltx_bibblock"><span id="bib.bib24.1.1" class="ltx_text ltx_font_italic">Algorithms for Clustering Data</span>.

</span>
<span class="ltx_bibblock">Prentice Hall, Englewood Cliffs, New Jersey, 1988.

</span>
</li>
<li id="bib.bib25" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[25]</span>
<span class="ltx_bibblock">
N. Katayama and S. Satoh.

</span>
<span class="ltx_bibblock">The SR-tree: An index structure for high-dimensional nearest
neighbor queries.

</span>
<span class="ltx_bibblock">In <span id="bib.bib25.1.1" class="ltx_text ltx_font_italic">Proc. ACM SIGMOD Conf. on Management of Data</span>, pages
369–380, 1997.

</span>
</li>
<li id="bib.bib26" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[26]</span>
<span class="ltx_bibblock">
J. M. Kleinberg.

</span>
<span class="ltx_bibblock">Two algorithms for nearest-neighbor search in high dimension.

</span>
<span class="ltx_bibblock">In <span id="bib.bib26.1.1" class="ltx_text ltx_font_italic">Proc. 29th Annu. ACM Sympos. Theory Comput.</span>, pages 599–608,
1997.

</span>
</li>
<li id="bib.bib27" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[27]</span>
<span class="ltx_bibblock">
E. Kushilevitz, R. Ostrovsky, and Y. Rabani.

</span>
<span class="ltx_bibblock">Efficient search for approximate nearest neighbor in high dimemsional
spaces.

</span>
<span class="ltx_bibblock">In <span id="bib.bib27.1.1" class="ltx_text ltx_font_italic">Proc. 30th Annu. ACM Sympos. Theory Comput.</span>, 1998.

</span>
</li>
<li id="bib.bib28" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[28]</span>
<span class="ltx_bibblock">
K. I. Lin, H. V. Jagdish, and C. Faloutsos.

</span>
<span class="ltx_bibblock">The TV-tree: An index structure for high-dimensional data.

</span>
<span class="ltx_bibblock"><span id="bib.bib28.1.1" class="ltx_text ltx_font_italic">VLDB Journal</span>, 3(4):517–542, 1994.

</span>
</li>
<li id="bib.bib29" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[29]</span>
<span class="ltx_bibblock">
J. MacQueen.

</span>
<span class="ltx_bibblock">Some methods for classification and analysis of multivariate
observations.

</span>
<span class="ltx_bibblock">In <span id="bib.bib29.1.1" class="ltx_text ltx_font_italic">Proc. of the Fifth Berkeley Symposium on Math. Stat. and
Prob.</span>, volume 1, pages 281–296, 1967.

</span>
</li>
<li id="bib.bib30" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[30]</span>
<span class="ltx_bibblock">
D. M. Mount and S. Arya.

</span>
<span class="ltx_bibblock">Ann: A library for approximate nearest neighbor searching.

</span>
<span class="ltx_bibblock">CGC 2nd Annual Fall Workship on Computational Geometry, URL: <span id="bib.bib30.1.1" class="ltx_text ltx_font_typewriter">http://www.cs.umd.edu/~mount/ANN</span>., 1997.

</span>
</li>
<li id="bib.bib31" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[31]</span>
<span class="ltx_bibblock">
T. Sellis, N. Roussopoulos, and C. Faloutsos.

</span>
<span class="ltx_bibblock">The R<math id="bib.bib31.1.m1.1" class="ltx_Math" alttext="{}^{+}" display="inline"><semantics id="bib.bib31.1.m1.1a"><msup id="bib.bib31.1.m1.1.1" xref="bib.bib31.1.m1.1.1.cmml"><mi id="bib.bib31.1.m1.1.1a" xref="bib.bib31.1.m1.1.1.cmml"></mi><mo id="bib.bib31.1.m1.1.1.1" xref="bib.bib31.1.m1.1.1.1.cmml">+</mo></msup><annotation-xml encoding="MathML-Content" id="bib.bib31.1.m1.1b"><apply id="bib.bib31.1.m1.1.1.cmml" xref="bib.bib31.1.m1.1.1"><plus id="bib.bib31.1.m1.1.1.1.cmml" xref="bib.bib31.1.m1.1.1.1"></plus></apply></annotation-xml><annotation encoding="application/x-tex" id="bib.bib31.1.m1.1c">{}^{+}</annotation><annotation encoding="application/x-llamapun" id="bib.bib31.1.m1.1d">start_FLOATSUPERSCRIPT + end_FLOATSUPERSCRIPT</annotation></semantics></math>-tree: A dynamic index for multi-dimensional objects.

</span>
<span class="ltx_bibblock">In <span id="bib.bib31.2.1" class="ltx_text ltx_font_italic">Proc. 13th VLDB Conference</span>, pages 507–517, 1987.

</span>
</li>
<li id="bib.bib32" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[32]</span>
<span class="ltx_bibblock">
R. F. Sproull.

</span>
<span class="ltx_bibblock">Refinements to nearest-neighbor searching in k-dimensional trees.

</span>
<span class="ltx_bibblock"><span id="bib.bib32.1.1" class="ltx_text ltx_font_italic">Algorithmica</span>, 6(4):579–589, 1991.

</span>
</li>
<li id="bib.bib33" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[33]</span>
<span class="ltx_bibblock">
D. A. White and R. Jain.

</span>
<span class="ltx_bibblock">Algorithms and strategies for similarity retrieval.

</span>
<span class="ltx_bibblock">Technical Report VCL-96-101, Visual Computing Lab., Univ. California,
San Diego, CA, 1996.

</span>
</li>
<li id="bib.bib34" class="ltx_bibitem">
<span class="ltx_tag ltx_tag_bibitem">[34]</span>
<span class="ltx_bibblock">
P. N. Yianilos.

</span>
<span class="ltx_bibblock">Data structures and algorithms for nearest neighbor search in general
metric spaces.

</span>
<span class="ltx_bibblock">In <span id="bib.bib34.1.1" class="ltx_text ltx_font_italic">Proc. 4th ACM-SIAM Sympos. Discrete Algorithms</span>, pages
311–321, 1993.

</span>
</li>
</ul>
</section>
<figure id="S6.F4" class="ltx_figure">
<div class="ltx_flex_figure">

<div class="ltx_flex_cell 
                  ">
<table id="S6.F4.2" class="ltx_tabular ltx_centering ltx_align_middle">
<tbody class="ltx_tbody">
<tr id="S6.F4.2.2" class="ltx_tr">
<td id="S6.F4.1.1.1" class="ltx_td ltx_align_center"><img src="/html/cs/9901013/assets/x3.png" id="S6.F4.1.1.1.g1" class="ltx_graphics ltx_img_portrait" width="326" height="422" alt="Refer to caption"></td>
<td id="S6.F4.2.2.2" class="ltx_td ltx_align_center"><img src="/html/cs/9901013/assets/x4.png" id="S6.F4.2.2.2.g1" class="ltx_graphics ltx_img_portrait" width="326" height="422" alt="Refer to caption"></td>
</tr>
<tr id="S6.F4.2.3.1" class="ltx_tr">
<td id="S6.F4.2.3.1.1" class="ltx_td ltx_align_center">(a)</td>
<td id="S6.F4.2.3.1.2" class="ltx_td ltx_align_center">(b)</td>
</tr>
</tbody>
</table>
</div>
<div class="ltx_flex_break"></div>
<div class="ltx_flex_cell 
                  ">
<p id="S6.F4.3" class="ltx_p ltx_align_center ltx_align_center"><span id="S6.F4.3.1" class="ltx_text"><img src="/html/cs/9901013/assets/x5.png" id="S6.F4.3.1.g1" class="ltx_graphics ltx_img_portrait" width="326" height="422" alt="Refer to caption"></span></p>
</div>
<div class="ltx_flex_cell 
                  ">
<p id="S6.F4.8" class="ltx_p ltx_align_center">(c)</p>
</div>
</div>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 4: </span>Number of nodes visited versus <math id="S6.F4.6.m1.1" class="ltx_Math" alttext="\sigma_{\rm thin}" display="inline"><semantics id="S6.F4.6.m1.1b"><msub id="S6.F4.6.m1.1.1" xref="S6.F4.6.m1.1.1.cmml"><mi id="S6.F4.6.m1.1.1.2" xref="S6.F4.6.m1.1.1.2.cmml">σ</mi><mi id="S6.F4.6.m1.1.1.3" xref="S6.F4.6.m1.1.1.3.cmml">thin</mi></msub><annotation-xml encoding="MathML-Content" id="S6.F4.6.m1.1c"><apply id="S6.F4.6.m1.1.1.cmml" xref="S6.F4.6.m1.1.1"><csymbol cd="ambiguous" id="S6.F4.6.m1.1.1.1.cmml" xref="S6.F4.6.m1.1.1">subscript</csymbol><ci id="S6.F4.6.m1.1.1.2.cmml" xref="S6.F4.6.m1.1.1.2">𝜎</ci><ci id="S6.F4.6.m1.1.1.3.cmml" xref="S6.F4.6.m1.1.1.3">thin</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S6.F4.6.m1.1d">\sigma_{\rm thin}</annotation><annotation encoding="application/x-llamapun" id="S6.F4.6.m1.1e">italic_σ start_POSTSUBSCRIPT roman_thin end_POSTSUBSCRIPT</annotation></semantics></math> for
<math id="S6.F4.7.m2.3" class="ltx_Math" alttext="\epsilon\in\{0,1,2\}" display="inline"><semantics id="S6.F4.7.m2.3b"><mrow id="S6.F4.7.m2.3.4" xref="S6.F4.7.m2.3.4.cmml"><mi id="S6.F4.7.m2.3.4.2" xref="S6.F4.7.m2.3.4.2.cmml">ϵ</mi><mo id="S6.F4.7.m2.3.4.1" xref="S6.F4.7.m2.3.4.1.cmml">∈</mo><mrow id="S6.F4.7.m2.3.4.3.2" xref="S6.F4.7.m2.3.4.3.1.cmml"><mo stretchy="false" id="S6.F4.7.m2.3.4.3.2.1" xref="S6.F4.7.m2.3.4.3.1.cmml">{</mo><mn id="S6.F4.7.m2.1.1" xref="S6.F4.7.m2.1.1.cmml">0</mn><mo id="S6.F4.7.m2.3.4.3.2.2" xref="S6.F4.7.m2.3.4.3.1.cmml">,</mo><mn id="S6.F4.7.m2.2.2" xref="S6.F4.7.m2.2.2.cmml">1</mn><mo id="S6.F4.7.m2.3.4.3.2.3" xref="S6.F4.7.m2.3.4.3.1.cmml">,</mo><mn id="S6.F4.7.m2.3.3" xref="S6.F4.7.m2.3.3.cmml">2</mn><mo stretchy="false" id="S6.F4.7.m2.3.4.3.2.4" xref="S6.F4.7.m2.3.4.3.1.cmml">}</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S6.F4.7.m2.3c"><apply id="S6.F4.7.m2.3.4.cmml" xref="S6.F4.7.m2.3.4"><in id="S6.F4.7.m2.3.4.1.cmml" xref="S6.F4.7.m2.3.4.1"></in><ci id="S6.F4.7.m2.3.4.2.cmml" xref="S6.F4.7.m2.3.4.2">italic-ϵ</ci><set id="S6.F4.7.m2.3.4.3.1.cmml" xref="S6.F4.7.m2.3.4.3.2"><cn type="integer" id="S6.F4.7.m2.1.1.cmml" xref="S6.F4.7.m2.1.1">0</cn><cn type="integer" id="S6.F4.7.m2.2.2.cmml" xref="S6.F4.7.m2.2.2">1</cn><cn type="integer" id="S6.F4.7.m2.3.3.cmml" xref="S6.F4.7.m2.3.3">2</cn></set></apply></annotation-xml><annotation encoding="application/x-tex" id="S6.F4.7.m2.3d">\epsilon\in\{0,1,2\}</annotation><annotation encoding="application/x-llamapun" id="S6.F4.7.m2.3e">italic_ϵ ∈ { 0 , 1 , 2 }</annotation></semantics></math>.
Data and query points both sampled from the same
clustered-orthogonal-ellipsoid distribution.</figcaption>
</figure>
<figure id="S6.F5" class="ltx_figure">
<div class="ltx_flex_figure">

<div class="ltx_flex_cell 
                  ">
<table id="S6.F5.2" class="ltx_tabular ltx_centering ltx_align_middle">
<tbody class="ltx_tbody">
<tr id="S6.F5.2.2" class="ltx_tr">
<td id="S6.F5.1.1.1" class="ltx_td ltx_align_center"><img src="/html/cs/9901013/assets/x6.png" id="S6.F5.1.1.1.g1" class="ltx_graphics ltx_img_portrait" width="326" height="422" alt="Refer to caption"></td>
<td id="S6.F5.2.2.2" class="ltx_td ltx_align_center"><img src="/html/cs/9901013/assets/x7.png" id="S6.F5.2.2.2.g1" class="ltx_graphics ltx_img_portrait" width="326" height="422" alt="Refer to caption"></td>
</tr>
<tr id="S6.F5.2.3.1" class="ltx_tr">
<td id="S6.F5.2.3.1.1" class="ltx_td ltx_align_center">(a)</td>
<td id="S6.F5.2.3.1.2" class="ltx_td ltx_align_center">(b)</td>
</tr>
</tbody>
</table>
</div>
<div class="ltx_flex_break"></div>
<div class="ltx_flex_cell 
                  ">
<p id="S6.F5.3" class="ltx_p ltx_align_center ltx_align_center"><span id="S6.F5.3.1" class="ltx_text"><img src="/html/cs/9901013/assets/x8.png" id="S6.F5.3.1.g1" class="ltx_graphics ltx_img_portrait" width="326" height="422" alt="Refer to caption"></span></p>
</div>
<div class="ltx_flex_cell 
                  ">
<p id="S6.F5.8" class="ltx_p ltx_align_center">(c)</p>
</div>
</div>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 5: </span>Number of nodes visited versus <math id="S6.F5.6.m1.1" class="ltx_Math" alttext="\sigma_{\rm thin}" display="inline"><semantics id="S6.F5.6.m1.1b"><msub id="S6.F5.6.m1.1.1" xref="S6.F5.6.m1.1.1.cmml"><mi id="S6.F5.6.m1.1.1.2" xref="S6.F5.6.m1.1.1.2.cmml">σ</mi><mi id="S6.F5.6.m1.1.1.3" xref="S6.F5.6.m1.1.1.3.cmml">thin</mi></msub><annotation-xml encoding="MathML-Content" id="S6.F5.6.m1.1c"><apply id="S6.F5.6.m1.1.1.cmml" xref="S6.F5.6.m1.1.1"><csymbol cd="ambiguous" id="S6.F5.6.m1.1.1.1.cmml" xref="S6.F5.6.m1.1.1">subscript</csymbol><ci id="S6.F5.6.m1.1.1.2.cmml" xref="S6.F5.6.m1.1.1.2">𝜎</ci><ci id="S6.F5.6.m1.1.1.3.cmml" xref="S6.F5.6.m1.1.1.3">thin</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S6.F5.6.m1.1d">\sigma_{\rm thin}</annotation><annotation encoding="application/x-llamapun" id="S6.F5.6.m1.1e">italic_σ start_POSTSUBSCRIPT roman_thin end_POSTSUBSCRIPT</annotation></semantics></math> for
<math id="S6.F5.7.m2.3" class="ltx_Math" alttext="\epsilon\in\{0,1,2\}" display="inline"><semantics id="S6.F5.7.m2.3b"><mrow id="S6.F5.7.m2.3.4" xref="S6.F5.7.m2.3.4.cmml"><mi id="S6.F5.7.m2.3.4.2" xref="S6.F5.7.m2.3.4.2.cmml">ϵ</mi><mo id="S6.F5.7.m2.3.4.1" xref="S6.F5.7.m2.3.4.1.cmml">∈</mo><mrow id="S6.F5.7.m2.3.4.3.2" xref="S6.F5.7.m2.3.4.3.1.cmml"><mo stretchy="false" id="S6.F5.7.m2.3.4.3.2.1" xref="S6.F5.7.m2.3.4.3.1.cmml">{</mo><mn id="S6.F5.7.m2.1.1" xref="S6.F5.7.m2.1.1.cmml">0</mn><mo id="S6.F5.7.m2.3.4.3.2.2" xref="S6.F5.7.m2.3.4.3.1.cmml">,</mo><mn id="S6.F5.7.m2.2.2" xref="S6.F5.7.m2.2.2.cmml">1</mn><mo id="S6.F5.7.m2.3.4.3.2.3" xref="S6.F5.7.m2.3.4.3.1.cmml">,</mo><mn id="S6.F5.7.m2.3.3" xref="S6.F5.7.m2.3.3.cmml">2</mn><mo stretchy="false" id="S6.F5.7.m2.3.4.3.2.4" xref="S6.F5.7.m2.3.4.3.1.cmml">}</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S6.F5.7.m2.3c"><apply id="S6.F5.7.m2.3.4.cmml" xref="S6.F5.7.m2.3.4"><in id="S6.F5.7.m2.3.4.1.cmml" xref="S6.F5.7.m2.3.4.1"></in><ci id="S6.F5.7.m2.3.4.2.cmml" xref="S6.F5.7.m2.3.4.2">italic-ϵ</ci><set id="S6.F5.7.m2.3.4.3.1.cmml" xref="S6.F5.7.m2.3.4.3.2"><cn type="integer" id="S6.F5.7.m2.1.1.cmml" xref="S6.F5.7.m2.1.1">0</cn><cn type="integer" id="S6.F5.7.m2.2.2.cmml" xref="S6.F5.7.m2.2.2">1</cn><cn type="integer" id="S6.F5.7.m2.3.3.cmml" xref="S6.F5.7.m2.3.3">2</cn></set></apply></annotation-xml><annotation encoding="application/x-tex" id="S6.F5.7.m2.3d">\epsilon\in\{0,1,2\}</annotation><annotation encoding="application/x-llamapun" id="S6.F5.7.m2.3e">italic_ϵ ∈ { 0 , 1 , 2 }</annotation></semantics></math>.
Data and query points both sampled from the same
clustered-ellipsoid distribution.</figcaption>
</figure>
<figure id="S6.F6" class="ltx_figure">
<div class="ltx_flex_figure">

<div class="ltx_flex_cell 
                  ">
<table id="S6.F6.2" class="ltx_tabular ltx_centering ltx_align_middle">
<tbody class="ltx_tbody">
<tr id="S6.F6.2.2" class="ltx_tr">
<td id="S6.F6.1.1.1" class="ltx_td ltx_align_center"><img src="/html/cs/9901013/assets/x9.png" id="S6.F6.1.1.1.g1" class="ltx_graphics ltx_img_portrait" width="326" height="422" alt="Refer to caption"></td>
<td id="S6.F6.2.2.2" class="ltx_td ltx_align_center"><img src="/html/cs/9901013/assets/x10.png" id="S6.F6.2.2.2.g1" class="ltx_graphics ltx_img_portrait" width="326" height="422" alt="Refer to caption"></td>
</tr>
<tr id="S6.F6.2.3.1" class="ltx_tr">
<td id="S6.F6.2.3.1.1" class="ltx_td ltx_align_center">(a)</td>
<td id="S6.F6.2.3.1.2" class="ltx_td ltx_align_center">(b)</td>
</tr>
</tbody>
</table>
</div>
<div class="ltx_flex_break"></div>
<div class="ltx_flex_cell 
                  ">
<p id="S6.F6.3" class="ltx_p ltx_align_center ltx_align_center"><span id="S6.F6.3.1" class="ltx_text"><img src="/html/cs/9901013/assets/x11.png" id="S6.F6.3.1.g1" class="ltx_graphics ltx_img_portrait" width="326" height="422" alt="Refer to caption"></span></p>
</div>
<div class="ltx_flex_cell 
                  ">
<p id="S6.F6.8" class="ltx_p ltx_align_center">(c)</p>
</div>
</div>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 6: </span>Number of nodes visited versus <math id="S6.F6.6.m1.1" class="ltx_Math" alttext="\sigma_{\rm thin}" display="inline"><semantics id="S6.F6.6.m1.1b"><msub id="S6.F6.6.m1.1.1" xref="S6.F6.6.m1.1.1.cmml"><mi id="S6.F6.6.m1.1.1.2" xref="S6.F6.6.m1.1.1.2.cmml">σ</mi><mi id="S6.F6.6.m1.1.1.3" xref="S6.F6.6.m1.1.1.3.cmml">thin</mi></msub><annotation-xml encoding="MathML-Content" id="S6.F6.6.m1.1c"><apply id="S6.F6.6.m1.1.1.cmml" xref="S6.F6.6.m1.1.1"><csymbol cd="ambiguous" id="S6.F6.6.m1.1.1.1.cmml" xref="S6.F6.6.m1.1.1">subscript</csymbol><ci id="S6.F6.6.m1.1.1.2.cmml" xref="S6.F6.6.m1.1.1.2">𝜎</ci><ci id="S6.F6.6.m1.1.1.3.cmml" xref="S6.F6.6.m1.1.1.3">thin</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S6.F6.6.m1.1d">\sigma_{\rm thin}</annotation><annotation encoding="application/x-llamapun" id="S6.F6.6.m1.1e">italic_σ start_POSTSUBSCRIPT roman_thin end_POSTSUBSCRIPT</annotation></semantics></math> for
<math id="S6.F6.7.m2.3" class="ltx_Math" alttext="\epsilon\in\{0,1,2\}" display="inline"><semantics id="S6.F6.7.m2.3b"><mrow id="S6.F6.7.m2.3.4" xref="S6.F6.7.m2.3.4.cmml"><mi id="S6.F6.7.m2.3.4.2" xref="S6.F6.7.m2.3.4.2.cmml">ϵ</mi><mo id="S6.F6.7.m2.3.4.1" xref="S6.F6.7.m2.3.4.1.cmml">∈</mo><mrow id="S6.F6.7.m2.3.4.3.2" xref="S6.F6.7.m2.3.4.3.1.cmml"><mo stretchy="false" id="S6.F6.7.m2.3.4.3.2.1" xref="S6.F6.7.m2.3.4.3.1.cmml">{</mo><mn id="S6.F6.7.m2.1.1" xref="S6.F6.7.m2.1.1.cmml">0</mn><mo id="S6.F6.7.m2.3.4.3.2.2" xref="S6.F6.7.m2.3.4.3.1.cmml">,</mo><mn id="S6.F6.7.m2.2.2" xref="S6.F6.7.m2.2.2.cmml">1</mn><mo id="S6.F6.7.m2.3.4.3.2.3" xref="S6.F6.7.m2.3.4.3.1.cmml">,</mo><mn id="S6.F6.7.m2.3.3" xref="S6.F6.7.m2.3.3.cmml">2</mn><mo stretchy="false" id="S6.F6.7.m2.3.4.3.2.4" xref="S6.F6.7.m2.3.4.3.1.cmml">}</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S6.F6.7.m2.3c"><apply id="S6.F6.7.m2.3.4.cmml" xref="S6.F6.7.m2.3.4"><in id="S6.F6.7.m2.3.4.1.cmml" xref="S6.F6.7.m2.3.4.1"></in><ci id="S6.F6.7.m2.3.4.2.cmml" xref="S6.F6.7.m2.3.4.2">italic-ϵ</ci><set id="S6.F6.7.m2.3.4.3.1.cmml" xref="S6.F6.7.m2.3.4.3.2"><cn type="integer" id="S6.F6.7.m2.1.1.cmml" xref="S6.F6.7.m2.1.1">0</cn><cn type="integer" id="S6.F6.7.m2.2.2.cmml" xref="S6.F6.7.m2.2.2">1</cn><cn type="integer" id="S6.F6.7.m2.3.3.cmml" xref="S6.F6.7.m2.3.3">2</cn></set></apply></annotation-xml><annotation encoding="application/x-tex" id="S6.F6.7.m2.3d">\epsilon\in\{0,1,2\}</annotation><annotation encoding="application/x-llamapun" id="S6.F6.7.m2.3e">italic_ϵ ∈ { 0 , 1 , 2 }</annotation></semantics></math>.
Data sampled from the clustered-orthogonal-ellipsoid distribution
and query points from the uniform distribution.</figcaption>
</figure>
<figure id="S6.F7" class="ltx_figure">
<div class="ltx_flex_figure">

<div class="ltx_flex_cell 
                  ">
<table id="S6.F7.2" class="ltx_tabular ltx_centering ltx_align_middle">
<tbody class="ltx_tbody">
<tr id="S6.F7.2.2" class="ltx_tr">
<td id="S6.F7.1.1.1" class="ltx_td ltx_align_center"><img src="/html/cs/9901013/assets/x12.png" id="S6.F7.1.1.1.g1" class="ltx_graphics ltx_img_portrait" width="326" height="422" alt="Refer to caption"></td>
<td id="S6.F7.2.2.2" class="ltx_td ltx_align_center"><img src="" id="S6.F7.2.2.2.g1" class="ltx_graphics ltx_missing ltx_missing_image" alt="Refer to caption"></td>
</tr>
<tr id="S6.F7.2.3.1" class="ltx_tr">
<td id="S6.F7.2.3.1.1" class="ltx_td ltx_align_center">(a)</td>
<td id="S6.F7.2.3.1.2" class="ltx_td ltx_align_center">(b)</td>
</tr>
</tbody>
</table>
</div>
<div class="ltx_flex_break"></div>
<div class="ltx_flex_cell 
                  ">
<p id="S6.F7.3" class="ltx_p ltx_align_center ltx_align_center"><span id="S6.F7.3.1" class="ltx_text"><img src="/html/cs/9901013/assets/x14.png" id="S6.F7.3.1.g1" class="ltx_graphics ltx_img_portrait" width="326" height="422" alt="Refer to caption"></span></p>
</div>
<div class="ltx_flex_cell 
                  ">
<p id="S6.F7.8" class="ltx_p ltx_align_center">(c)</p>
</div>
</div>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 7: </span>Number of nodes visited versus <math id="S6.F7.6.m1.1" class="ltx_Math" alttext="\sigma_{\rm thin}" display="inline"><semantics id="S6.F7.6.m1.1b"><msub id="S6.F7.6.m1.1.1" xref="S6.F7.6.m1.1.1.cmml"><mi id="S6.F7.6.m1.1.1.2" xref="S6.F7.6.m1.1.1.2.cmml">σ</mi><mi id="S6.F7.6.m1.1.1.3" xref="S6.F7.6.m1.1.1.3.cmml">thin</mi></msub><annotation-xml encoding="MathML-Content" id="S6.F7.6.m1.1c"><apply id="S6.F7.6.m1.1.1.cmml" xref="S6.F7.6.m1.1.1"><csymbol cd="ambiguous" id="S6.F7.6.m1.1.1.1.cmml" xref="S6.F7.6.m1.1.1">subscript</csymbol><ci id="S6.F7.6.m1.1.1.2.cmml" xref="S6.F7.6.m1.1.1.2">𝜎</ci><ci id="S6.F7.6.m1.1.1.3.cmml" xref="S6.F7.6.m1.1.1.3">thin</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S6.F7.6.m1.1d">\sigma_{\rm thin}</annotation><annotation encoding="application/x-llamapun" id="S6.F7.6.m1.1e">italic_σ start_POSTSUBSCRIPT roman_thin end_POSTSUBSCRIPT</annotation></semantics></math> for
<math id="S6.F7.7.m2.3" class="ltx_Math" alttext="\epsilon\in\{0,1,2\}" display="inline"><semantics id="S6.F7.7.m2.3b"><mrow id="S6.F7.7.m2.3.4" xref="S6.F7.7.m2.3.4.cmml"><mi id="S6.F7.7.m2.3.4.2" xref="S6.F7.7.m2.3.4.2.cmml">ϵ</mi><mo id="S6.F7.7.m2.3.4.1" xref="S6.F7.7.m2.3.4.1.cmml">∈</mo><mrow id="S6.F7.7.m2.3.4.3.2" xref="S6.F7.7.m2.3.4.3.1.cmml"><mo stretchy="false" id="S6.F7.7.m2.3.4.3.2.1" xref="S6.F7.7.m2.3.4.3.1.cmml">{</mo><mn id="S6.F7.7.m2.1.1" xref="S6.F7.7.m2.1.1.cmml">0</mn><mo id="S6.F7.7.m2.3.4.3.2.2" xref="S6.F7.7.m2.3.4.3.1.cmml">,</mo><mn id="S6.F7.7.m2.2.2" xref="S6.F7.7.m2.2.2.cmml">1</mn><mo id="S6.F7.7.m2.3.4.3.2.3" xref="S6.F7.7.m2.3.4.3.1.cmml">,</mo><mn id="S6.F7.7.m2.3.3" xref="S6.F7.7.m2.3.3.cmml">2</mn><mo stretchy="false" id="S6.F7.7.m2.3.4.3.2.4" xref="S6.F7.7.m2.3.4.3.1.cmml">}</mo></mrow></mrow><annotation-xml encoding="MathML-Content" id="S6.F7.7.m2.3c"><apply id="S6.F7.7.m2.3.4.cmml" xref="S6.F7.7.m2.3.4"><in id="S6.F7.7.m2.3.4.1.cmml" xref="S6.F7.7.m2.3.4.1"></in><ci id="S6.F7.7.m2.3.4.2.cmml" xref="S6.F7.7.m2.3.4.2">italic-ϵ</ci><set id="S6.F7.7.m2.3.4.3.1.cmml" xref="S6.F7.7.m2.3.4.3.2"><cn type="integer" id="S6.F7.7.m2.1.1.cmml" xref="S6.F7.7.m2.1.1">0</cn><cn type="integer" id="S6.F7.7.m2.2.2.cmml" xref="S6.F7.7.m2.2.2">1</cn><cn type="integer" id="S6.F7.7.m2.3.3.cmml" xref="S6.F7.7.m2.3.3">2</cn></set></apply></annotation-xml><annotation encoding="application/x-tex" id="S6.F7.7.m2.3d">\epsilon\in\{0,1,2\}</annotation><annotation encoding="application/x-llamapun" id="S6.F7.7.m2.3e">italic_ϵ ∈ { 0 , 1 , 2 }</annotation></semantics></math>.
Data sampled from the clustered-ellipsoid distribution
and query points from the uniform distribution.</figcaption>
</figure>
<figure id="S6.F8" class="ltx_figure">
<table id="S6.F8.4" class="ltx_tabular ltx_centering ltx_align_middle">
<tbody class="ltx_tbody">
<tr id="S6.F8.2.2" class="ltx_tr">
<td id="S6.F8.1.1.1" class="ltx_td ltx_align_center"><img src="/html/cs/9901013/assets/x15.png" id="S6.F8.1.1.1.g1" class="ltx_graphics ltx_img_portrait" width="326" height="422" alt="Refer to caption"></td>
<td id="S6.F8.2.2.2" class="ltx_td ltx_align_center"><img src="" id="S6.F8.2.2.2.g1" class="ltx_graphics ltx_missing ltx_missing_image" alt="Refer to caption"></td>
</tr>
<tr id="S6.F8.4.5.1" class="ltx_tr">
<td id="S6.F8.4.5.1.1" class="ltx_td ltx_align_center">(a)</td>
<td id="S6.F8.4.5.1.2" class="ltx_td ltx_align_center">(b)</td>
</tr>
<tr id="S6.F8.4.4" class="ltx_tr">
<td id="S6.F8.3.3.1" class="ltx_td ltx_align_center"><img src="/html/cs/9901013/assets/x17.png" id="S6.F8.3.3.1.g1" class="ltx_graphics ltx_img_portrait" width="326" height="422" alt="Refer to caption"></td>
<td id="S6.F8.4.4.2" class="ltx_td ltx_align_center"><img src="/html/cs/9901013/assets/x18.png" id="S6.F8.4.4.2.g1" class="ltx_graphics ltx_img_portrait" width="326" height="422" alt="Refer to caption"></td>
</tr>
<tr id="S6.F8.4.6.2" class="ltx_tr">
<td id="S6.F8.4.6.2.1" class="ltx_td ltx_align_center">(c)</td>
<td id="S6.F8.4.6.2.2" class="ltx_td ltx_align_center">(d)</td>
</tr>
</tbody>
</table>
<figcaption class="ltx_caption"><span class="ltx_tag ltx_tag_figure">Figure 8: </span>Time to construct minimum-ambiguity tree versus
<math id="S6.F8.6.m1.1" class="ltx_Math" alttext="\sigma_{\rm thin}" display="inline"><semantics id="S6.F8.6.m1.1b"><msub id="S6.F8.6.m1.1.1" xref="S6.F8.6.m1.1.1.cmml"><mi id="S6.F8.6.m1.1.1.2" xref="S6.F8.6.m1.1.1.2.cmml">σ</mi><mi id="S6.F8.6.m1.1.1.3" xref="S6.F8.6.m1.1.1.3.cmml">thin</mi></msub><annotation-xml encoding="MathML-Content" id="S6.F8.6.m1.1c"><apply id="S6.F8.6.m1.1.1.cmml" xref="S6.F8.6.m1.1.1"><csymbol cd="ambiguous" id="S6.F8.6.m1.1.1.1.cmml" xref="S6.F8.6.m1.1.1">subscript</csymbol><ci id="S6.F8.6.m1.1.1.2.cmml" xref="S6.F8.6.m1.1.1.2">𝜎</ci><ci id="S6.F8.6.m1.1.1.3.cmml" xref="S6.F8.6.m1.1.1.3">thin</ci></apply></annotation-xml><annotation encoding="application/x-tex" id="S6.F8.6.m1.1d">\sigma_{\rm thin}</annotation><annotation encoding="application/x-llamapun" id="S6.F8.6.m1.1e">italic_σ start_POSTSUBSCRIPT roman_thin end_POSTSUBSCRIPT</annotation></semantics></math>.</figcaption>
</figure>
</article>
</div>
<div class="ar5iv-footer"><a href="/html/cs/9901012" class="ar5iv-nav-button ar5iv-nav-button-prev">◄</a>
    <a class="ar5iv-home-button" href="/"><img height="40" alt="ar5iv homepage" src="/assets/ar5iv.png"></a>
    <a href="/feeling_lucky" class="ar5iv-text-button">Feeling<br>lucky?</a>
    <a href="/log/cs/9901013" class="ar5iv-text-button ar5iv-severity-warning">Conversion<br>report</a>
    <a class="ar5iv-text-button" target="_blank" href="https://github.com/dginev/ar5iv/issues/new?template=improve-article--arxiv-id-.md&title=Improve+article+cs/9901013">Report<br>an issue</a>
    <a href="https://arxiv.org/abs/cs/9901013" class="ar5iv-text-button arxiv-ui-theme">View&nbsp;original<br>on&nbsp;arXiv</a><a href="/html/cs/9901014" class="ar5iv-nav-button ar5iv-nav-button-next">►</a>
</div><footer class="ltx_page_footer">
<a class="ar5iv-toggle-color-scheme" href="javascript:toggleColorScheme()" title="Toggle ar5iv color scheme"><span class="color-scheme-icon"></span></a>
<a class="ar5iv-footer-button" href="https://arxiv.org/help/license" target="_blank">Copyright</a>
<a class="ar5iv-footer-button" href="https://arxiv.org/help/policies/privacy_policy" target="_blank">Privacy Policy</a>

<div class="ltx_page_logo">Generated  on Sun Dec 18 07:58:15 2022 by <a target="_blank" href="http://dlmf.nist.gov/LaTeXML/" class="ltx_LaTeXML_logo"><span style="letter-spacing:-0.2em; margin-right:0.1em;">L<span style="font-size:70%;position:relative; bottom:2.2pt;">A</span>T<span style="position:relative; bottom:-0.4ex;">E</span></span><span class="ltx_font_smallcaps">xml</span><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAOCAYAAAD5YeaVAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wKExQZLWTEaOUAAAAddEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIFRoZSBHSU1Q72QlbgAAAdpJREFUKM9tkL+L2nAARz9fPZNCKFapUn8kyI0e4iRHSR1Kb8ng0lJw6FYHFwv2LwhOpcWxTjeUunYqOmqd6hEoRDhtDWdA8ApRYsSUCDHNt5ul13vz4w0vWCgUnnEc975arX6ORqN3VqtVZbfbTQC4uEHANM3jSqXymFI6yWazP2KxWAXAL9zCUa1Wy2tXVxheKA9YNoR8Pt+aTqe4FVVVvz05O6MBhqUIBGk8Hn8HAOVy+T+XLJfLS4ZhTiRJgqIoVBRFIoric47jPnmeB1mW/9rr9ZpSSn3Lsmir1fJZlqWlUonKsvwWwD8ymc/nXwVBeLjf7xEKhdBut9Hr9WgmkyGEkJwsy5eHG5vN5g0AKIoCAEgkEkin0wQAfN9/cXPdheu6P33fBwB4ngcAcByHJpPJl+fn54mD3Gg0NrquXxeLRQAAwzAYj8cwTZPwPH9/sVg8PXweDAauqqr2cDjEer1GJBLBZDJBs9mE4zjwfZ85lAGg2+06hmGgXq+j3+/DsixYlgVN03a9Xu8jgCNCyIegIAgx13Vfd7vdu+FweG8YRkjXdWy329+dTgeSJD3ieZ7RNO0VAXAPwDEAO5VKndi2fWrb9jWl9Esul6PZbDY9Go1OZ7PZ9z/lyuD3OozU2wAAAABJRU5ErkJggg==" alt="[LOGO]"></a>
</div></footer>
</div>

    <script>
      var canMathML = typeof(MathMLElement) == "function";
      if (!canMathML) {
        var body = document.querySelector("body");
        body.firstElementChild.setAttribute('style', 'opacity: 0;');
        var loading = document.createElement("div");
        loading.setAttribute("id", "mathjax-loading-spinner");
        var message = document.createElement("div");
        message.setAttribute("id", "mathjax-loading-message");
        message.innerText = "Typesetting Equations...";
        body.prepend(loading);
        body.prepend(message);

        var el = document.createElement("script");
        el.src = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js";
        document.querySelector("head").appendChild(el);

        window.MathJax = {
          startup: {
            pageReady: () => {
              return MathJax.startup.defaultPageReady().then(() => {
                body.removeChild(loading);
                body.removeChild(message);
                body.firstElementChild.removeAttribute('style');
              }); } } };
      }
    </script>
    <script>
    // Auxiliary function, building the preview feature when
    // an inline citation is clicked
    function clicked_cite(e) {
      e.preventDefault();
      let cite = this.closest('.ltx_cite');
      let next = cite.nextSibling;
      if (next && next.nodeType == Node.ELEMENT_NODE && next.getAttribute('class') == "ar5iv-bibitem-preview") {
        next.remove();
        return; }
      // Before adding a preview modal,
      // cleanup older previews, in case they're still open
      document.querySelectorAll('span.ar5iv-bibitem-preview').forEach(function(node) {
        node.remove();
      })

      // Create the preview
      preview = document.createElement('span');
      preview.setAttribute('class','ar5iv-bibitem-preview');
      let target = document.getElementById(this.getAttribute('href').slice(1));
      target.childNodes.forEach(function (child) {
        preview.append(child.cloneNode(true));
      });
      let close_x = document.createElement('button');
      close_x.setAttribute("aria-label","Close modal for bibliography item preview");
      close_x.textContent = "×";
      close_x.setAttribute('class', 'ar5iv-button-close-preview');
      close_x.setAttribute('onclick','this.parentNode.remove()');
      preview.append(close_x);
      preview.querySelectorAll('.ltx_tag_bibitem').forEach(function(node) {
        node.remove();
      });
      cite.parentNode.insertBefore(preview, cite.nextSibling);
      return;
    }
    // Global Document initialization:
    // - assign the preview feature to all inline citation links
    document.querySelectorAll(".ltx_cite .ltx_ref").forEach(function (link) {
      link.addEventListener("click", clicked_cite);
    });
    </script>
    </body>
</html>
